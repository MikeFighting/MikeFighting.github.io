<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Write the Code,Change the World" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:type" content="website">
<meta property="og:title" content="击水湘江">
<meta property="og:url" content="https://mikefighting.github.io/index.html">
<meta property="og:site_name" content="击水湘江">
<meta property="og:description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="击水湘江">
<meta name="twitter:description" content="努力让明天的自己爱上今天的自己！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://mikefighting.github.io/"/>





  <title>击水湘江 - Keeep Refactoring, Keeep Moving!</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">击水湘江</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Keeep Refactoring, Keeep Moving!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/11/vapor-prepare-data-base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/11/vapor-prepare-data-base/" itemprop="url">Swift后端Vapor安装数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-11T09:52:02+08:00">
                2017-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1513759-b14c0ae08140a1d3.png" alt="MySQL"></p>
<p>Vapor中使用<code>Fluent</code>作为数据库的驱动，它现在可支持的数据库类型有：MySQL，SQL lite，MongoDB，PostgreSQL。因为MySQL用得较多，我们先来学习它。</p>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="安装MySQL-Provider"><a href="#安装MySQL-Provider" class="headerlink" title="安装MySQL-Provider"></a>安装<code>MySQL-Provider</code></h3><p>在<code>Package.swift</code>文件中加入</p>
<pre><code>.Package(url: &quot;https://github.com/vapor/mysql-provider.git&quot;, majorVersion: 2)
</code></pre><p>然后执行执行<code>vapor clean</code>和<code>rm -rf .build Package.pins</code>，最后执行<code>vapor update</code>和<code>vapor build</code>。<br>安装完MySql之后报错<code>mysql/mysql.h file not found</code>以及<code>Could not build Objective-C module CMySQL</code>，这时因为MySql数据库需要更新，执行下面的指令</p>
<pre><code>brew update &amp;&amp; brew install mysql vapor/tap/cmysql pkg-config
</code></pre><p>然后再执行<code>vapor xcode</code>就可以运行成功了。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="在Droplet中添加驱动"><a href="#在Droplet中添加驱动" class="headerlink" title="在Droplet中添加驱动"></a>在Droplet中添加驱动</h3><p>我们要往<code>Config</code>对象中添加相应的<code>Provider</code>，如下所示</p>
<pre><code class="Swift"><span class="keyword">import</span> MySQLProvider
<span class="keyword">let</span> config = <span class="keyword">try</span> <span class="type">Config</span>()
<span class="keyword">try</span> config.addProvider(<span class="type">MySQLProvider</span>.<span class="type">Provider</span>.<span class="keyword">self</span>)
<span class="keyword">let</span> drop = <span class="keyword">try</span> <span class="type">Droplet</span>(config)
</code></pre>
<h3 id="配置Fluent"><a href="#配置Fluent" class="headerlink" title="配置Fluent"></a>配置Fluent</h3><p>在<code>fluent.json</code>文件中加入如下的配置</p>
<pre><code>{
    &quot;//&quot;: &quot;The underlying database technology to use.&quot;,
    &quot;//&quot;: &quot;memory: SQLite in-memory DB.&quot;,
    &quot;//&quot;: &quot;sqlite: Persisted SQLite DB (configure with sqlite.json)&quot;,
    &quot;//&quot;: &quot;Other drivers are available through Vapor providers&quot;,
    &quot;//&quot;: &quot;https://github.com/search?q=topic:vapor-provider+topic:database&quot;,
    &quot;driver&quot;: &quot;mysql&quot;,
}
</code></pre><h3 id="配置MySQL"><a href="#配置MySQL" class="headerlink" title="配置MySQL"></a>配置MySQL</h3><p>在Config文件夹下面新建文件<code>mysql.json</code>，并添加如下内容</p>
<pre><code>{
    &quot;hostname&quot;: &quot;localhost&quot;,
    &quot;user&quot;: &quot;root&quot;,
    &quot;password&quot;: &quot;yourPassword&quot;,
    &quot;database&quot;: &quot;yourDatabase&quot;
    &quot;poort&quot;: &quot;3306&quot;
}      
</code></pre><p>也可以将证书作为url传入MySQL。</p>
<pre><code>{
&quot;url&quot;: &quot;http://root:password@172.0.0.1/hello&quot;
}
</code></pre><h3 id="多份读取（Read-Replicas）"><a href="#多份读取（Read-Replicas）" class="headerlink" title="多份读取（Read Replicas）"></a>多份读取（Read Replicas）</h3><p>多份读取可以通过配置hostname或者是<code>readReplicas</code>接口数组来进行配置。在mysql.josn中加入：</p>
<pre><code>{
   {
    &quot;master&quot;: &quot;master.mysql.foo.com&quot;,
    &quot;readReplicas&quot;: [&quot;read01.mysql.foo.com&quot;, &quot;read02.mysql.foo.com&quot;],
    &quot;user&quot;: &quot;root&quot;,
    &quot;password&quot;: &quot;password&quot;,
    &quot;database&quot;: &quot;hello&quot;
   }
}
</code></pre><p><em>Tip:也可以将readReplicas用字符串表示，多个字符串用逗号分隔开。</em></p>
<h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><p>你可以在Routes中得到<code>MySQL Driver</code>（前提是在你自己的MySQL数据库中创建了<code>your_table</code>)表。</p>
<pre><code class="Swift"><span class="keyword">import</span> MySQLProvider
<span class="keyword">get</span>(<span class="string">"mysql"</span>) { req <span class="keyword">in</span>

           <span class="keyword">let</span> mysqlDriver = <span class="keyword">try</span> <span class="keyword">self</span>.mysql()
           <span class="keyword">let</span> user = <span class="keyword">try</span> mysqlDriver.raw(<span class="string">"SELECT * FROM your_table"</span>)
           <span class="keyword">let</span> reusltJon = <span class="keyword">try</span> <span class="type">JSON</span>(node: user)
           <span class="keyword">return</span> reusltJon

       }
</code></pre>
<p>然后在浏览器中输入<code>http://localhost:8080/mysql</code>，如果看到输出了相应的JSON传就证明安装成功了。</p>
<h3 id="配置缓存"><a href="#配置缓存" class="headerlink" title="配置缓存"></a>配置缓存</h3><p>在<code>Config/droplet.json</code>里面可以配置<code>fluent</code>缓存，这里<code>fluent</code>缓存走的是<code>mysql</code>：</p>
<pre><code class="Swift">{
 <span class="string">"driver"</span>: <span class="string">"fluent"</span>
}
</code></pre>
<p>下次，当启动Droplet的时候，如果出现：</p>
<pre><code class="bash">Database prepared
</code></pre>
<p>就说明安装成功了。</p>
<h3 id="帮助："><a href="#帮助：" class="headerlink" title="帮助："></a>帮助：</h3><ol>
<li>如果运行出现 </li>
</ol>
<pre><code class="bash">The current <span class="built_in">hash</span> key <span class="string">"0000000000000000"</span> is not secure.
Update hash.key <span class="keyword">in</span> Config/crypto.json before using <span class="keyword">in</span> production.
Use `openssl rand -base64 &lt;length&gt;` to generate a random string.
The current cipher key <span class="string">"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="</span> is not secure.
Update cipher.key <span class="keyword">in</span> Config/crypto.json before using <span class="keyword">in</span> production.
Use `openssl rand -base64 32` to generate a random string.
</code></pre>
<p>这说明我们需要运行<code>openssl rand -base64 &lt;length&gt;</code>，以及<code>openssl rand -base64 32</code>来产生新的hash key和cipher key，并且将原来的数值替换掉。</p>
<ol>
<li>MySql更改密码：</li>
</ol>
<p>请参考：</p>
<ol>
<li><a href="https://stackoverflow.com/questions/2101694/mysql-how-to-set-root-password-to-null" target="_blank" rel="external">https://stackoverflow.com/questions/2101694/mysql-how-to-set-root-password-to-null</a> </li>
<li><a href="https://stackoverflow.com/questions/30692812/mysql-user-db-does-not-have-password-columns-installing-mysql-on-osx" target="_blank" rel="external">https://stackoverflow.com/questions/30692812/mysql-user-db-does-not-have-password-columns-installing-mysql-on-osx</a></li>
<li><a href="https://sraji.wordpress.com/2011/08/10/how-to-reset-mysql-root-password/" target="_blank" rel="external">https://sraji.wordpress.com/2011/08/10/how-to-reset-mysql-root-password/</a></li>
<li><a href="https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating" target="_blank" rel="external">https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating</a></li>
<li><a href="https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating/9704993#comment16367803_9704993" target="_blank" rel="external">https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating/9704993#comment16367803_9704993</a></li>
</ol>
<p>需要注意的是：<em><code>sudo mysqld_safe --skip-grant-tables</code>执行完之后，要重新打开一个终端执行</em>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/10/swift-server-vapor-validation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/10/swift-server-vapor-validation/" itemprop="url">Vapor中的数据校验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-10T07:10:13+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>   <img src="http://upload-images.jianshu.io/upload_images/1513759-267da7a2929f0562.jpg" alt="Validation"><br>服务端在有数据请求时需要对数据进行校验然后返回响应的校验结果，比如要求必须输入邮箱，必须输入电话等，Validation工具给我们提供了非常方便的常用操作，接下来就对其使用过程做以总结（<em>本文用到的是Validation 1.2.0版本</em>）。</p>
<h2 id="Vapor中添加Validation依赖包"><a href="#Vapor中添加Validation依赖包" class="headerlink" title="Vapor中添加Validation依赖包"></a>Vapor中添加Validation依赖包</h2><p>在<code>Package.swift</code>文件中添加如下的依赖，比如：</p>
<pre><code>.Package(url: &quot;https://github.com/vapor/vapor.git&quot;, majorVersion: 2),
.Package(url: &quot;https://github.com/vapor/validation-provider.git&quot;, majorVersion: 1)
</code></pre><blockquote>
<p>之后要执行<code>vapor clean</code>或者<code>rm -rf .build Package.pins</code>，然后执行<code>vapor update</code>或者<code>swift package update</code>，<code>vapor xcode</code>，这样才可以安装好依赖。</p>
</blockquote>
<h2 id="校验实例"><a href="#校验实例" class="headerlink" title="校验实例"></a>校验实例</h2><h3 id="Alphanumeric校验"><a href="#Alphanumeric校验" class="headerlink" title="Alphanumeric校验"></a>Alphanumeric校验</h3><p> 接下来我们来做一个简单的校验，校验输入的字符串是否是a-z或者0-9在请求中加入如下代码：</p>
<pre><code class="Swift"><span class="keyword">get</span>(<span class="string">"alpha"</span>) { request <span class="keyword">in</span>
            <span class="keyword">guard</span> <span class="keyword">let</span> input = request.data[<span class="string">"input"</span>]?.string <span class="keyword">else</span> {
                <span class="keyword">throw</span> <span class="type">Abort</span>.badRequest
            }
            <span class="keyword">let</span> validInput = <span class="keyword">try</span> input.tested(by: <span class="type">OnlyAlphanumeric</span>())
            <span class="keyword">return</span> <span class="string">"validated:<span class="subst">\(validInput)</span>"</span>
}
</code></pre>
<p>我们运行程序，然后在PostMan中输入<a href="http://localhost:8080/alpha?input=example@github.com，这时会得到下面的返回值：" target="_blank" rel="external">http://localhost:8080/alpha?input=example@github.com，这时会得到下面的返回值：</a></p>
<pre><code class="Swift">{<span class="string">"identifier"</span>:<span class="string">"Validation.ValidatorError.failure"</span>,<span class="string">"reason"</span>:<span class="string">"Internal Server Error"</span>,<span class="string">"debugReason"</span>:<span class="string">"OnlyAlphanumeric failed validation: example@github.com is not alphanumeric"</span>,<span class="string">"error"</span>:<span class="literal">true</span>}
</code></pre>
<p>这也就说明了，我们传输的问本内容不符合<code>alphanumeric</code>。<br>然后我们将URL改为<code>http://localhost:8080/alpha?input=example123</code>，然后就会看到我们的返回值</p>
<pre><code>validated:example
</code></pre><h3 id="邮箱校验"><a href="#邮箱校验" class="headerlink" title="邮箱校验"></a>邮箱校验</h3><p>我们可以利用<code>EmailValidator</code>来做邮箱的校验，方法同上面一样：</p>
<pre><code class="Swift"><span class="keyword">get</span>(<span class="string">"email"</span>) { request <span class="keyword">in</span>
            <span class="keyword">guard</span> <span class="keyword">let</span> input = request.data[<span class="string">"input"</span>]?.string <span class="keyword">else</span> {
                <span class="keyword">throw</span> <span class="type">Abort</span>.badRequest
            }
            <span class="keyword">let</span> validaInput = <span class="keyword">try</span> input.tested(by: <span class="type">EmailValidator</span>())
            <span class="keyword">return</span> <span class="string">"validated:<span class="subst">\(validaInput)</span>"</span>
    }
</code></pre>
<p>然后我们输入URL：<a href="http://localhost:8080/email?input=wallaceicdi@outlook.com，然后就会的到：" target="_blank" rel="external">http://localhost:8080/email?input=wallaceicdi@outlook.com，然后就会的到：</a></p>
<pre><code>Validated: wallaceicdi@outlook.com
</code></pre><h3 id="其余自带校验工具"><a href="#其余自带校验工具" class="headerlink" title="其余自带校验工具"></a>其余自带校验工具</h3><table>
<thead>
<tr>
<th>校验类</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unique</td>
<td>输入内容是否唯一</td>
<td>someCharacter.tested(by: Unique())</td>
</tr>
<tr>
<td>Compare</td>
<td>输入内容的数值比较</td>
<td>int.tested(by:Compare.greaterThan(1))</td>
</tr>
<tr>
<td>Contains</td>
<td>输入的内容是否包含某个</td>
<td>someArray.tested(by: Contains(“1”))</td>
</tr>
<tr>
<td>Count</td>
<td>输入的内容个数</td>
<td>someArray.tested(by: Count.max(2))</td>
</tr>
<tr>
<td>Equals</td>
<td>输入的内容是否相同</td>
<td>someConent.tested(by: Equals.init(“equal”))</td>
</tr>
<tr>
<td>In</td>
<td>输入内容是否被包含</td>
<td>input.tested(by: In.init([“1”,”2”,”3”]))</td>
</tr>
</tbody>
</table>
<h2 id="创建自己的校验工具"><a href="#创建自己的校验工具" class="headerlink" title="创建自己的校验工具"></a>创建自己的校验工具</h2><p>通过参考工具自带的<code>Equals.Swift</code>：</p>
<pre><code class="Swift"><span class="comment">/// Validates that matches a given input</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Equals</span>&lt;<span class="title">T</span>&gt;: <span class="title">Validator</span> <span class="title">where</span> <span class="title">T</span>: <span class="title">Validatable</span>, <span class="title">T</span>: <span class="title">Equatable</span> </span>{
    <span class="comment">/// The value expected to be in sequence</span>
    <span class="keyword">public</span> <span class="keyword">let</span> expectation: <span class="type">T</span>

    <span class="comment">/// Initialize a validator with the expected value</span>
    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> expectation: <span class="type">T</span>) {
        <span class="keyword">self</span>.expectation = expectation
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">validate</span><span class="params">(<span class="number">_</span> input: T)</span></span> <span class="keyword">throws</span> {
        <span class="keyword">guard</span> input == expectation <span class="keyword">else</span> {
            <span class="keyword">throw</span> error(<span class="string">"<span class="subst">\(input)</span> does not equal expectation <span class="subst">\(expectation)</span>"</span>)
        }
    }
}
</code></pre>
<p>从这里面我们可以看出，只要遵守<code>Validator</code>协议，并且实现其<code>validate</code>方法即可。</p>
<p>参考文件：<br><a href="https://github.com/vapor/validation/blob/master/Tests/ValidationTests/ValidationConvenienceTests.swift" target="_blank" rel="external">https://github.com/vapor/validation/blob/master/Tests/ValidationTests/ValidationConvenienceTests.swift</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/07/wwdc-advanced-swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/wwdc-advanced-swift/" itemprop="url">Swift进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-07T22:29:53+08:00">
                2017-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文是对<a href="https://developer.apple.com/videos/play/wwdc2014/404/" target="_blank" rel="external">WWDC2014–AdvancedSwift的总结</a></p>
<h2 id="改变参数名"><a href="#改变参数名" class="headerlink" title="改变参数名"></a>改变参数名</h2><p>比如我们要改变Thing对象的参数名：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>{
<span class="keyword">init</span>(location: <span class="type">Thing</span>?, name:<span class="type">String</span>,
     longDescription: <span class="type">String</span>){ ... }
}
</code></pre>
<p>如果我们不想用默认的<code>Thing.init(location:Beijing, name:&quot;wall&quot;,longDescription:&quot;An amazing city&quot;)</code>这种方式进行初始化，我们可以在参数前面添加<code>label</code>的形式：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>{
  <span class="keyword">init</span>(newLocation location: <span class="type">Thing</span>?, newName name: <span class="type">String</span>,
newLongDescription longDescription: <span class="type">String</span>) { ... }
}
</code></pre>
<p>这样我们就可以使用<code>Thing.init(newLocation:Beijing, newName:&quot;wall&quot;,newLongDescription:&quot;An amazing city&quot;)</code>这种参数来进行初始化。</p>
<h2 id="匿名参数"><a href="#匿名参数" class="headerlink" title="匿名参数"></a>匿名参数</h2><p>比如下面的例子，我们不需要字典中的value，那么我们就只需要遍历其<code>key</code>即可。</p>
<pre><code class="Swift"><span class="keyword">for</span> (key,<span class="number">_</span>) <span class="keyword">in</span> dictionary {
 <span class="built_in">print</span>(\(key))
}
</code></pre>
<p>在这个例子中，我们使用下划线<code>_</code>来进行你匿名操作，略过了我们不关心的value值，而只输出了<code>key</code>的值。</p>
<p>在上面<code>Thing</code>的例子中，如果我们要移除其参数名称，那么我们可以将<code>label</code>变为下划线，这样我们在调用的时候就不必写参数名了。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>{
  <span class="keyword">init</span>(<span class="number">_</span> location: <span class="type">Thing</span>?, <span class="number">_</span> name: <span class="type">String</span>,

   <span class="number">_</span> longDescription: <span class="type">String</span>) { ... }
}
</code></pre>
<p>这样我们就可以使用<code>Thing.init(Beijing, &quot;wall&quot;,&quot;An amazing city&quot;)</code>来初始化了。</p>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>如果我们要给上面的<code>Thing</code>对象添加一个方法<code>performPull</code>来执行其是否可以被拉动的方法。</p>
<pre><code class="Swift">        <span class="comment">// The parser will call this. func performPull(object: Thing) </span>
{ <span class="keyword">if</span> <span class="comment">/* object is   pullable */</span> {      <span class="comment">/* pull it */</span> }<span class="keyword">else</span>{      <span class="comment">/* complain */</span>   } }
</code></pre>
<p>这时我们可以添加一个Protocol：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Pullable</span> </span>{
  <span class="function"><span class="keyword">func</span> <span class="title">pull</span><span class="params">()</span></span>
} 
<span class="class"><span class="keyword">class</span> <span class="title">Boards</span>: <span class="title">Thing</span>, <span class="title">Pullable</span> </span>{
<span class="function"><span class="keyword">func</span> <span class="title">pull</span><span class="params">()</span></span> {
....
}
}
</code></pre>
<p>这样我们的<code>Boards</code>类就遵守了<code>Pullable</code>协议，当我们来检查某个对象是否遵守了某个协议时，我们可以这样做：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">performPull</span><span class="params">(object: Thing)</span></span> { <span class="keyword">if</span> <span class="keyword">let</span> pullableObject = object <span class="keyword">as</span> <span class="type">Pullable</span> { pullableObject.pull()    }<span class="keyword">else</span>{ 
     <span class="built_in">print</span>(<span class="string">"You are not sure how to print a <span class="subst">\(object.name)</span>."</span>)
   } 
}
</code></pre>
<h3 id="对象转String"><a href="#对象转String" class="headerlink" title="对象转String"></a>对象转String</h3><p>如果我们要打印某个对象，并且需要打印出其中的有效信息，那么我们要像OC中实现<code>description</code>方法一样，来遵守<code>CustomStringConvertible</code>协议并且实现其中的<code>description</code>方法。<br>还有很多类似的方法</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ExpressibleByStringLiteral</td>
<td>“abc”</td>
</tr>
<tr>
<td>ExpressibleByArrayLiteral</td>
<td>[ a, b, c ]</td>
</tr>
<tr>
<td>ExpressibleByDictionaryLiteral</td>
<td>[a: x, b: y]</td>
</tr>
<tr>
<td>Sequence</td>
<td>for x in sequence</td>
</tr>
<tr>
<td>CustomStringConvertible</td>
<td>“(convertible)”</td>
</tr>
</tbody>
</table>
<p>同样，如果我们要对某个对象使用下表，那么我们要<code>subscript</code>。怎样对某个类使用下表呢？</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p> 比如以下三个方法，其参数的形式是一样的，但是其参数类型不同，我们想把它变成一个函数，这时候我们最常想到的做法就是使用<code>Any</code>来表示任何类型的参数和任何类型的返回值。</p>
<pre><code class="Swift"><span class="comment">// 之前的三个函数</span>
<span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">(interestingValue: String)</span></span> {
  <span class="built_in">println</span>(<span class="string">"[peek] <span class="subst">\(interestingValue)</span>"</span>)
}
<span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">(interestingValue: Int)</span></span> {
  <span class="built_in">println</span>(<span class="string">"[peek] <span class="subst">\(interestingValue)</span>"</span>)
}
<span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">(interestingValue: Float)</span></span> {
  <span class="built_in">println</span>(<span class="string">"[peek] <span class="subst">\(interestingValue)</span>"</span>)
} 
<span class="comment">// 变为一个函数</span>
<span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">(interestingValue: Any)</span></span> {
  <span class="built_in">println</span>(<span class="string">"[peek] <span class="subst">\(interestingValue)</span>"</span>)
}
</code></pre>
<p>但是这有个问题，在我们要调用返回值的某个方法时候编译器会报错，因为我们的返回值<code>Any</code>并没有所调用的方法，也就是说我们需要一次强转，强转在代码层面是很难看的，也很麻烦，这时候我们就可以使用泛型来解决这个问题，如果我们使用了泛型，那么编译器会将输入的参数和输出的参数给我们推断出来，这样就不必强转了。并且当编译器可以推断出来是那种type的时候它会给我们做各种优化。</p>
<p>泛型在Swift中很常见，比如：<br>Array<t>以及Dictionary<k,v>：是范型的结构体<br>Optional<t>：范型枚举<br>我们也可以创建自己的泛型类</t></k,v></t></p>
<h3 id="Type间的关系"><a href="#Type间的关系" class="headerlink" title="Type间的关系"></a>Type间的关系</h3><p>比如我们要转换两个变量的值，我们可以调用下面的方法：</p>
<pre><code class="Swift"> // Exchange the values of x and y
func swap&lt;T&gt;(inout x: T, inout y: T) { 
let tmp = x     x = y     y = tmp 
} 
var studentCount = 42
var teacherCount = 7
swap(&amp;studentCount, &amp;teacherCount) // OK
var schoolName = “Homestead High School"
swap(&amp;studentCount, &amp;schoolName) // error: 'Int' is not identical to 'String'
</code></pre>
<p>有了这样的编译器提示，这样我们就可以保证了输入的两种类型是相同的，这样就会更加<strong>安全</strong>，代码也会少很多bug。</p>
<h3 id="对泛型进行Protocol限制"><a href="#对泛型进行Protocol限制" class="headerlink" title="对泛型进行Protocol限制"></a>对泛型进行Protocol限制</h3><p>我们可以给泛型加上限制，让它遵守某些协议，比如：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">indexOf</span>&lt;T&gt;<span class="params">(sought: T, inArray array: T[])</span></span> -&gt; <span class="type">Int</span>? {
  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..array.<span class="built_in">count</span> {
    <span class="keyword">if</span> array[i] == sought { <span class="comment">// error: could not find an overload for '==' that accepts the supplied arguments </span>
      <span class="keyword">return</span> i
} } 
<span class="keyword">return</span> <span class="literal">nil</span> }
</code></pre>
<p>这是编译不通过的，因为编译器不知道我们的<code>T</code>是否遵守了<code>Equatable</code>协议，如果我们将其变为<code>func indexOf&lt;T:Equatable&gt;(Sought: T, inArray array: T[]) -&gt; Int?</code>就可以编译通过了。</p>
<h3 id="实现Equatable协议"><a href="#实现Equatable协议" class="headerlink" title="实现Equatable协议"></a>实现Equatable协议</h3><p>Enum，Class以及Struct都可以实现协议，比如我们有如下的Struct，实现Equatable协议如下：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">Temperature</span> : <span class="title">Equatable</span> </span>{ 
  <span class="keyword">let</span> value: <span class="type">Int</span> = <span class="number">0</span>
}

<span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Temperature, rhs: Temperature)</span></span> -&gt; <span class="type">Bool</span> {
  <span class="keyword">return</span> lhs.value == rhs.value
}
</code></pre>
<p>当我们实现了<code>Equatable</code>，那么对于<code>!=</code>这种操作，Swift在底层就会自动帮我们实现。</p>
<h2 id="斐波那契数列的例子"><a href="#斐波那契数列的例子" class="headerlink" title="斐波那契数列的例子"></a>斐波那契数列的例子</h2><p>什么是菲波那切数列？数列的前两个数相加等于后面的一个数。 <code>0, 1, 1, 2, 3, 5, 8, 13, 21, ...</code><br>我们创建一个菲波那切数列的函数：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">Double</span> {
  <span class="keyword">return</span> n &lt; <span class="number">2</span> ? <span class="type">Double</span>(n) : fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)
}
</code></pre>
<p>这个函数的返回值仍然是一个函数，它是一个递归调用的函数，这个函数的效率极低。当你在Playground中实验的时候就会卡的不行。如果调用<code>fibonacci(44)</code>估计要十几秒的时间。原因就是它需要一个调用一个树状结构，我们用<code>fibonacci(5)</code>做个图示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-1d9abd75b75e42ea.png" alt="fibonacci(n:5)"></p>
<p>在图中我们发现fib(1)，fib(2)等函数被持续的调用，我们如果可以把这个已经计算过的数值存下来，那么以后不是就就可以直接计算了呢？这样不就可以极大的提高计算的速度。这样我们就只计算下面带星号的函数即可：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-12e6e8ab9ae865d9.png" alt="valuable func"></p>
<p>这时最先想到的就是用一个全局的字典手动来存储这个数值，实现方法如下：</p>
<pre><code class="Swift"><span class="keyword">var</span> fibonacciMemo = <span class="type">Dictionary</span>&lt;<span class="type">Int</span>, <span class="type">Double</span>&gt;() <span class="comment">// implementation detail </span> <span class="comment">// Return the nth fibonacci number: 0, 1, 1, 2, 3, 5, 8, 13, 21, ...</span> <span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">Double</span> { 
  <span class="keyword">if</span> <span class="keyword">let</span> result = fibonacciMemo[n] {
    <span class="keyword">return</span> result
  }
  <span class="keyword">let</span> result = n &lt; <span class="number">2</span> ? <span class="type">Double</span>(n) : fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)
  fibonacciMemo[n] = result
  <span class="keyword">return</span> result
} 

<span class="comment">// 1.61803399...</span>
<span class="keyword">let</span> phi = fibonacci(<span class="number">45</span>) / fibonacci(<span class="number">44</span>) <span class="comment">//0.1 seconds = 100x speedup</span>
</code></pre>
<p>这样一来，我们之前计算<code>fibonacci(44)</code>中十几秒的计算时间一下子缩短到了0.1秒，缩减了100倍。<br>如果这样做的话，我们以后每次用到这个方法就都需要写一个字典，每次把这个计算过程过一遍，并且更重要的是它不具备通用型，如果我要放进去字符串，那就不起作用了。下面我们写一个通用的函数来解决这种需要保留中间数值，并且不需要额外的全局变量<code>fibonacciMemo</code>就可以解决问题的方法。先看一个不递归时候的函数：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">memoize</span>&lt;T: Hashable, U&gt;<span class="params">(work: @escaping <span class="params">(T)</span></span></span>-&gt;<span class="type">U</span>) -&gt; (<span class="type">T</span>)-&gt;<span class="type">U</span> {

    <span class="keyword">var</span> memo = <span class="type">Dictionary</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt;()
    <span class="keyword">return</span> { x <span class="keyword">in</span>
        <span class="keyword">if</span> <span class="keyword">let</span> q = memo[x] { <span class="keyword">return</span> q }
        <span class="keyword">let</span> r = work(x)
        memo[x] = r
        <span class="keyword">return</span> r
    }
}
</code></pre>
<p>然后再来一个可以递归的方法：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">memoize</span>&lt;T: Hashable, U&gt;<span class="params">(work: @escaping <span class="params">(<span class="params">(T)</span></span></span></span>-&gt;<span class="type">U</span>, <span class="type">T</span>) -&gt; <span class="type">U</span>) -&gt; (<span class="type">T</span>)-&gt;<span class="type">U</span> {
    <span class="keyword">var</span> memo = <span class="type">Dictionary</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt;()
    <span class="function"><span class="keyword">func</span> <span class="title">wrap</span><span class="params">(x: T)</span></span>-&gt;<span class="type">U</span> {
        <span class="keyword">if</span> <span class="keyword">let</span> q = memo[x] { <span class="keyword">return</span> q }
        <span class="keyword">let</span> r = work(wrap, x)
        memo[x] = r
        <span class="keyword">return</span> r
    }
    <span class="keyword">return</span> wrap
}
</code></pre>
<p>这两个函数包含了swift中的很多高级语法：</p>
<ul>
<li>强大的编译器推断匹配,比如你调用：</li>
</ul>
<pre><code class="Swift">     <span class="keyword">let</span> fibonacci = memoize {
    (n: <span class="type">Int</span>) <span class="keyword">in</span>
    <span class="type">String</span>(n)
}
</code></pre>
<p>那么上面泛型中的<code>T</code>就会被推断成<code>Int</code>，而<code>U</code>怎会被推断成<code>String</code>。</p>
<ul>
<li>尾随闭包，比如调用<code>let fibonacci = memoize {...}</code>的时候。</li>
<li>更通用，更安全，性能更高的泛型函数。</li>
</ul>
<p>关于这个函数，有人专门写了一篇博客来说明:<a href="https://medium.com/@mvxlr/swift-memoize-walk-through-c5224a558194" target="_blank" rel="external">https://medium.com/@mvxlr/swift-memoize-walk-through-c5224a558194</a></p>
<h2 id="泛型结构体的一个例子"><a href="#泛型结构体的一个例子" class="headerlink" title="泛型结构体的一个例子"></a>泛型结构体的一个例子</h2><pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">StringStack</span> </span>{
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(x: String)</span></span> {
items += x } 
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">String</span> {
    <span class="keyword">return</span> items.removeLast()
} 
  <span class="keyword">var</span> items: <span class="type">String</span>[]
}
</code></pre>
<p>这里我们创建了一个字符串的栈，如果我们要变为泛型，则需要：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>{
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(x: T)</span></span> {
items += x } 
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">T</span> {
    <span class="keyword">return</span> items.removeLast()
} 
  <span class="keyword">var</span> items: <span class="type">T</span>[]
}
</code></pre>
<p>这样我们就可以往里面放任何数据类型了：</p>
<pre><code class="Swift"><span class="keyword">var</span> intStack = <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()
intStack.push(<span class="number">42</span>)
</code></pre>
<p>但是当我们需要对这个Stack做<code>for in</code>操作时候，却得到了下面的错误提示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-9d39a23bddecaefd.png" alt="for_in_error"><br>这时候我们需要理解下，什么是<code>Sequence</code>，当Swift给我们做<code>for in</code>操作的时候在底层给我们做了什么？</p>
<pre><code class="Swift"><span class="comment">// 我们代码</span>
 <span class="keyword">for</span> x <span class="keyword">in</span> someSequence {
  ...
 }
<span class="comment">// Swift翻译后的代码</span>
<span class="keyword">var</span> __g = someSequence.generate()
<span class="keyword">while</span> <span class="keyword">let</span> x = __g.next(){
...
}
</code></pre>
<p>从上面可以看到，首先我们的<code>someSequence</code>需要关联一个<code>generate</code>，并且这个<code>generate</code>需要实现一个<code>next</code>方法，这样我们就可以对这个结构体做<code>for in</code>操作了。<br>我们先看这个<code>generate()</code>，它是一个结构体，其遵守<code>Generator</code>（<code>protocol</code>)。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Generator</span> </span>{
 <span class="keyword">typealias</span> <span class="type">Element</span>
 <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> ?
}
</code></pre>
<p>然后我们创建一个遵守<code>Generator</code>的结构体：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">StackGenerator</span>&lt;<span class="title">T</span>&gt; : <span class="title">Generator</span> </span>{
  <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">T</span>
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? {
    <span class="keyword">if</span> items.isEmpty { <span class="keyword">return</span> <span class="literal">nil</span> }
    <span class="keyword">let</span> ret = items[<span class="number">0</span>]
    items = items[<span class="number">1</span>..items.<span class="built_in">count</span>]
    <span class="keyword">return</span> ret
} 
  <span class="keyword">var</span> items: <span class="type">Slice</span>&lt;<span class="type">T</span>&gt;
}
</code></pre>
<p>那么什么是<code>Sequence</code>呢？它也是一个<code>protocol</code></p>
<pre><code class="Swift"> <span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>{
  <span class="keyword">typealias</span> <span class="type">GeneratorType</span> : <span class="type">Generator</span>
  <span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">GeneratorType</span>
}
</code></pre>
<p>它关联了一个<code>Generator</code>，然后我们让新建的<code>Stack</code>遵守这个<code>Sequence</code>协议：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> : <span class="title">Sequence</span> </span>{
  <span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">StackGenerator</span>&lt;<span class="type">T</span>&gt; {
    <span class="keyword">return</span> <span class="type">StackGenerator</span>( items[<span class="number">0</span>..itemCount] )
  }
}
</code></pre>
<p>这样就可以对<code>Stack</code>做<code>for in</code>操作了。</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">peekStack</span><span class="params">(s: Stack&lt;T&gt;)</span></span> {
  <span class="keyword">for</span> x <span class="keyword">in</span> s { <span class="built_in">println</span>(x) }
}
</code></pre>
<p>关于<code>Sequence</code>和<code>Generator</code>的详细说明，请看我的另外一篇博客<a href="https://mikefighting.github.io/2017/07/28/note-advance-swift-collection-protocols/">Swift中Collection的Protocol</a></p>
<h3 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h3><p>Swift是静态编译，很小的runtime。写好的代码传到设备上之后不需要再重新编译，只需要等着运行即可。Swift中的编译器，相比于C，C++，Objective-C的Clang，做了一步优化：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-3cb2500863892632.png" alt="SwiftComplier"><br>除此之外，Swift会在编译时候做以下几点</p>
<ul>
<li>全局分析App</li>
<li>使用Struct不会对Runtime的性能造成影响</li>
<li>Int，Float等很多标准库都是Struct的</li>
</ul>
<p>Swift还有去虚拟化的特点，它可以让再运行期确定的事情放到了编译期，这样就会更快了，详细内容可以参考我的另外一篇博客<a href="https://mikefighting.github.io/2017/08/01/Why-Swift-IS-swift/">为什么Swift比OC快</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/05/avfoundation-play/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/05/avfoundation-play/" itemprop="url">AVFoundation--视频播放</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-05T12:23:18+08:00">
                2017-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用<code>AVPlayer</code>对象可以用来控制asset的播放。在播放期间，你可以使用AVPlayerItem实例来asset的presentation state。并且一个<code>AVPlayerItemTrack</code>对象可以管理某个独立track的展示状态。展示一个视频，你可以使用<code>AVPlayerLayer</code>对象。</p>
<h2 id="播放Assets"><a href="#播放Assets" class="headerlink" title="播放Assets"></a>播放Assets</h2><p>一个player是一个控制器对象，你可以使用它来管理一个asset的播放，比如，开始和停止播放以及寻找特殊的时间点。使用<code>AVPlayer</code>实例来播放一个asset。你可以使用<code>AVQueuePlayer</code>对象来按序播放一系列的item（AVQueuePlayer是AVPlayer的一个子类）。</p>
<p>一个player给你提供了播放状态的信息，如果有需要，你可以让你的UI和player的状态相同步。通常情况下，你可以直接指出player的输出到一个特定的Core Animation的layer上(<code>AVPlayerLayer</code>或者<code>AVSynchronizedLayer</code>)对象。</p>
<blockquote>
<p>多个player layer:你可以对一个AVPlayer实例创建很多的AVPlayerLayer对象，但是只有最近创建layer才可以在屏幕上展示在视频内容。</p>
</blockquote>
<p>你不用给AVPlayer对象直接提供assets，尽管你最终想要播放的是asset。相反，你需要提供一个AVPlayerItem的实例。以个item用来管理其相关联的asset的presentation state。一个item包含一个AVPlayerItemTrack的实例，这个实例和asset中的track相对应。结构如下：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-f0dabcb6010b69ad.png" alt="PlaeyItem关系图"><br>下面的图说明了你可以用不同的player同时播放一个指定的asset，但是每个player都可以用不同的方式进行渲染。例如，使用item track，你可以在播放期间让一个特定的track失效（比如，你可能不想播放一个音频部分）。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-2a0e8b3648efb92a.png" alt="AVPlayerItem"></p>
<p>你可以使用一个已经存在的asset来初始化一个player，或者你可以用一个URL来初始化一个player，以便于你可以再一个特定的点来播放这个资源(<code>AVPlayerItem</code>将会对这个资源的创建和配置这个asset)。和<code>AVAsset</code>一样，仅仅初始化一个player item并不意味着它可以直接用来播放。你可以使用KVO来观察这个item的<code>status</code>属性来决定播放的时机及播放的逻辑。</p>
<h2 id="处理不同类型的Asset"><a href="#处理不同类型的Asset" class="headerlink" title="处理不同类型的Asset"></a>处理不同类型的Asset</h2><p>你可以根据将要播放的不同的Asset类型来决定怎样配置asset。一般说来，有两种不同的类型：文件类型的assets，有几种可以选择，比如：本地文件，相机胶卷，或者媒体库；另外就是基于流的assets（HTTP直播流形式）。</p>
<p><strong>基于文件的视频加载</strong>，为了播放基于文件的视频，有以下步骤：</p>
<ul>
<li>创建一个<code>AVURLAsset</code>对象。</li>
<li>使用asset创建一个<code>AVPlayerItem</code>对象</li>
<li>将一个<code>AVPlayer</code>和这个item对象相关联</li>
<li>等待，一直到这个item的<code>status</code>属性指明可以播放了（利用KVO）</li>
</ul>
<p><strong>基于HTTP直播视频流来播放</strong>，利用该URL创建一个AVPlayerItem。（你不可以直接创建一个<code>AVAsset</code>对象来代表<code>HTTP Live Stream</code>的媒体）</p>
<pre><code class="objc">NSURL *url = [NSURL URLWithString:@"&lt;#Live stream URL#&gt;];
// You may find a test stream at
&lt;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8&gt;.
self.playerItem = [AVPlayerItem playerItemWithURL:url];
[playerItem addObserver:self forKeyPath:@"status" options:0
context:&amp;ItemStatusContext];
self.player = [AVPlayer playerWithPlayerItem:playerItem];
</code></pre>
<p>当你将这个player item和以个player相结合的时候，它就变为待播放状态了。当它准备好播放的时候，这个player item创建<code>AVAsset</code>以及<code>AVAssetTrack</code>实例，你可以利用它来检测直播流的内容。想要得到这个item的播放时长，你可以观察其<code>duration</code>属性。当这个item状态变为可以播放时，这个属性就会更新到这个视频流的准确数值。<br><em>注：当这个状态变为AVPlayerItemStatusReadyToPlay的时候，这个播放时长可以使用下面的代码来获取时长</em></p>
<pre><code class="objc">[[[[[playerItem tracks] objectAtIndex:<span class="number">0</span>] assetTrack] asset] duration];
</code></pre>
<p>如果你仅仅想要播放一个直播流，那么你可以走个捷径，直接使用这个<code>URL</code>创建一个player：</p>
<pre><code class="objc"><span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithURL:&lt;<span class="meta">#Live stream URL#&gt;];</span>
[player addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"status"</span> options:<span class="number">0</span>
context:&amp;PlayerStatusContext];
</code></pre>
<p>和asset和item一样，初始化完player之后并不意味着你可以立即使用播放了。你需要观察其<code>status</code>属性，该属性变为<code>AVPlayerStatusReadyToPlay</code>的时候就表明它可以播放了。你也可以观察<code>currentItem</code>来获取已经创建的item。</p>
<p><strong>如果你不知道你要播放的URL的类型</strong>，那么你需要这样做：</p>
<ol>
<li>尝试使用这个URL来初始化一个<code>AVURLAsset</code>对象，然后加载其<code>tracks</code>key。如果tracks加载成功，那么你可以为这个asset创建一个player item。</li>
<li>如果1失败了，那么利用这个URL直接创建一个<code>AVPlayerItem</code>对象。观察这个player的<code>status</code>属性，来决定是否可以播放了。</li>
</ol>
<p>只要其中一个成功，你就可以得到一个player item，然后将其和一个player对象相关联。</p>
<h2 id="播放一个Item"><a href="#播放一个Item" class="headerlink" title="播放一个Item"></a>播放一个Item</h2><p>为了开始播放，你需要调用player的<code>play</code>方法即可：</p>
<pre><code class="objc">- (<span class="keyword">IBAction</span>)play:sender {
      [player play];

   }
</code></pre>
<p>除了紧紧播放以外，你可以管理播放过程中各种方面，比如，playhead的位置和速度。你也可以观察player的stata。比如，你如果想将UI和asset的presention state相同步，你就要这样做。</p>
<h3 id="改变播放速度"><a href="#改变播放速度" class="headerlink" title="改变播放速度"></a>改变播放速度</h3><p>你可以通过设定player的<code>rate</code>属性来改变其播放的速度。</p>
<pre><code class="objc">aPlayer.rate = <span class="number">0.5</span>;
aPlayer.rate = <span class="number">2.0</span>;
</code></pre>
<p>1.0的数值表示利用当前<code>item</code>的正常速度播放，0.0速度和暂停是一样的效果。<br>支持回播的player，可以使用一个负值来设置这这个播放速度。你可以使用<code>canPlayReverse</code>(是否支持数值-1.0的播放速度)属性来检测其是否可以支持回播，使用<code>canPlaySlowReverse</code>(支持0.0到1.0的播放速度)，以及<code>canPlayFastReverse</code>(支持小于-1.0的播放速度)</p>
<h3 id="寻找-重置Playhead"><a href="#寻找-重置Playhead" class="headerlink" title="寻找-重置Playhead"></a>寻找-重置Playhead</h3><p>为了将playhead移动到一个特定的时间点，你通常需要使用<code>seekToTime</code>：</p>
<pre><code class="objc"><span class="built_in">CMTime</span> fiveSecondsIn = <span class="built_in">CMTimeMake</span>(<span class="number">5</span>,<span class="number">1</span>);
[player seekToTime: fiveSecondsIn];
</code></pre>
<p>然而，这个<code>seekToTime:</code>方法不是很精确，尽管其性能较高。如果你要精确得移动这个<code>playhead</code>，你可以使用下面的<code>seekToTime:toleranceBefore:toleranceAfter:</code>方法。</p>
<pre><code class="objc"><span class="built_in">CMTime</span> fiveSecondsIn = <span class="built_in">CMTimeMake</span>(<span class="number">5</span>,<span class="number">1</span>);
[player seekToTime: fiveSecondsIn toleranceBefore: kCMTimeZero toleranceAfter: kCMTimeZero];
</code></pre>
<p>上面的例子中将<code>tolerance</code>设置为零需要框架解码大量的数据。因此，仅仅在必要的时候再使用零，比如：你需要写一个精确的媒体编辑应用，它需要精确的控制。</p>
<p>在视频播放之后，player的head被设定在了item的尾部，因此接下来调用<code>play</code>操作是不起作用的。为了将playhead放到item的起始位置，你需要注册一个item的<code>AVPlayerItemDidPlayToEndTimeNotification</code>通知，在该通知的回调方法中，你调用<code>seekToTime:</code>方法，并且传入<code>kCMTimeZero</code>参数。</p>
<pre><code class="objc">   <span class="comment">// Register with the notification center after creating the player item.</span>
   [[<span class="built_in">NSNotificationCenter</span> defaultCenter]
       addObserver:<span class="keyword">self</span>
       selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)
       name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span>
       object:&lt;<span class="meta">#The player item#&gt;];</span>

   - (<span class="keyword">void</span>)playerItemDidReachEnd:(<span class="built_in">NSNotification</span> *)notification {
   [player seekToTime:kCMTimeZero];
}
</code></pre>
<h2 id="很多Item的播放"><a href="#很多Item的播放" class="headerlink" title="很多Item的播放"></a>很多Item的播放</h2><p>你可以使用<code>AVQueuePlayer</code>对象来播放一系列的<code>item</code>。这个<code>AVQueuePlayer</code>类是<code>AVPlayer</code>类的子类。通过一个<code>item</code>的数组，你可以初始化一个<code>queue player</code>。</p>
<pre><code class="objc"><span class="built_in">NSArray</span> *items = &lt;<span class="meta">#An array of player items#&gt;;</span>
<span class="built_in">AVQueuePlayer</span> *queuePlayer = [[<span class="built_in">AVQueuePlayer</span> alloc] initWithItems:items];
</code></pre>
<p>然后调用其<code>play</code>方法即可。这个player会按序播放这些<code>item</code>。如果不想播放某个<code>item</code>可以调用它的<code>advanceToNextItem</code>方法。<br>可以使用<code>insertTtem:afterItem:</code>，<code>removeItem:</code>，以及<code>removeAllItems</code>方法，如果要插入一个item，你需要首先调用<code>canInsertItem：afterItem:</code>方法来确定它是否可以插入到这个<code>queue</code>中。你可以传给第二个参数<code>nil</code>，来检测是否新的<code>item</code>可以被加到<code>queue</code>的后面。</p>
<pre><code class="objc"><span class="built_in">AVPlayerItem</span> *anItem = &lt;<span class="meta">#Get a player item#&gt;;</span>
<span class="keyword">if</span> ([queuePlayer canInsertItem:anItem afterItem:<span class="literal">nil</span>]) {
    [queuePlayer insertItem:anItem afterItem:<span class="literal">nil</span>];
}
</code></pre>
<h2 id="监控视频播放"><a href="#监控视频播放" class="headerlink" title="监控视频播放"></a>监控视频播放</h2><p>你可以监控正在player的显示状态以及其正在播放的item的各个方面。这对你所不能控制的状态改变来说是极其有益的，比如：</p>
<ul>
<li>比如如果用户使用多任务操作来切换应用，那么一个player的<code>rate</code>属性就会掉到0.0;</li>
<li>如果你正在播放一个远程的媒体，一个player item的<code>loadedTimeRangs</code>和<code>seekableTimeRanges</code>属性就会在更多的数据变得可用的时候改变。这些属性告诉你这些player item的那些部分是可用的。</li>
<li>在HTTP直播流被创建的时候，player item的<code>tracks</code>属性就会改变。如果这个视频流对内容提供了不同的编码格式，那么这就会发生；在player切换不同的编码的时候，这个<code>tracks</code>就改变了。</li>
<li>如果一个视频播放失败，那么这个player或者player item的<code>status</code>属性可能会改变。</li>
</ul>
<p>你可以使用KVO来监控这些属性值的改变。</p>
<blockquote>
<p>你应该将注册KVO以及取消注册KVO都放到主线程中。这样，如果另外一个线程发生了改变，这将会避免收到部分通知的可能。尽管这些属性的变化会在其它线程上，但是AV Foundation触发<code>observeValueForKeyPath:ofObject:change:context:</code>是在主线程上。</p>
</blockquote>
<h3 id="响应某个状态的改变"><a href="#响应某个状态的改变" class="headerlink" title="响应某个状态的改变"></a>响应某个状态的改变</h3><p>当一个player或者一个player item的状态改变的时候，它发出一个KVO的变化通知。如果一个对象由于某种原因不能够被播放（比如，媒体服务被重置），其状态将会变为<code>AVPlayerStatusFailed</code>或者<code>AVPlayerItemStatusFailed</code>。在这种情况下，这个对象的<code>error</code>属性将会变为一个error 对象，这个对象中包含了其不能够播放的原因描述。</p>
<p>AVFoundation不会指明这个通知发送的线程。如果你想改变UI，你必须要确保任何相关的代码会在主线程中执行。比如，你可以使用<code>dispatch_async</code>来在主线程中执行代码。</p>
<pre><code class="objc">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object
                          change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context {
      <span class="keyword">if</span> (context == &lt;<span class="meta">#Player status context#&gt;) {</span>

          <span class="built_in">AVPlayer</span> *thePlayer = (<span class="built_in">AVPlayer</span> *)object;
          <span class="keyword">if</span> ([thePlayer status] == <span class="built_in">AVPlayerStatusFailed</span>) {
              <span class="built_in">NSError</span> *error = [&lt;<span class="meta">#The AVPlayer object#&gt; error];</span>
              <span class="comment">// Respond to error: for example, display an alert sheet.</span>
              <span class="keyword">return</span>;
} 
          <span class="comment">// Deal with other status change if appropriate.</span>
      }
      <span class="comment">// Deal with other change notifications if appropriate.</span>
      [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object
             change:change context:context];
      <span class="keyword">return</span>;
}
</code></pre>
<h3 id="追踪可视化播放的准备状态"><a href="#追踪可视化播放的准备状态" class="headerlink" title="追踪可视化播放的准备状态"></a>追踪可视化播放的准备状态</h3><p>你可以观察<code>AVPlayerLayer</code>对象的<code>readyForDisplay</code>属性来获取当<code>layer</code>的用户可视内容改变时发出的通知。尤其重要的是，只有在用户可以看到一些东西的时候，你才可以将一个player layer插入到layer tree中，然后执行转化操作。</p>
<h3 id="追踪时间"><a href="#追踪时间" class="headerlink" title="追踪时间"></a>追踪时间</h3><p>为了追踪一个<code>AVPlayer</code>对象中<code>playhead</code>的位置，你可以使用addPeriodicTimeObserverForInterval: queue: usingBlock:或者addBoundaryTimeObserverForTimes: queue: usingBlock:比如，你可以用过去的时间以及剩余的时间来更新用于界面，或者执行其它的UI同步操作。</p>
<ul>
<li>如果时间超过了你所指定的周期点，以及视频播放开始或者停止，这个时候<code>addPeriodicTimeObserverForInterval:queue:usingBlock:</code>将会被触发。</li>
<li>你也可以指定在某些时间触发<code>addBoundaryTimeObserverForTimes:queue:usingBlock:</code>，这里你需要传递一个包含被<code>NSValue</code>封装的<code>CMTime</code>数组。</li>
</ul>
<p>如果你要想这个基于时间的<code>observation block</code>被触发，那么你必须要对这两个方法返回的对象做强引用。同时你必须在每次触发这些方法时调<code>removeTimeObserver:</code>。使用这些方法，AV Foundation不会保证在每次的时间间隔或者时间范围达到的时候都触发这些操作。如果之前的block没有执行完毕，那么AV Foundation不会执行接下来的block。因此，你必须保证在block中执行的任务不能消耗太多的CPU资源。</p>
<pre><code class="objc">/ Assume a property: <span class="keyword">@property</span> (<span class="keyword">strong</span>) <span class="keyword">id</span> playerObserver;

Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([&lt;<span class="meta">#An asset#&gt; duration]);</span>
<span class="built_in">CMTime</span> firstThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">3.0</span>, <span class="number">1</span>);
<span class="built_in">CMTime</span> secondThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds*<span class="number">2.0</span>/<span class="number">3.0</span>, <span class="number">1</span>);
<span class="built_in">NSArray</span> *times = @[[<span class="built_in">NSValue</span> valueWithCMTime:firstThird], [<span class="built_in">NSValue</span>
valueWithCMTime:secondThird]];

<span class="keyword">self</span>.playerObserver = [&lt;<span class="meta">#A player#&gt; addBoundaryTimeObserverForTimes:times queue:NULL usingBlock:^{ </span>
<span class="built_in">NSString</span> *timeDescription = (<span class="built_in">NSString</span> *) <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, [<span class="keyword">self</span>.player currentTime])); 
    <span class="built_in">NSLog</span>(<span class="string">@"Passed a boundary at %@"</span>, timeDescription);
}];
</code></pre>
<h3 id="某个Item结束了"><a href="#某个Item结束了" class="headerlink" title="某个Item结束了"></a>某个Item结束了</h3><p>当一个Item播放结束的时候，你可以收到一个<code>AVPlayerItemDidPlayToEndTimeNotification</code>通知。你可以注册这个通知。</p>
<pre><code class="objc">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:&lt;<span class="meta">#The observer, typically self#&gt; selector:@selector(<span class="meta-string">&lt;#The selector name#&gt;</span>) </span>
name: <span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span>  object:&lt;<span class="meta">#A player item#&gt;];</span>
</code></pre>
<h2 id="使用AVPlayer播放一个视频文件"><a href="#使用AVPlayer播放一个视频文件" class="headerlink" title="使用AVPlayer播放一个视频文件"></a>使用AVPlayer播放一个视频文件</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/04/intermedia-swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/04/intermedia-swift/" itemprop="url">Swift中级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-04T08:28:26+08:00">
                2017-08-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文源于对：<a href="https://developer.apple.com/videos/play/wwdc2014/403/" target="_blank" rel="external">WWDC2014–Intermediate Swift</a>的总结。</p>
<h2 id="为什么需要Optional"><a href="#为什么需要Optional" class="headerlink" title="为什么需要Optional?"></a>为什么需要Optional?</h2><p>我们队某个对象的操作可能会返回错误的结果：比如我们将某个字符串转为Int型，执行下面的指令：</p>
<pre><code class="Swift"><span class="keyword">let</span> age = response.toInt()
</code></pre>
<p>这response可能是用户输入的,可能会输入不确定的数值<code>Do you konw?</code>那么肯定会得到错误的结果，在OC中遇到这种情况我们怎么处理呢？我们有如下的值可以表示错误：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-65ce6dec3ca6cade.png" alt="Wrong!"><br>但是你必须从不同的接口中去选择相应的错误类型，并且要记住这些错误类型。为了解决这个问题，Swift中引入了Optional的概念，将这种可能是nil的值进行打包。它可以表示上述所有错误的类型，同时，<strong>如果我们使用Optional，就一定要对它进行拆包，使用<code>!</code>号，如果不拆包会造成编译器错误</strong>，如下所示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-03cea3691052ac9b.png" alt="Need Unwrap"><br><strong>也可以使用Optional Binding将判断是否有值和拆包结合在一起使用：<code>if let</code></strong>。</p>
<pre><code class="Swift"><span class="keyword">var</span> neighbors = [<span class="string">"Alex"</span>, <span class="string">"Anna"</span>, <span class="string">"Madison"</span>, <span class="string">"Dave"</span>] <span class="keyword">let</span> index = findIndexOfString(<span class="string">"Anna"</span>, neighbors)  <span class="keyword">if</span> <span class="keyword">let</span> indexValue = index { 
    <span class="built_in">println</span>(<span class="string">"Hello, <span class="subst">\(neighbors[indexValue])</span>"</span>)
} <span class="keyword">else</span> {
    <span class="built_in">println</span>(<span class="string">"Must've moved away"</span>)
}
</code></pre>
<p>当然我们还可以进一步使用Optional Binding–Optional Chain：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-040ccbafce764e18.png" alt="Optional Chain Binding"></p>
<p>在Optional Chain中，只要其中一个Optional的值是nil，那么整个Optional Chain都将是nil，并且不会再执行接下来的取值，如果不是nil则继续执行。这样让我们的代码更加简洁更加安全。<br>Swift中的Optional其实是个枚举：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>{
   <span class="keyword">case</span> <span class="type">None</span>
   <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">T</span>)
}
</code></pre>
<h2 id="Swift中的内存管理"><a href="#Swift中的内存管理" class="headerlink" title="Swift中的内存管理"></a>Swift中的内存管理</h2><p>在Swift中也用的是ARC，也容易出现循环引用，这时需要使用<code>weak</code>属性。需要注意的是</p>
<blockquote>
<p><code>weak</code>引用的类型是Optional的。<br>Binding该Optional Type将会产生一个强引用。<br>如果仅仅是判断即用<code>if</code>判断，则不会产生强引用。</p>
</blockquote>
<p>例如：</p>
<pre><code class="Swift"><span class="keyword">if</span> <span class="keyword">let</span> tenant = apt.tenant {
  tenant.buzzIn()
 }
</code></pre>
<p>但是有些时候我们同时需要weak，又同时需要非Optional的。那么该怎么办？我们需要<code>unowned</code>属性，他也是weak的。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{
    <span class="keyword">var</span> card: <span class="type">CreditCard</span>?
} <span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> </span>{ <span class="keyword">unowned</span> <span class="keyword">let</span> holder: <span class="type">Person</span> 
    <span class="keyword">init</span>(holder: <span class="type">Person</span>) {
        <span class="keyword">self</span>.holder = holder
  } 
}
</code></pre>
<p>这说明<code>holder</code>没持指向Person，但是holder离开了Person它就不存在了。<code>unowned</code>很像<code>unsafe unretain</code></p>
<h2 id="Swift中的初始化"><a href="#Swift中的初始化" class="headerlink" title="Swift中的初始化"></a>Swift中的初始化</h2><p>在Swift的初始化中需要谨记：</p>
<blockquote>
<p>所有的变量在使用前必须初始化<br>设定完自己所有的变量之后再调用Super的初始化方法</p>
</blockquote>
<p>在下面这个初始化的例子中：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-71bbd45dcf36f0a3.png" alt="init wrong"><br>这样在init方法中没有初始化完自己的<code>hasTurbo</code>变量就直接调用super方法是会在编译的时候报错的，Swift为什么要这么做呢？因为可能会出现如下的情况：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-bd1edb7b7a89a7bc.png" alt="why init wrong"><br>也就是说在父类的<code>init</code>方法中可能会调用<code>filGasTank()</code>这个方法，而这个方法被子类所覆盖了，所以这时候就可能发生意向不到的bug。<br>初始化方法的覆盖也可能会产生问题：<br>比如我们有这样一个Car的类：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>{
    <span class="keyword">var</span> paintColor: <span class="type">Color</span>
    <span class="function"><span class="keyword">func</span> <span class="title">fillGasTank</span><span class="params">()</span></span> {...}
    <span class="keyword">init</span>(color: <span class="type">Color</span>) {
        paintColor = color
        fillGasTank()
    }
} 
<span class="class"><span class="keyword">class</span> <span class="title">RaceCar</span>: <span class="title">Car</span> </span>{
    <span class="keyword">var</span> hasTurbo: <span class="type">Bool</span>
    <span class="keyword">init</span>(color: <span class="type">Color</span>, turbo: <span class="type">Bool</span>) {
        hasTurbo = turbo
        <span class="keyword">super</span>.<span class="keyword">init</span>(color: color)
} 
    <span class="keyword">convenience</span> <span class="keyword">init</span>(color: <span class="type">Color</span>) {
        <span class="keyword">self</span>.<span class="keyword">init</span>(color: color, turbo: <span class="literal">true</span>)
} 
    <span class="keyword">convenience</span> <span class="keyword">init</span>() {
        <span class="keyword">self</span>.<span class="keyword">init</span>(color: <span class="type">Color</span>(gray: <span class="number">0.4</span>))
} } 

<span class="class"><span class="keyword">class</span> <span class="title">FormulaOne</span>: <span class="title">RaceCar</span> </span>{
    <span class="keyword">let</span> minimumWeight = <span class="number">642</span>

    <span class="comment">// inherited from RaceCar</span>
    <span class="comment">/*init(color: Color, turbo: Bool) {
        hasTurbo = turbo
        super.init(color: color)
    }
    convenience init(color: Color) {
        self.init(color: color, turbo: true)
    }
    convenience init() {
        self.init(color: Color(gray: 0.4))
    }
    */</span>
}
</code></pre>
<p>上面注释的内容是从父类中继承过来的，如果我们在子类中调用<code>convenience init(color: Color)</code>这个方法的时候，想让<code>turbo</code>这个参数的默认值为<code>false</code>，这时候我们就需要覆盖掉父类的<code>convenience init</code>方法了。这时我们需要实现自己的<code>designed initializer</code>  </p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">FormulaOne</span>: <span class="title">RaceCar</span> </span>{
    <span class="keyword">let</span> minimumWeight = <span class="number">642</span>
    <span class="keyword">init</span>(color: <span class="type">Color</span>) {
        <span class="keyword">super</span>.<span class="keyword">init</span>(color: color, turbo: <span class="literal">false</span>)
} 
    <span class="comment">// not inherited from RaceCar</span>
    <span class="comment">/*init(color: Color, turbo: Bool)
    convenience init()
    */</span>
}
</code></pre>
<p>这样以后被注释的内容就不会再被继承了。就会直接掉用子类的<code>designed init</code>方法了。</p>
<h2 id="懒加载属性"><a href="#懒加载属性" class="headerlink" title="懒加载属性"></a>懒加载属性</h2><p>如果我们的某个属性需要很大的性能消耗，那么我们希望在使用的时候再创建该类，那么我们不必像在OC中那样重写其<code>get</code>方法，我们只需要在变量声明的前面加上<code>lazy</code>关键字即可。</p>
<pre><code class="Swift"><span class="built_in">lazy</span> <span class="keyword">var</span> color:<span class="type">UIColor</span> = <span class="type">UIColor</span>.red
</code></pre>
<p>这样就可以声明了一个懒加载的属性了。</p>
<h2 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Swift中Array的sort方法实现了Closure，我们来看下：</p>
<pre><code class="Swift"><span class="keyword">var</span> clients = [<span class="string">"Pestov"</span>, <span class="string">"Buenaventura"</span>, <span class="string">"Sreeram"</span>, <span class="string">"Babbage"</span>]

clients.<span class="built_in">sort</span>({(a: <span class="type">String</span>, b: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> 
<span class="keyword">return</span> a &lt; b }) 

<span class="built_in">println</span>(clients)
<span class="comment">// [Babbage, Buenaventura, Pestov, Sreeram]</span>
</code></pre>
<p>这样就实现了数组中的元素排序。<br>但是基于<code>Swift</code>强大的类型推断功能，我们可以将其简化为：</p>
<pre><code class="Swift">clients.<span class="built_in">sort</span>({ a, b <span class="keyword">in</span>
<span class="keyword">return</span> a &lt; b
})
</code></pre>
<p>因为这个<code>Closure</code>是有返回值的，所以编译器可以再次推断，所以我们可以这样写</p>
<pre><code class="Swift">clients.<span class="built_in">sort</span>({ a, b <span class="keyword">in</span> a &lt; b })
</code></pre>
<p>编译器还可以推断出其参数值，所以，我们这里可以写成</p>
<pre><code class="Swift">clients.<span class="built_in">sort</span>({$<span class="number">0</span> &lt; $<span class="number">1</span>})
</code></pre>
<p>因为我们还有尾随闭包，所以我们可以进一步简化</p>
<pre><code class="Swift">clients.<span class="built_in">sort</span>{$<span class="number">0</span> &lt; $<span class="number">1</span>}
</code></pre>
<h3 id="Functional-Programming"><a href="#Functional-Programming" class="headerlink" title="Functional Programming"></a>Functional Programming</h3><p>我们有很多函数式编程的高阶函数可以供调用：</p>
<pre><code class="Swift"><span class="keyword">let</span> result = words.<span class="built_in">filter</span>{ $<span class="number">0</span>.hasSuffix(<span class="string">"gry"</span>)}.<span class="built_in">map</span>{$<span class="number">0</span>.uppercaseString}
</code></pre>
<p>这样我们就可以找到所有以<code>gry</code>结尾的单词，并且将其转化为大写字母。如果这时结果是</p>
<pre><code class="Swift"><span class="type">ANGRY</span>
<span class="type">HUNGRY</span>
</code></pre>
<p>我们还可以调用<code>reduce</code>方法将其和成一个字符串</p>
<pre><code class="Swift"><span class="keyword">let</span> reducedResult = result.<span class="built_in">reduce</span>(<span class="string">"HULK"</span>){<span class="string">"<span class="subst">\($<span class="number">0</span>)</span> <span class="subst">\($<span class="number">1</span>)</span>"</span>}
</code></pre>
<p>这时结果如下：</p>
<pre><code class="Swift"><span class="type">HULK</span> <span class="type">ANGRY</span> <span class="type">HUNGRY</span>
</code></pre>
<h3 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h3><p>比高可以传递一个函数，例如：</p>
<pre><code class="Swift"> numbers.<span class="built_in">map</span> {
        <span class="built_in">println</span>($<span class="number">0</span>)
} 
numbers.<span class="built_in">map</span>(<span class="built_in">println</span>)    <span class="comment">// 可以将一个函数传递过去</span>


<span class="keyword">var</span> indexes = <span class="type">NSMutableIndexSet</span>()
numbers.<span class="built_in">map</span> {
    indexes.addIndex($<span class="number">0</span>)
} 

numbers.<span class="built_in">map</span> (indexes.addIndex) <span class="comment">// 可以将一个Method传过去</span>
</code></pre>
<h3 id="闭包是一个ARC对象"><a href="#闭包是一个ARC对象" class="headerlink" title="闭包是一个ARC对象"></a>闭包是一个ARC对象</h3><p>我们可以声明一个Closure属性：</p>
<pre><code class="Swift"><span class="keyword">var</span> onTempratureChange: (<span class="type">Int</span>) -&gt; <span class="type">Void</span> = {}
<span class="function"><span class="keyword">func</span> <span class="title">logTemperatureDifferences</span><span class="params">(initial: Int)</span></span> {
    <span class="keyword">var</span> prev = initial
    onTemperatureChange = { next <span class="keyword">in</span>
        <span class="built_in">println</span>(<span class="string">"Changed <span class="subst">\(next - prev)</span>°F"</span>)
prev = next 
}
</code></pre>
<p>因为function也是closure，那么我们可以这样写：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">logTemperatureDifferences</span><span class="params">(initial: Int)</span></span> {
    <span class="keyword">var</span> prev = initial
    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(next: Int)</span></span> {
        <span class="built_in">println</span>(<span class="string">"Changed <span class="subst">\(next - prev)</span>°F"</span>)
prev = next } 
    onTemperatureChange = log
</code></pre>
<h3 id="闭包的循环引用问题"><a href="#闭包的循环引用问题" class="headerlink" title="闭包的循环引用问题"></a>闭包的循环引用问题</h3><p>和OC中的Block一样，Swift中也会出现循环引用的问题，我们来看看怎样解决：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureNotifier</span> </span>{
    <span class="keyword">var</span> onChange: (<span class="type">Int</span>) -&gt; <span class="type">Void</span> = {}
    <span class="keyword">var</span> currentTemp = <span class="number">72</span>
    <span class="keyword">init</span>() {
        onChange = { temp <span class="keyword">in</span>
currentTemp = temp    } <span class="comment">// error: requires explicit 'self' </span>
  } 
}
</code></pre>
<p>如果出现上面的循环引用问题，编译器会直接报错的，所以我们可以用上文提到的<code>unowned</code>来解决。我们可以将init()方法用下面的来取代：</p>
<pre><code class="Swift"><span class="keyword">init</span>() { 
    <span class="keyword">unowned</span> <span class="keyword">let</span> uSelf = <span class="keyword">self</span>
    onChange = { temp <span class="keyword">in</span>
      uSelf.currentTemp = temp
    }
</code></pre>
<p>但是这样写还会出现一个问题，就是如果别处有一份逻辑一样的代码，某个人不注意拷贝过来了忘记将<code>self</code>改成uSelf，或者这个方法很长，写到下面的是忘记了将<code>self</code>改成uSelf，那么就会出现内存泄漏的问题。为了解决这个问题Swift中提出了下面的优雅做法：</p>
<pre><code class="Swift"><span class="keyword">init</span>() { onChange = {[<span class="keyword">unowned</span> <span class="keyword">self</span>] temp <span class="keyword">in</span> 
<span class="keyword">self</span>.currentTemp = temp 
} }
</code></pre>
<h2 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h2><p><code>switch</code>中可以有范围，字符串和数字，并且Enum中可以关联属性，比如：</p>
<pre><code class="Swift"><span class="comment">// case中含有范围</span>
<span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(value: Int)</span></span> { <span class="keyword">switch</span> value { 
<span class="keyword">case</span> <span class="number">0</span>...<span class="number">4</span>: <span class="built_in">println</span>(<span class="string">"a few"</span>) 
<span class="keyword">case</span> <span class="number">5</span>...<span class="number">12</span>: <span class="built_in">println</span>(<span class="string">"a lot"</span>) 
      <span class="keyword">default</span>:
        <span class="built_in">println</span>(<span class="string">"a ton"</span>)
} } 
<span class="comment">// case中</span>

<span class="class"><span class="keyword">enum</span> <span class="title">TrainStatus</span> </span>{
    <span class="keyword">case</span> <span class="type">OnTime</span>
    <span class="keyword">case</span> <span class="type">Delayed</span>(<span class="type">Int</span>)
}
</code></pre>
<p>使用的时候如下：</p>
<pre><code class="Swift"><span class="keyword">switch</span> trainStatus {
  <span class="keyword">case</span> .<span class="type">OnTime</span>:
} 
  <span class="built_in">println</span>(<span class="string">"on time"</span>)
<span class="keyword">case</span> .<span class="type">Delayed</span>(<span class="keyword">let</span> minutes)
                        :
<span class="built_in">println</span>(<span class="string">"delayed by <span class="subst">\(minutes)</span> minutes"</span>)
</code></pre>
<p>我们可以对这个<code>delay</code>做各种各样的匹配：</p>
<pre><code class="Swift"><span class="keyword">switch</span> trainStatus {
  <span class="keyword">case</span> .<span class="type">OnTime</span>:
    <span class="built_in">println</span>(<span class="string">"on time"</span>)
  <span class="keyword">case</span> .<span class="type">Delayed</span>(<span class="number">1</span>):
    <span class="built_in">println</span>(<span class="string">"nearly on time"</span>)
  <span class="keyword">case</span> .<span class="type">Delayed</span>(<span class="number">2</span>...<span class="number">10</span>):
    <span class="built_in">println</span>(<span class="string">"almost on time, I swear"</span>)
  <span class="keyword">case</span> .<span class="type">Delayed</span>(<span class="number">_</span>):
    <span class="built_in">println</span>(<span class="string">"it'll get here when it's ready"</span>)
</code></pre>
<h3 id="Pattern-Compose"><a href="#Pattern-Compose" class="headerlink" title="Pattern Compose"></a>Pattern Compose</h3><p>也就是说Pattern可以组合出现，一个Pattern中可以包含其它的Pattern，比如对上文的<code>TrainStatus</code>再做以Pattern Compose：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">enum</span> <span class="title">VacationStatus</span> </span>{
    <span class="keyword">case</span> <span class="type">Traveling</span>(<span class="type">TrainStatus</span>)
    <span class="keyword">case</span> <span class="type">Relaxing</span>(daysLeft: <span class="type">Int</span>)
} 

<span class="keyword">switch</span> vacationStatus {
  <span class="keyword">case</span> .<span class="type">Traveling</span>(.<span class="type">OnTime</span>):
    tweet(<span class="string">"Train's on time! Can't wait to get there!"</span>)
  <span class="keyword">case</span> .<span class="type">Traveling</span>(.<span class="type">Delayed</span>(<span class="number">1</span>...<span class="number">15</span>)):
    tweet(<span class="string">"Train is delayed."</span>)
  <span class="keyword">case</span> .<span class="type">Traveling</span>(.<span class="type">Delayed</span>(<span class="number">_</span>)):
    tweet(<span class="string">"OMG when will this train ride end #railfail"</span>)
  <span class="keyword">default</span>:
  <span class="built_in">print</span>(<span class="string">"relaxing"</span>)
</code></pre>
<h3 id="Type-Pattern"><a href="#Type-Pattern" class="headerlink" title="Type Pattern"></a>Type Pattern</h3><p><code>Pattern</code>不仅仅可以作用于<code>Enum</code>，还可以作用于动态的类型，如：<code>Class</code></p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">tuneUp</span><span class="params">(car: Car)</span></span> {
    <span class="keyword">switch</span> car {
      <span class="keyword">case</span> <span class="keyword">let</span> formulaOne <span class="keyword">as</span> <span class="type">FormulaOne</span>:
        formulaOne.enterPit()
      <span class="keyword">case</span> <span class="keyword">let</span> raceCar <span class="keyword">as</span> <span class="type">RaceCar</span>:
        <span class="keyword">if</span> raceCar.hasTurbo { raceCar.tuneTurbo() }
        <span class="keyword">fallthrough</span>
      <span class="keyword">default</span>:
        car.checkOil()
        car.pumpTires()
} }
</code></pre>
<p>这样在多态中就会变得非常有用了。</p>
<h3 id="Tuple-Patterns"><a href="#Tuple-Patterns" class="headerlink" title="Tuple Patterns"></a>Tuple Patterns</h3><p>Tuple pattern有其极其强大的功能，其可以对tuple的各个数值做以类型匹配。</p>
<pre><code class="Swift"><span class="keyword">let</span> color = (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)
<span class="keyword">switch</span> color {
  <span class="keyword">case</span> (<span class="number">0.0</span>, <span class="number">0.5</span>...<span class="number">1.0</span>, <span class="keyword">let</span> blue, <span class="number">_</span>):
    <span class="built_in">println</span>(<span class="string">"Green and <span class="subst">\(blue * <span class="number">100</span>)</span>% blue"</span>)
  <span class="keyword">case</span> <span class="keyword">let</span> (r, g, b, <span class="number">1.0</span>) <span class="keyword">where</span> r == g &amp;&amp; g == b:
    <span class="built_in">println</span>(<span class="string">"Opaque grey <span class="subst">\(r * <span class="number">100</span>)</span>%"</span>)
</code></pre>
<p>我们甚至可以对其中的各个数值做以相应的模式匹配。</p>
<h3 id="Pattern-Matching的应用PList校验"><a href="#Pattern-Matching的应用PList校验" class="headerlink" title="Pattern Matching的应用PList校验"></a>Pattern Matching的应用PList校验</h3><p>比如我们有下面的方法来校验Plist中的内容是否有效</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">stateFromPlist</span><span class="params">(list: Dictionary&lt;String, AnyObject&gt;)</span></span>
  -&gt; <span class="type">State</span>?
stateFromPlist([<span class="string">"name"</span>: <span class="string">"California"</span>,
                <span class="string">"population"</span>: <span class="number">38_040_000</span>,
                <span class="string">"abbr"</span>: <span class="string">"CA"</span>])
</code></pre>
<p>这时我们要对<code>population</code>的值做以限制，如果是字符串返回<code>nil</code>，如果是超过某个范围的时候返回<code>nil</code>，如果是<code>abbr</code>中字母的个数大于2时候我们也返回<code>nil</code>，利用tuple pattern matching的强大特性，我们可以这样去做：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">stateFromPlist</span><span class="params">(list: Dictionary&lt;String, AnyObject&gt;)</span></span>
  -&gt; <span class="type">State</span>? {

<span class="keyword">switch</span> (list[<span class="string">"name"</span>], list[<span class="string">"population"</span>], list[<span class="string">"abbr"</span>]) { 
<span class="keyword">case</span> ( 
        .<span class="type">Some</span>(<span class="keyword">let</span> listName <span class="keyword">as</span> <span class="type">NSString</span>), 
        .<span class="type">Some</span>(<span class="keyword">let</span> pop <span class="keyword">as</span> <span class="type">NSNumber</span>),
        .<span class="type">Some</span>(<span class="keyword">let</span> abbr <span class="keyword">as</span> <span class="type">NSString</span>)
      ) <span class="keyword">where</span> abbr.length == <span class="number">2</span>:
    <span class="keyword">return</span> <span class="type">State</span>(name: listName, population: pop, abbr: abbr)
  <span class="keyword">default</span>:
<span class="keyword">return</span> <span class="literal">nil</span> 
   } 
}
</code></pre>
<p>这就利用了tuple和限制想结合的方式优雅的解决了这个问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/02/wwdc-better-app-with-value-type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/02/wwdc-better-app-with-value-type/" itemprop="url">怎样用好Value Type?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-02T16:37:56+08:00">
                2017-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Swift–怎样用好Value-Type"><a href="#Swift–怎样用好Value-Type" class="headerlink" title="Swift–怎样用好Value Type?"></a>Swift–怎样用好Value Type?</h1><p><img src="http://upload-images.jianshu.io/upload_images/1513759-6b88775e60bbef0f.png" alt="Value Type"></p>
<h2 id="为什么要用Value-Type"><a href="#为什么要用Value-Type" class="headerlink" title="为什么要用Value Type?"></a>为什么要用Value Type?</h2><p>首先我们要说明为什么我们需要<code>Value Type</code>。因为我们通常使用的<code>Reference Type</code>不能满足我们的需求，并且容易出Bug，什么是<code>Reference Type</code>?<br>Reference Type就是我们常说的Class，我们不是用的很好吗？我们举两个例子来看看<br>例一：但是现在又一种需求：进入用于信息页面编辑页面，如果用户的信息改变了，并且没有点击保存，这时如果点击导航栏的退出，要给用户提醒”您编辑了信息，确定不保存退出吗？”，这时为了保存进入编辑页面的信息，我们一般这样做</p>
<ol>
<li>增加一个originInfo的property。</li>
<li>在ViewDidLoad的时候赋值：self.originInfo = passedInfo;（这个passedInfo从上个页面传来）</li>
<li>在点击退出的时候对比passedInfo和self.originInfo是否相等，如果不相等则提醒用户，如果相等则返回。<br>这时你会发现一个bug，这两个对象永远都是相同的，为什么？</li>
</ol>
<p>例二：我们要从商品列表中进入商品编辑页面，这时，我们点击了编辑，将<code>goodModel</code>传到第二个页面，在第二个页面操作完之后，用户没有保存信息，返回了，这时你也可能会发现，你列表中的商品信息改变了。</p>
<p>例三：Cell复用造成的布局混乱。<br>上述两种情景是<code>Reference Type</code>，也就是说他们的都指向了堆上的相同对象，这种类型对对象的公用造成了一系列的bug。并且这种bug很难被发现，并且往往也不是必现的。<br>怎样解决呢？<br>这时我们就需要Copy原来的instance，在OC中我们需要遵守NSCopying，或者NSMutableCopying协议，因为这些，然后实现相应的协议，例如：</p>
<pre><code class="Objective-C">@interface HYLocationModel : NSObject&lt;NSMutableCopying&gt;
// cityDic{@&quot;name&quot;:@&quot;&quot;,@&quot;id&quot;:@&quot;&quot;}
@property (nonatomic, strong) NSDictionary *cityDic; //City
@property (nonatomic, strong) NSDictionary *areaDic; //
@property (nonatomic, strong) NSDictionary *districtDic;

@end
@implementation HYLocationModel
- (id)mutableCopyWithZone:(NSZone *)zone {

    HYLocationModel *locationModel = [[HYLocationModel alloc]init];
    locationModel.cityDic = self.cityDic;
    locationModel.areaDic = self.areaDic;
    locationModel.districtDic = self.districtDic;
    return locationModel;
}
@end
</code></pre>
<p>这样我们就可以Copy对象了，将Copy的对象赋值给self.originInfo，就可以解决上述的bug。<br>但是这会消耗性能，因为需要在堆里开辟内存空间。NSCopying协议在OC中很常见，比如NSString，NSArray，NSDictionary等都遵守NSCopying协议。其中NSDictionary的Key，默认是实现了NSCopying协议的，因为在给NSDictionary赋值的时候，系统默认是Copy了它的Key，因为如果不Copy它的Key，如果你给字典赋值之后改变了这个Key，那么它将会使整个NSDictionary混乱，出现意想不到的Bug。当然这种Copy也会消耗性能。</p>
<h2 id="不可变对象是否可以解决上述问题呢？"><a href="#不可变对象是否可以解决上述问题呢？" class="headerlink" title="不可变对象是否可以解决上述问题呢？"></a>不可变对象是否可以解决上述问题呢？</h2><p>在函数式编程中，我们会使用不可变的<code>Reference Type</code>来消除其可变所带来的问题，想象下如果你做数学题题目A中的X值被题目B改变了，那么会有怎样的结果？<br>在Swift中，我们可以使用let来使其不可变，但是这种不可变的数据结构有以下弊端：</p>
<ol>
<li>可能导致很恶心的接口（见下文）。</li>
<li>不能有效地和机器模型相匹配(因为我们的寄存器，我们的Cache，Memory，Storage都是可变状态的)。</li>
</ol>
<p>比如下面的代码</p>
<pre><code class="Swift"><span class="comment">// With mutability </span>
home.oven.temperature.fahrenheit += <span class="number">10.0</span>

<span class="comment">//Without mutability </span> <span class="keyword">let</span> temp = home.oven.temperature home.oven.temperature = <span class="type">Temperature</span>(fahrenheit: temp.fahrenheit + <span class="number">10.0</span>)
</code></pre>
<p>在上面的例子中，我们把Temperature类的某个属性改成了<code>let</code>，那么如果我们要更改这个数值，我们就需要在堆上开辟内存空间然后创建一个新的Temperature，最后更换掉整个Temperature类。<br>Cocoa[Touch]中有很多的不可变类比如：NSDate，NSURL，UIImage，NSNumber等<br>这更加安全了（不需要使用Copy），也不必担心接下来的程序会改变这个数值。</p>
<pre><code class="Objective-C">NSArray&lt;NSString *&gt; *array = [NSArray arrayWithObject: NSHomeDirectory()];
NSString *component;  while ((component = getNextSubdir()) { 
     array = [array arrayByAddingObject: component]; } 
     url = [NSURL fileURLWithPathComponents: array];
</code></pre>
<h2 id="Value-Type将怎样解决这种问题呢？"><a href="#Value-Type将怎样解决这种问题呢？" class="headerlink" title="Value Type将怎样解决这种问题呢？"></a>Value Type将怎样解决这种问题呢？</h2><p>Swift中的所有基础类型都是Value Type的，像：Int，Double，String …<br>Swift中所有的Collection都是Value Type的，像：Array，Set，Dictianry…<br>Swift中的<code>Tuples，Struct，Enums</code>如果只包含Value Types那么他们自身也是Value Type的。<br>Value Type要是完全可以直接比较的，可以直接使用<code>==</code>，<strong>自定义的Value Type并且其必须要遵守<code>Equable</code>协议，覆盖<code>==</code>方法才可以使用的</strong>。</p>
<pre><code class="Swift"><span class="keyword">var</span> a: [<span class="type">Int</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
<span class="keyword">var</span> b: [<span class="type">Int</span>] = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].sorted(by:&lt;)
<span class="built_in">assert</span>(a == b) <span class="comment">// true</span>
</code></pre>
<p>如果是自身的定义的Struct，那么需要遵守<code>Equable</code>协议，并且覆盖<code>==</code>方法来实现。比如：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">Temperature</span>: <span class="title">Equatable</span> </span>{
  <span class="keyword">var</span> celsius: <span class="type">Double</span> = <span class="number">0</span>
  <span class="keyword">var</span> fahrenheit: <span class="type">Double</span> {
    <span class="keyword">get</span> { <span class="keyword">return</span> celsius * <span class="number">9</span> / <span class="number">5</span> + <span class="number">32</span> }
    <span class="keyword">set</span> { celsius = (newValue - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span> }
 }
}
<span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Temperature, rhs: Temperature)</span></span> -&gt; <span class="type">Bool</span> {
  <span class="keyword">return</span> lhs.celsius == rhs.celsius
}
</code></pre>
<p>使用Value Type不用担心竞争条件。也就是不用担心资源抢夺，加锁等。看下面的代码：</p>
<pre><code class="Swift"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]
scheduler.processNumbersAsynchronously(numbers) <span class="comment">//异步处理numbers</span>
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;numbers.<span class="built_in">count</span> { numbers[i] = numbers[i] * i }
scheduler.processNumbersAsynchronously(numbers) <span class="comment">//异步处理numbers</span>
</code></pre>
<p>在Reference Type中这个<code>numbers</code>将会发生资源抢夺，但在Swift中是Value Type的，在执行<code>for i in 0..&lt;numbers.count { numbers[i] = numbers[i] * i }</code>的时候会发生Copy操作，所以不会发生资源抢夺。也就是说每次将Value Type赋值给其它的Value Type的时候会发生拷贝（逻辑拷贝）操作，但是这种Copy消耗的时间很微小，并且系统会将Copy推迟到写操作执行的时候，这就是Copy on Write。<em>在Swift中可以利用Protocol将Struct等ValueType封装，类似于OOP中的多态</em></p>
<h2 id="Swift中的Value-Type和Reference-Type混用会怎样呢？"><a href="#Swift中的Value-Type和Reference-Type混用会怎样呢？" class="headerlink" title="Swift中的Value Type和Reference Type混用会怎样呢？"></a>Swift中的Value Type和Reference Type混用会怎样呢？</h2><p>我们来看Structh中含有结构体的情况：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">ButtonWrapper</span> </span>{
   <span class="keyword">var</span> button: <span class="type">Button</span>
}
</code></pre>
<p>在这种情况下，复制ButtonWrapper的时候将会共享button这个Reference Type。这就违背了我们上文所说的Value Type在重新赋值的时候拷贝（深拷贝，和原来的Struct没有关系）。怎样才可以做到这一点呢？比如下面的</p>
<h3 id="Value-Type-中含有不可变的Reference-Type"><a href="#Value-Type-中含有不可变的Reference-Type" class="headerlink" title="Value Type 中含有不可变的Reference Type"></a>Value Type 中含有不可变的Reference Type</h3><pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">Image</span>: <span class="title">Drawable</span> </span>{
  <span class="keyword">var</span> topLeft:<span class="type">CGPoint</span>
  <span class="keyword">var</span> image: <span class="type">UIImage</span>
}
<span class="keyword">var</span> image = <span class="type">Image</span>(topLeft:<span class="type">CGPoint</span>(x:<span class="number">0</span>,y:<span class="number">0</span>),image:<span class="type">UIImage</span>.<span class="keyword">init</span>(named: <span class="string">"someImage.png"</span>))
<span class="keyword">var</span> image2 = image
</code></pre>
<p>这时image和image2将会公用一个UIImage：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-fb29f1978b1a0b66.png" alt="ValueType Contains Reference Type"><br>在实现<code>Equatable</code>协议的时候，我们这么做：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">extension</span> <span class="title">Image</span>: <span class="title">Equatable</span> </span>{   }
<span class="function"><span class="keyword">func</span> == <span class="params">(<span class="keyword">left</span>:Iamge, <span class="keyword">right</span>:Image)</span></span> -&gt; <span class="type">Bool</span> {
 <span class="keyword">return</span> <span class="keyword">left</span>.topLeft == <span class="keyword">right</span>.topLeft &amp;&amp; <span class="keyword">left</span>.image === <span class="keyword">right</span>.image
}
</code></pre>
<p>但是由于UIImage是不可变的，所以我们不必担心image2的image对象的改变会影响到image的image对象。<br><em>注：上面<code>===</code>表示引用相同，但是不表示其指向<code>Image</code>是相同的，如果要表示其相同，需要使用<code>==</code>操作。</em></p>
<h3 id="Value-Type-中含有可变的Reference-Type"><a href="#Value-Type-中含有可变的Reference-Type" class="headerlink" title="Value Type 中含有可变的Reference Type"></a>Value Type 中含有可变的Reference Type</h3><p>下面我们来看一个可变的Reference Type。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">BezierPath</span>: <span class="title">Drawable</span> </span>{
  <span class="keyword">var</span> path = <span class="type">UIBezierPath</span>()
  <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> {
    <span class="keyword">return</span> path.empty
} 
  <span class="comment">// **注意这种写法是错误的**</span>
  <span class="function"><span class="keyword">func</span> <span class="title">addLineToPoint</span><span class="params">(point: CGPoint)</span></span> {
    path.addLineToPoint(point)
} }
</code></pre>
<p>其内存结构是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-f574f73819356261.png" alt="Value Contains Reference Type"></p>
<p>这时如果我们如果执行下面的代码</p>
<pre><code class="Swift"><span class="keyword">var</span> bezierPath1 = bezierPath0
</code></pre>
<p>就会发现意想不到的Bug，因为你对bezierPath1的任何改动都将会显示到bezierPath0上。<br>怎样解决这样的问题呢？这时我们需要使用<strong>Copy On Write</strong></p>
<blockquote>
<p>对Value Type中的Reference Type做改动将会破坏Value Type的”完全独立”特性。<br>所以我们必须将可变的Reference Type和不可变的操作分开<br>不可变操作总是安全的<br>可变操作必须首先Copy</p>
</blockquote>
<p>怎样做到Copy On Write呢？我们需要给BezierPath中加入如下代码：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">BezierPath</span>: <span class="title">Drawable</span> </span>{ 
<span class="keyword">private</span> <span class="keyword">var</span> _path = <span class="type">UIBezierPath</span>()  <span class="keyword">var</span> pathForReading: <span class="type">UIBezierPath</span> { 
<span class="keyword">return</span> _path 
}  <span class="keyword">var</span> pathForWriting: <span class="type">UIBezierPath</span> {
    <span class="keyword">mutating</span> <span class="keyword">get</span> {      _path = _path.copy() <span class="keyword">as</span>! <span class="type">UIBezierPath</span> 
    <span class="keyword">return</span> _path 
} } 
}
</code></pre>
<p>这样我们就可以将上述的错误代码改为：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">extension</span> <span class="title">BezierPath</span> </span>{ 
<span class="keyword">var</span> isEmpty: <span class="type">Bool</span> {
<span class="keyword">return</span> pathForReading.empty 
} 
 <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addLineToPoint</span><span class="params">(point: CGPoint)</span></span> {
    pathForWriting.addLineToPoint(point)
  }
}
</code></pre>
<p>这样，我们在执行：</p>
<pre><code class="Swift"><span class="keyword">var</span> path = <span class="type">BezierPath</span>()
<span class="keyword">var</span> path2 = path
<span class="keyword">if</span> path.empty { <span class="built_in">print</span>(<span class="string">"Path is empty"</span>) }
<span class="keyword">var</span> path2 = path
path.addLineToPoint(<span class="type">CGPoint</span>(x: <span class="number">10</span>, y: <span class="number">20</span>))
path.addLineToPoint(<span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">125</span>))
</code></pre>
<p>这段代码的时候就会在addLineToPoint的时候执行Copy，这就不会出现改动path而影响path2的现象了。<br>但是还有一个问题，每次执行addLineToPoint的时候都需要执行Copy操作，有时候如果这个对象只有一个引用那么就不需要这种操作，所以我们可以利用<code>isUniquelyReferencedNonObjC()</code>方法来判断时候需要Copy,如果返回true，说明只有一个对象在用，就不必Copy，如果返回false，说明很多对象在用，这个时候就需要执行Copy操作了。<br>用法如下：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">MyWrapper</span> </span>{
  <span class="keyword">var</span> _object: <span class="type">SomeSwiftObject</span>
  <span class="keyword">var</span> objectForWriting: <span class="type">SomeSwiftObject</span> {
    <span class="keyword">mutating</span> <span class="keyword">get</span> {
     <span class="keyword">if</span> !<span class="built_in">isUniquelyReferencedNonObjC</span>(&amp;_object)) {
        _object = _object.copy()
     }
     <span class="keyword">return</span> _object
    }
} }
</code></pre>
<blockquote>
<p>注：</p>
<ol>
<li>需要标示记忆过程的时候，比如实现撤销操作，需要恢复之前数值的时候。（备忘录模式）</li>
<li>比如需要对新的变化做特殊处理的时候，因为我们已经记忆了之前的过程，只需要对最新的Value Type改变，比如：本博客中的第一张图片，如果衣服颜色改变了，那么就只改变衣服颜色的那几个方格的值即可。</li>
</ol>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://developer.apple.com/videos/play/wwdc2015/414/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2015/414/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/01/Why-Swift-IS-swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/01/Why-Swift-IS-swift/" itemprop="url">为什么Swift比OC快？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-01T19:34:23+08:00">
                2017-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Swift相比OC以及其它语言，有很多的优化点，这篇文章将从方法调度的角度去说明为什么Swift要比OC更快。OC是一门动态的语言，很多实际执行需要在运行时才可以确定，Swift不一样，<strong>Swift将很多在运行时才可以确定的信息，在编译期就决定了</strong>。这就让Swift更加快速。<br>方法调度就是程序在触发方法时选择需要执行指令的过程，它在每次方法执行时都会发生。如果这种调度发生在编译期，我们称它为静态调度（Static Dispatch），如果调度发生在运行时，那么我们称它为动态调度（Dynamic Dispatch）。静态调度往往要比动态调度要快。那么问题来了，为什么我们需要动态调度呢？全部用静态调度不就得了？<br>问题就在于我们很多时候我们需要用到多态，看看下面这段非常简单的代码<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"animal eat"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sleep</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"animal sleep"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">sleep</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"dog sleep"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span>: <span class="title">Animal</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"rabbit sleep"</span>);</div><div class="line">    &#125;</div><div class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">sleep</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"rabbit sleep"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> animal:<span class="type">Animal</span>?</div><div class="line"><span class="keyword">var</span> somThingTrue = <span class="literal">false</span></div><div class="line"><span class="comment">//执行很多业务逻辑</span></div><div class="line"><span class="keyword">if</span> somThingTrue &#123;</div><div class="line">    animal = <span class="type">Rabbit</span>()</div><div class="line">    </div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">    animal = <span class="type">Dog</span>()</div><div class="line">&#125;</div><div class="line">animal?.eat()</div></pre></td></tr></table></figure></p>
<p>上面的代码中<code>animal?.eat()</code>就不能够在编译期确定，因为其中需要很多的业务逻辑(比如根据用户的不同，或者网络请求结果的不同)来确定就究竟创建出来的对象是Rabbit还是Dog，也就无法最终确定要调用那个对象的eat()方法。相似的代码在OC中是怎样执行的呢？在OC中编译器会将这个方法翻译成<code>objc_msgSend(target,@selector(eat),nil)</code>这个方法，然后到了运行时，会分为以下几步进行调用：</p>
<ol>
<li>找到方法target中isa对应的Class（如果是类方法要到其metaClass中找）。</li>
<li>从其中的<code>struct objc_method_list **methodLists</code>找到对应的方法实现。</li>
<li>如果没有找到就到superClass的<code>methodLists</code>中找。</li>
</ol>
<p>如果在Swift中，它是怎样做方法调度的呢？</p>
<ol>
<li>找到target对应的class</li>
<li><p>从class的V-Table中的那得到函数的实现<br>Swift中的类会创建一个V-Table，这个Table是一个数组，其中存放的是函数指针。子类会按照父类V-Table中函数的存放，如果子类没有覆盖某个方法，那么就会拷贝父类方法的地址，如上面的例子会得到下面的V-Table。</p>
<h2 id="Animal"><a href="#Animal" class="headerlink" title=" Animal"></a> Animal</h2><p> Index0 eat 0x0001<br> Index1 sleep 0x0004</p>
<h2 id="Dog"><a href="#Dog" class="headerlink" title=" Dog"></a> Dog</h2><p> Index0 eat 0x0001 (copied)<br> Index1 sleep 0x0008 (overrideen)</p>
<h2 id="Rabbit"><a href="#Rabbit" class="headerlink" title=" Rabbit"></a> Rabbit</h2><p> Index0 eat 0x0002 (overrideen)<br> Index1 sleep 0x0003 (overrideen)</p>
<p>可以注意到Dog因为没有覆盖父类的<code>eat</code>方法，所以其copy了父类的<code>0x0010</code>指针。因为Swift是Type Safe的，所以在调用它的时候它不会变成<code>Robot</code>或者其它的类（如果不能通过编译），所以无论是调用上面结构中的Animal，Dog，还是Rabbit类，它都是调用相同的Index，得到对应的方法实现。<strong>将函数指针和Index所做的映射在编译期就确定了，这就大大减少了运行时的工作量，提高了运行速度。</strong>所以在运行时它没有必要知道是哪个类型的实例调用了这个方法，只需要找到相应的V-Table即可，至于是其中的哪个Index已经在编译期确定了，没必要再去查找Index的值。<br>然而Swift的方法调度不仅仅是动态方法调度，还有很多静态方法调度。<br><strong>如果我们将某个方法标记为final或者private，或者我们不用类，而使用结构体，枚举，这时就不需要动态调度，只需要静态调度即可，这样速度会更快。</strong></p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/07/30/method-dispatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/30/method-dispatch/" itemprop="url">method_dispatch</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-30T18:37:43+08:00">
                2017-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Swift中的方法调度"><a href="#Swift中的方法调度" class="headerlink" title="Swift中的方法调度"></a>Swift中的方法调度</h1><p><a href="https://stackoverflow.com/questions/38877465/are-method-swizzling-and-isa-swizzling-the-same-thing/38878119#38878119" target="_blank" rel="external">ISA Swizzling</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-95ac273f0c0d68b5.png" alt="Iamges"></p>
<p>##扩展阅读：<br><a href="https://www.raizlabs.com/dev/2016/12/swift-method-dispatch/" target="_blank" rel="external">https://www.raizlabs.com/dev/2016/12/swift-method-dispatch/</a><br><a href="https://www.skilled.io/u/purpleyay/why-swift-is-swift" target="_blank" rel="external">https://www.skilled.io/u/purpleyay/why-swift-is-swift</a><br><a href="https://oleb.net/blog/2016/06/kevin-ballard-swift-dispatch/" target="_blank" rel="external">https://oleb.net/blog/2016/06/kevin-ballard-swift-dispatch/</a><br><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001922.html" target="_blank" rel="external">https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001922.html</a><br><a href="https://developer.apple.com/swift/blog/?id=27" target="_blank" rel="external">https://developer.apple.com/swift/blog/?id=27</a><br><a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001948.html" target="_blank" rel="external">https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001948.html</a><br><a href="https://medium.com/@leandromperez/protocol-extensions-gotcha-9ef1a42c83b6" target="_blank" rel="external">https://medium.com/@leandromperez/protocol-extensions-gotcha-9ef1a42c83b6</a><br><a href="https://stackoverflow.com/questions/38332616/at-runtime-how-does-swift-know-which-implementation-to-use" target="_blank" rel="external">https://stackoverflow.com/questions/38332616/at-runtime-how-does-swift-know-which-implementation-to-use</a><br><a href="https://untitledkingdom.com/blog/obj-c-vs-swift/" target="_blank" rel="external">https://untitledkingdom.com/blog/obj-c-vs-swift/</a><br><a href="http://cocoasamurai.blogspot.kr/2010/01/understanding-objective-c-runtime.html" target="_blank" rel="external">http://cocoasamurai.blogspot.kr/2010/01/understanding-objective-c-runtime.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/07/30/wwdc-understand-swift-performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/30/wwdc-understand-swift-performance/" itemprop="url">理解Swift的性能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-30T13:26:43+08:00">
                2017-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>草稿：</strong><br>本博客主要来源于WWDC2016-416，UnderStanding Swift Performance。<br>Swift性能指标：</p>
<ol>
<li>Stack VS Heap</li>
<li>Reference Count</li>
<li>Method Dispatch中Static多还是Dynamic多<br>栈上的操作更加高效，降低栈指针来创建，增加栈指针来释放栈。<br>堆上可以存放高级数据结构，但是堆的操作效率是更低的，因为每次开辟堆空间都需要寻找空闲的内存块。在消除的时候需要重新插入一个内存块。除此之外，Class等存在堆上的对象，需要开辟我们看不到的空间，这些空间是需要消耗内存的。<br>引用计数的不断操作会降低性能。所以要尽可能少的创建Class。<br>在Struct中包含Class是会降低性能的，我们要尽量减少这种情况的出现，比如在使用纯字符串的时候，我们可以使用Enum，或者其它的值类型来替代。<br>如果Struct中包含Class对象，那么在CopyStruct的时候也会拷贝其引用计数，包含的Class越多，就需要操作更多的retain和release方法方法。<br>Swift在调用一个函数的时候，我们需要跳到对应的方法实现。<br>Static 调度：如果在编译时期就可以确定某个方法的实现的话，就可以直接跳转到相应的方法的。并且是inline方法。既然静态调度这么好，为什么还需要Dynamic Dispatch呢？因为我们需要执行各种业务逻辑，需要根据具体的场景来决定究竟调用那个方法，我们需要使用多态。<br>对于类，那么编译器会增加一个指针来存储来指向那个类的Type信息，并且存到静态区。在执行函数调用时，编译器会到该类型对应的虚拟方法表（VTable）中找到相应的方法实现。将类标记为<code>final</code>时，其方法的调用将变为静态派发。在不需要动态派发的时候，我们应该尽量使用静态派发。</li>
</ol>
<p>怎样是用<code>Struct</code>写多态呢？Protocol类型的变量是怎样被存储，被拷贝，以及方法调度是怎样工作的呢？<br>Static Dispatches VS Dynamic Dispatch<br>Static方法：可以在编译时确定需要调用的方法实现，在运行时，可以直接调用并且可以做<code>inline</code>优化。<br>Dynamic方法：需要在运行时在表中找到对应的方法的实现。并且会妨碍inlining及其它的性能优化。当我们利用了多态之后，我们就难以确定这个方法究竟是调用那个方法，也就是说必须在运行时去确定到底要执行那个方法的实现。<br>Swift中Protocol Type的多态，由于没有继承，所以就没有了<code>V-Table</code>方式的调度。Swift使用了一种Protocol Witness Table的技术来调度Protocol Type的方法，这个表格的入口和该Type的实现先链接，因此找到这个表格就找到了方法的实现，那么我们怎样找到这个Table呢？，注意数组中的数值都有相同的offset，因此Swift使用Existential Container来封装protocol type，它的前三个字（两个字节称为一个字）是valueBuffer，小数据，例如两个word的Point可以存储，但是大于三个字时候，swift将会开辟一个堆空间，并且将这个控件的地址存储在Existential Container里面。<br>Swift让value Type，比如Strut和protocol一起获得了动态调度行为，实现了动态多态。<br>Copy on write：Swift自己提供了Copy on Write的机制，但是如果我们自己写了结构体，并且结构体比较重，还有其它的引用类型，在Copy结构体的时候，我们同时需要Copy这个对象，所以在Write的时候，我们需要判断这个引用类型的引用计数，然后做相应的改变。<br>因此Existential Container需要处理不同的数据类型，这是怎样实现的呢？这需要另外一个基于表的机制–Value Witness Table，程序中的每一个type都有一个这样的表，它包含以下几部分：<br>allocate:<br>copy:<br>destruct:<br>deallocate:<br>Whole Model优化可以让同一个模块中的不同文件都可以同时优化。<br>Type不会在运行时改变。</p>
<p>Generics-Small Value<br>如果使用泛型，那么每次函数的调用就只能产生一个call context，并且call context中的类型是一定的，这里Swift不会使用Existential container，它可以直接传递value witness table和 protocol witness table</p>
<ol>
<li>没有比必要开辟堆空间，没有在堆上进行操作，所以不需要考虑线程安全，无需对线程进行加锁。</li>
<li>没有引用计数，操作引用计数也需要是线程安全的，因为引用计数操作极其频繁，所以其性能消耗会逐渐增多，并且不是可以忽略的。</li>
<li>通过Protocol Witness Table进行动态调度以实现多态<br>Generics-Large Value</li>
<li>使用indirect storage 来开辟堆空间</li>
<li>如果包含引用类型的话会有引用计数</li>
<li>通过Protocol Witness Table进行动态调度实现多态</li>
</ol>
<p>总结：<br>尽可能少的使用dynamic runtime，选择合适的抽象。这样编译器可以做错误检查，并且可以做优化，提升代码执行速度。<br>Class类型：identity或者OOP类型的多态。<br>结构体&amp;枚举类型：值语义。<br>Protocol types：动态多态。<br>泛型和值语义相结合可以实现静态多态。<br>使用indirect Storage来处理大数值。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/07/28/note-advance-swift-collection-protocols/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/28/note-advance-swift-collection-protocols/" itemprop="url">Swift中Collection的Protocol</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-28T17:37:51+08:00">
                2017-07-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Sequences"><a href="#Sequences" class="headerlink" title="Sequences"></a>Sequences</h2><p><code>Sequence</code>协议位于系统架构的底层，其定义是<br>   <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line">   </div><div class="line"> associatedtype <span class="type">Iterator</span>: <span class="type">IteratorProtocol</span></div><div class="line"> <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span>-&gt; <span class="type">Iterator</span></div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h2><pre><code><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">IteratorProtocol</span></span>&#123;</div><div class="line">associatedtype <span class="type">Element</span></div><div class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span>-&gt; <span class="type">Element</span>?</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>实现了IteratorProtocol协议就可以遍历实例中的数据了，比如：<br>    <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PrefixIterator</span>:<span class="title">IteratorProtocol</span> </span>&#123;</div><div class="line">   <span class="keyword">let</span> string:<span class="type">String</span></div><div class="line">   <span class="keyword">var</span> offset:<span class="type">String</span>.<span class="type">Index</span></div><div class="line">   <span class="keyword">init</span>(string:<span class="type">String</span>) &#123;</div><div class="line">       <span class="keyword">self</span>.string = string</div><div class="line">       offset = string.startIndex</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">typealias</span> <span class="type">Element</span> =  <span class="type">String</span> <span class="comment">// 这里可以省略，因为编译器可以从返回值的类型中推断出来</span></div><div class="line">   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String</span>? &#123;</div><div class="line"></div><div class="line">       <span class="keyword">guard</span> offset &lt; string.endIndex <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</div><div class="line">       offset = string.index(after: offset)</div><div class="line">       <span class="keyword">let</span> offSetString = string[string.startIndex..&lt;offset]</div><div class="line">       <span class="keyword">return</span> offSetString;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="keyword">var</span> prefixIterator = <span class="type">PrefixIterator</span>.<span class="keyword">init</span>(string: <span class="string">"Hello"</span>)</div><div class="line"> <span class="keyword">while</span> <span class="keyword">let</span> content = prefixIterator.next() &#123;</div><div class="line">    <span class="built_in">print</span>(content)</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PrefixSequence</span>:<span class="title">Sequence</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> string: <span class="type">String</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">PrefixIterator</span> &#123;</div><div class="line">       </div><div class="line">       <span class="keyword">return</span> <span class="type">PrefixIterator</span>(string:string)</div><div class="line">       </div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">    <span class="keyword">for</span> <span class="keyword">prefix</span> <span class="keyword">in</span> <span class="type">PrefixSequence</span>(string:<span class="string">"Hello"</span>)&#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"for in<span class="subst">\(<span class="keyword">prefix</span>)</span>"</span>)</div><div class="line">   &#125;</div><div class="line">   <span class="type">PrefixSequence</span>(string:<span class="string">"Hello"</span>).<span class="built_in">map</span> &#123;$<span class="number">0</span>.uppercased()&#125;</div></pre></td></tr></table></figure></p>
<p>如上所示，我么要想对一个Type实现for in 操作，需要两步：</p>
<ol>
<li>创建一个遍历器：让其遵守<code>IteratorProtocol</code>协议</li>
<li>创建一个Type：让其遵守<code>Sequence</code>协议，在实现<code>makeIterator</code>方法时将第一步中的<code>Iterator</code>返回即可<br><code>Iterator</code>有两种不同的语义，<strong>值语义</strong>(将要遍历的实例拷贝)和<strong>引用语义</strong>（不拷贝所遍历的实例），比如</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">		<span class="keyword">let</span> sequ = <span class="built_in">stride</span>(from: <span class="number">0</span>, to: <span class="number">10</span>, by: <span class="number">1</span>)</div><div class="line">		<span class="keyword">var</span> i1 = sequ.makeIterator() <span class="comment">// StrideToIterator</span></div><div class="line">		i1.next() <span class="comment">//Optional(0)</span></div><div class="line">		i1.next() <span class="comment">//Optional(1)</span></div><div class="line">		</div><div class="line">		<span class="keyword">var</span> i2 = i1;</div><div class="line">		i1.next() <span class="comment">//Optional(2)</span></div><div class="line">		i1.next() <span class="comment">//Optional(3)</span></div><div class="line">		</div><div class="line">		i2.next() <span class="comment">//Optional(2)</span></div><div class="line">		i2.next() <span class="comment">//Optional(3)</span></div><div class="line">		```	</div><div class="line">这个<span class="type">StrideToIterator</span>是值语义，所以在赋值的时候会执行拷贝操作。</div><div class="line"><span class="type">AnyIterator</span>会将基础<span class="type">Iterator</span>用内部box对象封装，这个box对象时引用类型的，所以其是引用语义。比如:</div><div class="line">      ```<span class="type">Swift</span></div><div class="line">      <span class="keyword">var</span> i3 = <span class="type">AnyIterator</span>(i1)</div><div class="line">      <span class="keyword">var</span> i4 = i3   </div><div class="line">      i3.next() <span class="comment">// Optional(4)</span></div><div class="line">      i4.next() <span class="comment">// Optional(5)</span></div><div class="line">      <span class="keyword">let</span> fibsSequence2 = sequence(state:(<span class="number">0</span>, <span class="number">1</span>)) &#123; (state:<span class="keyword">inout</span> (<span class="type">Int</span>, <span class="type">Int</span>)) -&gt; <span class="type">Int</span>? <span class="keyword">in</span></div><div class="line">   </div><div class="line">    <span class="keyword">let</span> upcomingNumber = state.<span class="number">0</span></div><div class="line">    state = (state.<span class="number">1</span> , state.<span class="number">0</span> + state.<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> upcomingNumber</div><div class="line">    </div><div class="line">     &#125;</div><div class="line">     <span class="type">Array</span>(fibsSequence2.<span class="keyword">prefix</span>(<span class="number">10</span>))</div></pre></td></tr></table></figure>
<p>  Sequence的闭包是懒执行的，只有到获取某个数值的时候才执行，比如</p>
<pre><code>Array(fibsSequence2.prefix(10))
</code></pre><p>   这才让构造方法<code>fibsSequence2.prefix(10)</code>产生作用，如果<code>Sequence</code>提前计算了其数值，因为其实无穷<code>Sequence</code>，所以当越界的时候其就会崩溃。</p>
<p>  有些Sequence是不稳定的，也就是说每次的遍历，结果可能不一样，比如网络流，磁盘文件，UI事件流，以及其它类型的数据，它们都可以被建模，作为<code>Sequence</code>。这也就是为什么，<strong>取出第一个元素的属性只存在于Collection中</strong>，而不是在<code>Sequence</code>中，因为改这个<code>first</code>方法一定要是<code>nondestructive</code>的，也就是说取出第一个元素不应该对其输出结果产生影响，也就是说必须是稳定的。</p>
<p>  怎样判断一个<code>Sequence</code>是否是稳定的？<br>  如果一个<code>Sequence</code>遵守<code>Collection</code>，那么它就是稳定的。<br>  反过来，就不成立了：如果一个<code>Sequence</code>是稳定的，那么它就是遵守<code>Collection</code>协议的。这时不成立的。比如：<code>StrideTo</code>和<code>StrideThrough</code>类型，就是稳定的，然而他们没有遵守<code>Collection</code>协议。</p>
<h2 id="Sequences和Iterator之间的关系是怎样的？"><a href="#Sequences和Iterator之间的关系是怎样的？" class="headerlink" title="Sequences和Iterator之间的关系是怎样的？"></a>Sequences和Iterator之间的关系是怎样的？</h2><p>Sequences和Iterator那么相似，为什么不把他们合并成一个呢？在<code>destructively consumed sequence</code>中可以，因为他们可以共用一个Iterator，但是在<code>stable sequence</code>中是不行的，因为它们需要Iterator提供的隔离的遍历状态和遍历逻辑（这种遍历状态就是Iterator创建的）。<code>makeIterator</code>也就是为了创建这种遍历状态。</p>
<h2 id="SubSequence"><a href="#SubSequence" class="headerlink" title="SubSequence"></a>SubSequence</h2><p>Sequence有另外的一个关联属性SubSequence<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line">associatedtype <span class="type">Iterator</span> : <span class="type">IteratorProtocol</span></div><div class="line">associatedtype <span class="type">SubSequence</span> </div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以对其<code>SubSequence</code>做以限制，比如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Iterator</span>.<span class="title">Element</span>: <span class="title">Equatable</span>,</span></div><div class="line"><span class="title">SubSequence</span>: <span class="title">Sequence</span>,</div><div class="line"><span class="title">SubSequence</span>.<span class="title">Iterator</span>.<span class="title">Element</span> == <span class="title">Iterator</span>.<span class="title">Element</span> &#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">headMirrorsTrail</span><span class="params">(<span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> head = <span class="keyword">self</span>.<span class="keyword">prefix</span>(n)</div><div class="line">    <span class="keyword">let</span> trail = <span class="keyword">self</span>.suffix(n).reversed()</div><div class="line">    <span class="keyword">return</span> head.elementsEqual(trail)</div><div class="line">    </div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> result = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>].headMirrorsTrail(<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<h2 id="Collection-Protocol"><a href="#Collection-Protocol" class="headerlink" title="Collection Protocol"></a>Collection Protocol</h2><p>   如上文所示Collection都是稳定的<code>Sequence</code>，它可以稳定的被屡次遍历，并且没有破坏。并且其元素可以使用脚标的形式被访问。Colllection的<code>Index</code>通常是<code>integer</code>，存在数组中，并且是有限的。也就是说不像<code>Sequence</code>，<code>Collection</code>必须是有限的。这也就是为啥其有<code>count</code>属性。<br>不仅仅标准库中的<code>Array</code>,<code>Set</code>,<code>Dictionary</code>,<code>CountableRange</code>以及<code>UnsafeBufferProinter</code>等等遵守<code>Collection</code>协议，Foundation库中的<code>Data</code>和<code>IndexSet</code>也遵守<code>Collection</code>协议。  </p>
<p>A Queue Implementation中对算法的解释不是很懂。</p>
<p>如果一个Type要遵守<code>Collection</code>协议，那么它需要满足以下要求：</p>
<ol>
<li>提供startIndex属性</li>
<li>提供endIndex属性</li>
<li>提供一个subscript，它至少是readonly的，用来获取Type的Element</li>
<li>index函数，来寻找Collection的Index</li>
</ol>
<p>由于Collection的协议的很多方法都有默认实现，所以我们在没有特殊处理的时候不需要再实现其他的方法，比如我们定义完Collection之后就可以使用<code>map</code>,<code>flatMap</code>,<code>filter</code>,<code>sorted</code>,<code>joined</code>等方法。<br>为了让我们定义的Collection使用字面量的形式来创建，我们需要实现<code>ExpressibleByArrayLiteral</code>协议，该协议只有一个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ExpressibleByArrayLiteral</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/// The type of the elements of an array literal.</span></div><div class="line">    associatedtype <span class="type">Element</span></div><div class="line">    <span class="comment">/// Creates an instance initialized with the given elements.</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(arrayLiteral elements: <span class="type">Self</span>.<span class="type">Element</span>...)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是在这个初始化方法里面调用自己的<code>Designated</code>初始化方法。</p>
<p>注：<br>   只要是遵守<code>ExpressibleByArrayLiteral</code>的Type都可以使用如<br> <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> queue:<span class="type">FIFOQueue</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div></pre></td></tr></table></figure></p>
<p> 这样的方式进行创建，至于创建的类型需要根据声明的类型以及上下文来推断，也就是说在利用[1,2,3,4]这样的方式进行初始化的时候，系统会自动的调用协议中规定的初始化方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="击水湘江" />
          <p class="site-author-name" itemprop="name">击水湘江</p>
           
              <p class="site-description motion-element" itemprop="description">努力让明天的自己爱上今天的自己！</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">击水湘江</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script>


  

</body>
</html>
