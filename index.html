<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Write the Code,Change the World" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:type" content="website">
<meta property="og:title" content="击水湘江">
<meta property="og:url" content="https://mikefighting.github.io/index.html">
<meta property="og:site_name" content="击水湘江">
<meta property="og:description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="击水湘江">
<meta name="twitter:description" content="努力让明天的自己爱上今天的自己！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://mikefighting.github.io/"/>





  <title>击水湘江 - Born To Fight!</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">击水湘江</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Born To Fight!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/09/06/google-the-clean-code-talks-inheritance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/06/google-the-clean-code-talks-inheritance/" itemprop="url">代码整洁之道-继承，多态和测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-06T07:50:00+08:00">
                2017-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="代码整洁的讨论，条件和多态"><a href="#代码整洁的讨论，条件和多态" class="headerlink" title="代码整洁的讨论，条件和多态"></a>代码整洁的讨论，条件和多态</h3><p><img src="http://upload-images.jianshu.io/upload_images/1513759-0ac66a6395d8b9ff.png" alt="Conclusion"></p>
<p>条件和多态是怎样影响测试的？</p>
<ol>
<li>大多数的if可以被多态所取代</li>
</ol>
<p>为什么要取代ifs</p>
<ol>
<li>没有if的代码更容易阅读</li>
<li>没有if的代码更容易测试</li>
<li>多态更容易维护：容易扩展</li>
</ol>
<p>什么时候使用多态：</p>
<ol>
<li>如果一个对象基于其不同的状态，而表现不一样</li>
<li>如果你要在不同的地方来检测这种条件</li>
</ol>
<p>对于基本数据类型，我们使用<code>&gt;,&lt;,==,!=</code>来做比较。我们要避免使用<code>if</code>。</p>
<p>尽量不适用if<br>不要返回null（使用null之后不能够Dispatch这个错误）,而是返回一个Null对象，比如一个空的list<br>不要返回error代码，而是抛出异常</p>
<h3 id="尽量少用继承"><a href="#尽量少用继承" class="headerlink" title="尽量少用继承"></a>尽量少用继承</h3><p>多态需要使用继承<br>小心继承的层级太深</p>
<h3 id="将条件用多态替代"><a href="#将条件用多态替代" class="headerlink" title="将条件用多态替代"></a>将条件用多态替代</h3><p>你有一个条件，该条件是基于某个对象的类型来选择不同的行为。</p>
<p>将这些条件的判断一到一个子类的覆盖方法中。然后将原来的的方变成一个抽象方法。<br>我们用下面的例子：</p>
<pre><code class="java"><span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>{

  <span class="keyword">switch</span> (_type) {

   <span class="keyword">case</span> ENROPEAN:
        <span class="keyword">return</span> getBaseSpeed();

   <span class="keyword">case</span> AFRICAN:
        <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() * _numberOfCoconuts;

   <span class="keyword">case</span> NORWEGIAN_BLUE:
        <span class="keyword">return</span> (_isNailed) ? <span class="number">0</span> : getBaseSpeed(_voltage);
  }

  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Should be unreachable"</span>);
}
</code></pre>
<p>比如我们有一个<code>1+ 2 * 3</code>的表达式，如果用树来表示应该是这样的： </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-44f337f613e5c3f2.png" alt="1 + 2 * 3"></p>
<p>这时候大多情况下我们会写下面的的代码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-4efa0dbac30dd19d.png" alt="Implement"></p>
<p>那么大多数情况下会出问题，比如：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-3ee95ff9e5c8dd78.png" alt="Evaluate UML"></p>
<p>从中我们可以看到叶子节点的左右分支都是null，上文已经提到null是很不好的。比如叶子节点我们需要的只是数值，没有function，没有left和right数值。</p>
<p>那么怎么办呢？我们需要将原来的Node创建两个子类，一个ValueNode，一个OpNode。UML图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-e32bbbf0adf5e116.png" alt="SubClass UML"></p>
<p>创建子类之后：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-92adea90f4f9f44d.png" alt="Node Subclass"></p>
<p>Java只针对某个类编译。</p>
<p>这样最终我们的UML图是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-d12731bff0df6db3.png" alt="ValueNode"></p>
<p>用多态替代switch case。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-8e09c9eb66adc448.png" alt="多态UML"></p>
<p>然后系统的操作类变为：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-f3b681a924bba620.png" alt="Operation Class"></p>
<p>然后我们再创建两个<code>OpNode</code>的子类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-d6699abc050608e6.png" alt="OpNodeSubClass"></p>
<p>然后我们有了除去Operation字段的UML图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-1ebf2e28e6c0c310.png" alt="NoOperationUML"></p>
<h2 id="进一步探讨"><a href="#进一步探讨" class="headerlink" title="进一步探讨"></a>进一步探讨</h2><p>定义一个<code>toString()</code>方法来打印表达式的前缀，并且在适当的时候加上括号。<br>添加一些新的数学操作：添加方程，阶乘，算法，三角学。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> 多态的结局方案通常来说是更好的，因为；</p>
<ul>
<li>新功能的添加不需要改动原来的代码</li>
<li>每个操都被放到一个单独的文件中了，这样易于测试和理解，并且易于扩展</li>
</ul>
<p>多用多态而不是条件语句：</p>
<ul>
<li><strong>switch</strong>语句就意味着你应该使用多态</li>
<li><strong>if</strong>更加很精妙，但是有时候一个<strong>if</strong>仅仅是一个<strong>if</strong></li>
</ul>
<h3 id="重复条件"><a href="#重复条件" class="headerlink" title="重复条件"></a>重复条件</h3><pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">Update</span> </span>{
    execute (){
    <span class="keyword">if</span> (FLAG_i18n_ENABLED) {

       <span class="comment">// DO A;</span>
    }<span class="keyword">else</span> {
       <span class="comment">// DO B;</span>
     }
   }
}
</code></pre>
<p>但是后来又有了相似的代码：</p>
<pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">Update</span> </span>{
   render (){
    <span class="keyword">if</span> (FLAG_i18n_ENABLED) {

       <span class="comment">// Render A;</span>
    }<span class="keyword">else</span> {
       <span class="comment">// Render B;</span>
     }
   }
}
</code></pre>
<p>在测试的时候，我们还需要写两套代码，比如：</p>
<pre><code class="java"><span class="keyword">void</span> testExecuteDoA {
    FLAG_i18n_ENABLED = <span class="keyword">true</span>;
    Update u = <span class="keyword">new</span> Update();
    u.execute();
    assertX();
}
<span class="keyword">void</span> testExecuteDoB {
  FLAG_i18n_ENABLED = <span class="keyword">false</span>;
  Update u = <span class="keyword">new</span> Update();
  u.execute();
  assertX();
}
</code></pre>
<p>应该怎样做才好呢？我们应该经条件语句用多态来替代：</p>
<p><em>你有一种条件，这种条件会基于某个对象的类型类选择不同的行为。</em><br>将判断条件一到一个子类的覆盖方法中。将原来类的方法变成抽象方法。</p>
<pre><code class="java">
<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Update</span> </span>{
 <span class="comment">//...</span>
}

<span class="class"><span class="keyword">class</span> <span class="title">I18NUpdate</span> <span class="keyword">extends</span> <span class="title">Update</span> </span>{
   execute() {
    <span class="comment">// Do A;</span>
   }
   render() {
   <span class="comment">// Render A;</span>
   }
}

<span class="class"><span class="keyword">class</span> <span class="title">NoNI18NUpdate</span> <span class="keyword">extends</span> <span class="title">Update</span> </span>{
  execute() {
   <span class="comment">// Do B;</span>
  }
  render() {
   <span class="comment">// Render A;</span>
  }
}
</code></pre>
<p>测试的时候我们就方便多了：</p>
<pre><code class="java"><span class="keyword">void</span> testExecuteDoA {
   Update u = <span class="keyword">new</span> MyI18NUpdate();
   u.execute();
   assertX();
}

<span class="keyword">void</span> testExecuteDoB {
   Update u = <span class="keyword">new</span> MyNonI18NUpdate();
   u.execute();
   assertX();
}
</code></pre>
<p><strong>if</strong>s去哪里了？</p>
<pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>{
  Consumer(Update u){...}
}
</code></pre>
<p>两种方式：</p>
<p>第一种方式：</p>
<p>对象的堆砌</p>
<ul>
<li>业务逻辑</li>
<li>有趣的东西</li>
<li>目的是建造逻辑，主要的抽象</li>
<li>假如需要很多的合作者</li>
</ul>
<p>第二种方式：</p>
<p>构造方法的堆砌</p>
<ul>
<li>工厂</li>
<li>建造者</li>
<li>Provier<t></t></li>
<li>目的是建造对象表</li>
<li>创建和提供合作者（依赖注入）</li>
</ul>
<p>将创建某个具体对象的操作放到工厂方法中去性能会更高，因为我们只需要判断一次就可以对这个对象做一系列的操作。而之前，我们需要尽心一系列的判断。将If else放到工厂中还有一个好处就是便于测试和调试Bug，因为尽管我们有if else，但是这是在创建对象的过程中，具体的业务逻辑我们是放到了子类中去做的，而经常出错的地方往往是业务逻辑，而不是创建对象的过程。举个例子：</p>
<pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>{
  Consumer(Update u){...}
}

<span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>{
  <span class="function">Consumer <span class="title">build</span><span class="params">()</span> </span>{
    Update u = FLAG_i18n_ENABLED ? <span class="keyword">new</span> I18NUpdate()
                                 : <span class="keyword">new</span> NonI18NUpdate();
    <span class="keyword">return</span> <span class="keyword">new</span> Consumer(u);
  }
}
</code></pre>
<p>使用依赖注入：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-d44fe1f5cbe6fe8f.png" alt="Injection"></p>
<p>这样做的好处是：</p>
<ol>
<li>所有的判断条件都被放到了一个地方</li>
<li>没有很多的重复代码</li>
<li>将责任分离，将全局状态分离</li>
</ol>
<h2 id="总结优势"><a href="#总结优势" class="headerlink" title="总结优势"></a>总结优势</h2><ol>
<li>公用代码放到了一个地方</li>
<li>很容易独立测试和平行测试</li>
<li>关注子类让它更加明白不同点在哪里</li>
</ol>
<p>什么时候用继承？</p>
<p>不同的状态产生不同的行为<br>不同的地方有平行的条件</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/09/05/chat-if-else/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/05/chat-if-else/" itemprop="url">聊聊if else</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-05T07:04:01+08:00">
                2017-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>if else 是我们学习C语言开始用的流程控制语句。还记得大学老师说过一句话，任何复杂的业务逻辑都可以用if else去解决。然而就像面向对象中的继承一样，如果用的过多就会造成代码的腐烂。下面我们就来聊聊if else。</p>
<h3 id="为什么太多的if-else不好？"><a href="#为什么太多的if-else不好？" class="headerlink" title="为什么太多的if else不好？"></a>为什么太多的if else不好？</h3><p>我们先看一个例子：</p>
<pre><code class="swift">   @<span class="type">Synchronized</span> fun findSubscribeMethods(subscriber: <span class="type">Any</span>) {
    <span class="keyword">var</span> clazz: <span class="type">Class</span>&lt;*&gt;? = subscriber.swiftClass
    <span class="keyword">while</span> (clazz != null &amp;&amp; !isSystemClass(clazz.name)) {
        val allMethods = clazz.declaredMethods
        <span class="keyword">for</span> (method <span class="keyword">in</span> allMethods) {
            val annotation = method.getAnnotation(<span class="type">Subscriber</span>::<span class="class"><span class="keyword">class</span>.<span class="title">swift</span>)
            <span class="title">if</span> (<span class="title">annotation</span> != <span class="title">null</span>) </span>{
                <span class="comment">// 获取方法参数</span>
                val paramsTypeClass = method.parameterTypes
                <span class="comment">// 订阅函数只支持一个参数</span>
                <span class="keyword">if</span> (paramsTypeClass != null &amp;&amp; paramsTypeClass.size == <span class="number">1</span>) {
                    val paramsEvent = paramsTypeClass[<span class="number">0</span>]
                    <span class="keyword">if</span> (isImplementIEvent(paramsEvent)) {
                        method.isAccessible = <span class="literal">true</span>
                        @<span class="type">Suppress</span>(<span class="string">"UNCHECKED_CAST"</span>)
                        val eventType = <span class="type">EventType</span>(paramsEvent <span class="keyword">as</span> <span class="type">Class</span>&lt;<span class="type">IEvent</span>&gt;, annotation.tag)
                        val subscription = <span class="type">Subscription</span>(<span class="type">WeakReference</span>(subscriber), method, annotation.mode)
                        subscribe(eventType, subscription)
                    }
                }
            }
        }
        clazz = clazz.superclass
    }
}
</code></pre>
<p>这个方法里面仅仅嵌套了三层if。但是一眼看过去就会感觉很不爽，再看一个例子：</p>
<pre><code class="swift"><span class="keyword">if</span>(isSkipPPUForQA &amp;&amp; <span class="type">StringUtils</span>.isNotBlank(request.getParameter(<span class="string">"userId"</span>))){
    <span class="keyword">super</span>.doFilter(request, response, chain);
}<span class="keyword">else</span> {
    <span class="keyword">try</span> {
        <span class="keyword">if</span>(<span class="string">"/app/school/article/share"</span>.equals(request.getRequestURI())){
            <span class="keyword">super</span>.doFilter(request, response, chain);
        }<span class="keyword">else</span>{
            <span class="keyword">if</span>(!filterReqUrl(request)) {
                long ppuUserId = <span class="type">PassportService</span>.passportService.getLoginUserId(<span class="type">RemoteValid</span>.<span class="type">SAPCE_ONE_HOUR</span>, request, response);
                <span class="keyword">if</span> (ppuUserId &lt; <span class="number">2</span>) {
                    response.getWriter().write(this.generateResponse(<span class="type">AppResultStateEnum</span>.<span class="type">PPU_UNVALID</span>.getCodeStr(), <span class="string">"登录认证信息已过期，请重新登录"</span>));
                    log.error(<span class="string">"ppu返回的userId:"</span> + ppuUserId + <span class="string">",ppu过期,ppu="</span> + <span class="type">PPUCookieUtil</span>.getPpuCookie(request) + <span class="string">",url="</span> + request.getRequestURI());
                    log.error(<span class="string">"imei="</span> + request.getParameter(<span class="string">"imei"</span>) + <span class="string">",version="</span> + request.getParameter(<span class="string">"version"</span>) + <span class="string">",platform="</span> + request.getParameter(<span class="string">"platform"</span>));
                } <span class="keyword">else</span> {
                    boolean flag = isTouchSingleDeviceLimitWithoutLogin(ppuUserId, request);
                    <span class="keyword">if</span> (flag) {
                        <span class="type">String</span> singleDeviceLoginContent = configComp.getValueByConfigTable(<span class="type">ConfigEnum</span>.<span class="type">APP_SINGLE_DEVICE_LOGIN_CONTENT</span>);
                        boolean isH5 = <span class="string">"1"</span>.equals(request.getParameter(<span class="string">"isH5"</span>));
                        <span class="keyword">if</span>(isH5){
                            <span class="type">String</span> jsAjaxHeader = request.getHeader(<span class="string">"X-Requested-With"</span>);
                            <span class="keyword">if</span>(<span class="string">"XMLHttpRequest"</span>.equals(jsAjaxHeader)){response.getWriter().write(this.generateResponse(<span class="type">AppResultStateEnum</span>.<span class="type">SINGLE_DEVICE_LOGIN</span>.getCodeStr(), singleDeviceLoginContent));
                            }<span class="keyword">else</span> {
                             renderSingleDeviceHtml(response,<span class="string">"/single_device_error"</span>);
                            }
                        }<span class="keyword">else</span> {
                            response.getWriter().write(this.generateResponse(<span class="type">AppResultStateEnum</span>.<span class="type">SINGLE_DEVICE_LOGIN</span>.getCodeStr(), singleDeviceLoginContent));
                        }
                        log.error(<span class="string">"触发单设备登录限制,userId="</span> + ppuUserId + <span class="string">" , imei="</span> + request.getParameter(<span class="string">"imei"</span>) + <span class="string">" , platform="</span> + request.getParameter(<span class="string">"platform"</span>));
                    } <span class="keyword">else</span> {
                        request.addParameter(<span class="string">"userId"</span>, new <span class="type">String</span>[]{ppuUserId + <span class="string">""</span>});
                        <span class="keyword">super</span>.doFilter(request, response, chain);
                    }
                }
            }
        }
    } <span class="keyword">catch</span> (<span class="type">Exception</span> e) {
        logger.error(<span class="string">"业务处理异常,url="</span>+request.getRequestURI(),e);
    }
}
</code></pre>
<p>第一，这个方法中嵌套了七层的if else，层次太多。第二这个方法太长。嵌套层次过多和方法过长都是Bad Smell。那么究竟很多的if else有哪些弊端呢？</p>
<ul>
<li><p><strong>僵化</strong>：如果再有更多情况的时候，我们需要在原来的地方写更多的if…else if条件。也就是说你需要去改动原来的代码，然后重新编译，重新部署，这是很浪费时间的。并且这违背了面向对象中的<strong>开放封闭原则</strong>：对扩展开放，对修改封闭。同时由于这个类需要处理各种业务，职责太多，所以也违背了<strong>职责单一原则。</strong></p>
</li>
<li><p><strong>效率低下</strong>：很多系统的类，比如<code>HashMaps</code>，<code>Properties</code>等，都非常注意基于数据的条件判断。</p>
</li>
<li><p><strong>难阅读</strong>：像这种层层if else嵌套的情况，如果其他人需要来看，并且维护这份代码，由于难阅读，他们会感觉吃力。试想下，如果段代码很长，一个屏看不完，那肯定是维护的灾难。</p>
</li>
<li><p><strong>难维护</strong>：if else不像switch case，它的每个分支都和其它分支有关系，如果需求变更，在修改某个分支之前要看懂其它所有分支，确保不会对其它分支造成影响。</p>
</li>
<li><p><strong>难调试</strong>：很多if else，调试过程中需要一步步跟进，会影响调试效率。</p>
</li>
<li><p><strong>难测试</strong>：每次我们写测试用例的Case，针对每个有很多if else的方法，我们要对每个分支都写一个测试，这样下来这个测试用例将会变得非常长。</p>
</li>
</ul>
<blockquote>
<p>在任何面向对象语言中，都需要考虑移除分支控制逻辑（<code>if</code>以及<code>switch</code>，<code>case</code>）。移除的常用做法是将这些控制逻辑的方法移到一个类中。 <a href="https://www.quora.com/Why-should-Java-programmers-try-to-avoid-if-statements" target="_blank" rel="external">Quora,Simon Hayes</a></p>
</blockquote>
<p>那么我们怎样来解决这种情况，因为遇到不同的情况需要用不同的解决方案，我们逐个来分析：</p>
<h2 id="平行类的if-else处理方式–命令模式"><a href="#平行类的if-else处理方式–命令模式" class="headerlink" title="平行类的if else处理方式–命令模式"></a>平行类的if else处理方式–命令模式</h2><p><strong>如果我们有几个判断条件是平级if，那么我们可以使用命令模式来解决这种问题。</strong>比如我们现在有如下的if else：</p>
<pre><code class="swift"><span class="keyword">if</span> (value.equals(<span class="string">"A"</span>)) { doCommandA() }
<span class="keyword">else</span> <span class="keyword">if</span> (value.equals(<span class="string">"B"</span>)) { doCommandB() } 
<span class="keyword">else</span> <span class="keyword">if</span> etc.
</code></pre>
<p>我们可以使用命令模式来解决，先创建一个接口：</p>
<pre><code class="swift"><span class="keyword">public</span> interface <span class="type">Command</span> {
     void exec();
}
</code></pre>
<p>然后<code>CommandA</code>和<code>CommandB</code>类实现这个接口：</p>
<pre><code class="swift"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandA</span>() <span class="title">implements</span> <span class="title">Command</span> </span>{

     void exec() {
          <span class="comment">// ... </span>
     }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandB</span>() <span class="title">implements</span> <span class="title">Command</span> </span>{

     void exec() {
          <span class="comment">// ...</span>
     }
}
</code></pre>
<p>然后创建一个<code>Map&lt;String,Command&gt;</code>,并且往其中添加Command实例：</p>
<pre><code class="swift">commandMap.put(<span class="string">"A"</span>, new <span class="type">CommandA</span>());
commandMap.put(<span class="string">"B"</span>, new <span class="type">CommandB</span>());
</code></pre>
<p>然后所有的<strong>if/else if</strong>，就都会变成：</p>
<pre><code class="swift">commandMap.<span class="keyword">get</span>(value).exec();
</code></pre>
<p>如果某个Command有任何的改变只需要改动某个具体的类即可，如果有新加的Command，那么只需要添加响应的Command即可。如果不知道这是命令模式，请参考相关资料。</p>
<h2 id="处理方式相似的if-else解决方式–策略模式"><a href="#处理方式相似的if-else解决方式–策略模式" class="headerlink" title="处理方式相似的if else解决方式–策略模式"></a>处理方式相似的if else解决方式–策略模式</h2><p>如果我们if之后的代码格式是一样的，比如：</p>
<pre><code class="swift"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfElseDemo</span> </span>{
    <span class="keyword">public</span> double calculateInsurance(double income) {
        <span class="keyword">if</span> (income &lt;= <span class="number">10000</span>) {
            <span class="keyword">return</span> income*<span class="number">0.365</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (income &lt;= <span class="number">30000</span>) {
            <span class="keyword">return</span> (income-<span class="number">10000</span>)*<span class="number">0.2</span>+<span class="number">35600</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (income &lt;= <span class="number">60000</span>) {
            <span class="keyword">return</span> (income-<span class="number">30000</span>)*<span class="number">0.1</span>+<span class="number">76500</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> (income-<span class="number">60000</span>)*<span class="number">0.02</span>+<span class="number">105600</span>;
        }

    }
}
</code></pre>
<p>那么我们就可以将每个if分支中的代码单独分离到各个类中，然后再抽出一个父类，这样我们每个条件分支中就不会有很多代码了：</p>
<pre><code class="swift"><span class="keyword">public</span> abstract <span class="class"><span class="keyword">class</span> <span class="title">InsuranceStrategy</span> </span>{
    <span class="keyword">public</span> double calculateInsuranceVeryHigh(double income) {
        <span class="keyword">return</span> (income - getAdjustment()) * getWeight() + getConstant();
    }

    <span class="keyword">public</span> abstract int getConstant();
    <span class="keyword">public</span> abstract double getWeight();
    <span class="keyword">public</span> abstract int getAdjustment();
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsuranceStrategyMedium</span> <span class="title">extends</span> <span class="title">InsuranceStrategy</span> </span>{
    @<span class="type">Override</span>
    <span class="keyword">public</span> int getConstant() {
        <span class="keyword">return</span> <span class="number">35600</span>;
    }

    @<span class="type">Override</span>
    <span class="keyword">public</span> double getWeight() {
        <span class="keyword">return</span> <span class="number">0.2</span>;
    }

    @<span class="type">Override</span>
    <span class="keyword">public</span> int getAdjustment() {
        <span class="keyword">return</span> <span class="number">10000</span>;
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">IfElseDemo</span> </span>{
    <span class="keyword">private</span> <span class="type">InsuranceStrategy</span> strategy;
    <span class="keyword">public</span> double calculateInsurance(double income) {
        <span class="keyword">if</span> (income &lt;= <span class="number">10000</span>) {
            strategy = new <span class="type">InsuranceStrategyLow</span>();
            <span class="keyword">return</span> strategy.calculate(income);
        } <span class="keyword">else</span> <span class="keyword">if</span> (income &lt;= <span class="number">30000</span>) {
            strategy = new <span class="type">InsuranceStrategyMedium</span>();
            <span class="keyword">return</span> strategy.calculate(income);
        } <span class="keyword">else</span> <span class="keyword">if</span> (income &lt;= <span class="number">60000</span>) {
            strategy = new <span class="type">InsuranceStrategyHigh</span>();
            <span class="keyword">return</span> strategy.calculate(income);
        } <span class="keyword">else</span> {
            strategy = new <span class="type">InsuranceStrategyVeryHigh</span>();
            <span class="keyword">return</span> strategy.calculate(income);
        }
    }
}
</code></pre>
<h2 id="区间类的if-else解决方案–责任链模式"><a href="#区间类的if-else解决方案–责任链模式" class="headerlink" title="区间类的if else解决方案–责任链模式"></a>区间类的if else解决方案–责任链模式</h2><p>如果客户端的if条件中表示的是范围，比如：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{

    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>{

        Request request = <span class="keyword">new</span> Request();
        request.addSalaryAmount = <span class="number">9999</span>;
        <span class="keyword">if</span> (request.addSalaryAmount &lt;= <span class="number">100</span>){
            DivisionManager divisionManager = <span class="keyword">new</span> DivisionManager();
            divisionManager.accept();
        }<span class="keyword">else</span> <span class="keyword">if</span> (request.addSalaryAmount &lt;= <span class="number">1000</span>){
            Chief chief = <span class="keyword">new</span> Chief();
            chief.accept();
        }<span class="keyword">else</span> <span class="keyword">if</span> (request.addSalaryAmount &lt;= <span class="number">10000</span>){
            GeneralManager generalManager  = <span class="keyword">new</span> GeneralManager();
            generalManager.accept();
        }<span class="keyword">else</span> {
            System.out.println(<span class="string">"金额太大没人能批准"</span>);
        }
    }
}
</code></pre>
<p>比如上面这个例子，不同的条件分支是让不同的对象来处理这种条件。并且以后可能Request对象会添加其他的请求属性，比如offWork（请假），并且这种请求属性同样需要<code>DivisionManager</code>，<code>Chief</code>，<code>GeneralManager</code>。然而其中的处理顺序变了，并不是现在的请求等级。可能是先由<code>Chief</code>处理，再有<code>GeneralManager</code>处理，最后有<code>DivisionManager</code>来处理，那怎么办呢？难道还要写一套if else吗？<br>这时候我们就可以用责任链模式来将这一长串if else嵌套进每一个对象中去，我们可以这样做：</p>
<pre><code class="java"><span class="class"><span class="keyword">interface</span> <span class="title">ManagerCommand</span></span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> requestAmount)</span></span>;
}

<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommManager</span> <span class="keyword">implements</span> <span class="title">ManagerCommand</span> </span>{
    <span class="keyword">public</span> CommManager superior;
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuperior</span><span class="params">(CommManager superior)</span> </span>{
        <span class="keyword">this</span>.superior = superior;
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivisionManager</span> <span class="keyword">extends</span> <span class="title">CommManager</span> </span>{

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> requestAmount)</span> </span>{

        <span class="keyword">if</span> (requestAmount&lt;<span class="number">100</span>){

            System.out.println(<span class="string">"部门经理批准"</span>);

        }<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">this</span>.superior != <span class="keyword">null</span>){

            <span class="keyword">this</span>.superior.accept(requestAmount);
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chief</span> <span class="keyword">extends</span> <span class="title">CommManager</span></span>{


    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">accept</span><span class="params">(<span class="keyword">int</span> requestAmount)</span>  </span>{

        <span class="keyword">if</span> (requestAmount &lt; <span class="number">1000</span>){
        System.out.println(<span class="string">"总监同意"</span>);
        }<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.superior != <span class="keyword">null</span>){

            <span class="keyword">this</span>.superior.accept(requestAmount);
        }
    }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralManager</span> <span class="keyword">extends</span> <span class="title">CommManager</span></span>{

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> requestAmount)</span> </span>{

        <span class="keyword">if</span> (requestAmount&lt;<span class="number">10000</span>){
            System.out.println(<span class="string">"总经理批准"</span>);

        }<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.superior != <span class="keyword">null</span>){

            <span class="keyword">this</span>.superior.accept(requestAmount);
        }
    }
}
</code></pre>
<p>最后在Client端调用的时候，我们可以这样写：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{

    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>{

        Request request = <span class="keyword">new</span> Request();
        request.addSalaryAmount = <span class="number">999</span>;
        DivisionManager divisionManager = <span class="keyword">new</span> DivisionManager();
        Chief chief = <span class="keyword">new</span> Chief();
        GeneralManager generalManager = <span class="keyword">new</span> GeneralManager();
        divisionManager.setSuperior(chief);
        chief.setSuperior(generalManager);
        divisionManager.accept(request.addSalaryAmount);
    }
}
</code></pre>
<p>这种写法的好处是：<strong>将条件和处理某种条件的对象解耦，每个处理条件的对象都不知道其他对象，我们可以随时地增加或者修改处理一个请求的结构。这增加了给对象指派职责的灵活性</strong>。</p>
<blockquote>
<p>小结：其实上述的每种方式都是利用<strong>多态</strong>来解决分支带来的僵化，<a href="https://www.youtube.com/watch?v=4F72VULWFvc" target="_blank" rel="external">谷歌有一个视频对这个问题阐述的非常好</a>。</p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://stackoverflow.com/questions/10175805/how-to-avoid-a-lot-of-if-else-conditions" target="_blank" rel="external">https://stackoverflow.com/questions/10175805/how-to-avoid-a-lot-of-if-else-conditions</a></li>
<li><a href="https://stackoverflow.com/questions/271526/avoiding-null-statements?rq=1" target="_blank" rel="external">https://stackoverflow.com/questions/271526/avoiding-null-statements?rq=1</a></li>
<li><a href="https://stackoverflow.com/questions/14136721/converting-many-if-else-statements-to-a-cleaner-approach" target="_blank" rel="external">https://stackoverflow.com/questions/14136721/converting-many-if-else-statements-to-a-cleaner-approach</a></li>
<li><a href="https://www.youtube.com/watch?v=4F72VULWFvc" target="_blank" rel="external">https://www.youtube.com/watch?v=4F72VULWFvc</a></li>
<li><a href="https://www.quora.com/Why-should-Java-programmers-try-to-avoid-if-statements" target="_blank" rel="external">https://www.quora.com/Why-should-Java-programmers-try-to-avoid-if-statements</a></li>
<li><a href="https://stackoverflow.com/questions/1199646/long-list-of-if-statements-in-swift/1199677#1199677" target="_blank" rel="external">https://stackoverflow.com/questions/1199646/long-list-of-if-statements-in-swift/1199677#1199677</a></li>
<li><a href="https://industriallogic.com/xp/refactoring/conditionalWithStrategy.html" target="_blank" rel="external">https://industriallogic.com/xp/refactoring/conditionalWithStrategy.html</a></li>
<li>大话设计模式</li>
<li>重构改善既有代码的设计</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/09/04/wwdc-understand-foundation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/04/wwdc-understand-foundation/" itemprop="url">理解Foundation框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-04T10:13:00+08:00">
                2017-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文源于对WWDC：UnderStanding Foundation的总结。</p>
<h2 id="什么是Foundation"><a href="#什么是Foundation" class="headerlink" title="什么是Foundation?"></a>什么是Foundation?</h2><ul>
<li>Foundation提供了构建基础类的框架<ul>
<li>所有应用都是用的基础类型</li>
<li>它们供软件的更高层来组合使用</li>
</ul>
</li>
</ul>
<h2 id="Dictionry"><a href="#Dictionry" class="headerlink" title="Dictionry"></a>Dictionry</h2><p>Dictionary中提供了<code>objectEnumerator</code>和<code>keyEnumerator</code>两个方法，可以直接取到<code>key</code>或者<code>value</code>的Enumerator，然后就直接可以用while循环了。</p>
<pre><code class="objc"><span class="built_in">NSEnumerator</span> *e = [dictionary keyEnumerator];

<span class="keyword">while</span>(<span class="keyword">id</span> key = [e nextObject]){

 <span class="keyword">id</span> value = [e objectForKey:key];
 ....
}
</code></pre>
<h3 id="Fast-Enumeration"><a href="#Fast-Enumeration" class="headerlink" title="Fast Enumeration"></a>Fast Enumeration</h3><p>如果想获取某个Dictionary中的key，那么直接用Fast Enumeration就可以：</p>
<pre><code class="objc"><span class="built_in">NSDictionary</span> *someDic = @{<span class="string">@"key"</span>:<span class="string">@"value"</span>};
<span class="keyword">for</span> (<span class="keyword">id</span> key <span class="keyword">in</span> someDic) {

    <span class="built_in">NSLog</span>(<span class="string">@"key:%@"</span>,key);   
}
</code></pre>
<p>如果想要获取Key及其对应的Value，那么直接是用Block就可以：</p>
<pre><code class="objc">[someDic enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull obj, <span class="built_in">BOOL</span> * _Nonnull stop) {

}];
</code></pre>
<h3 id="NSArray排序"><a href="#NSArray排序" class="headerlink" title="NSArray排序"></a>NSArray排序</h3><p>对一个NSArray进行排序，有以下几种方法：</p>
<ol>
<li>C function</li>
<li>Objective-C method</li>
<li>NSSortDescriptor</li>
<li>Blocks</li>
</ol>
<p>使用Bock遍历数组的方法：</p>
<pre><code class="objc"><span class="built_in">NSMutableArray</span> *names = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"11"</span>,<span class="string">@"22"</span>, <span class="literal">nil</span>];
    [names sortUsingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span>  _Nonnull obj1, <span class="keyword">id</span>  _Nonnull obj2) {
        <span class="built_in">NSComparisonResult</span> result;
        <span class="built_in">NSUInteger</span> lLen = [obj1 length], rLen = [obj2 length];

        <span class="keyword">if</span> (lLen &lt; rLen) {
            result = <span class="built_in">NSOrderedAscending</span>;
        }<span class="keyword">else</span> <span class="keyword">if</span> (lLen &gt; rLen){   
            result = <span class="built_in">NSOrderedDescending</span>;
        }<span class="keyword">else</span>{
            result = <span class="built_in">NSOrderedSame</span>;
        }        
        <span class="keyword">return</span> result;
    }];
</code></pre>
<h3 id="Collection的过滤"><a href="#Collection的过滤" class="headerlink" title="Collection的过滤"></a>Collection的过滤</h3><p><strong>遍历一个Collection的同时再改变它，会引发异常。</strong><br>Collection的过滤步骤：</p>
<ol>
<li>将要筛选的Collection改为可变类型的</li>
<li>筛选出需要移除的项</li>
<li>调用可变类型的响应方法进行移除</li>
</ol>
<pre><code class="objc"><span class="built_in">NSMutableArray</span> *files = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"file0"</span>,<span class="string">@"file1"</span>, <span class="literal">nil</span>]; <span class="comment">// array of NSString objcects;</span>
<span class="built_in">NSIndexSet</span> *toRemove = [files indexesOfObjectsPassingTest:^<span class="built_in">BOOL</span>(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) {

    <span class="keyword">if</span> ([obj hasPrefix:<span class="string">@"."</span>]) {<span class="keyword">return</span> <span class="literal">YES</span>;}
    <span class="keyword">return</span> <span class="literal">NO</span>;

}];
[files removeObjectsAtIndexes:toRemove];
</code></pre>
<h3 id="Collection更多的特性"><a href="#Collection更多的特性" class="headerlink" title="Collection更多的特性"></a>Collection更多的特性</h3><ul>
<li>查找</li>
<li>对每个元素都调用某个方法</li>
<li><code>NSArray</code>：切开和串联</li>
<li>NSSet：交集，合并和子集</li>
</ul>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p>String其实是一个Unicode字符集的数组，你可以将它看做非透明的容器。对它的常用方法有：</p>
<ul>
<li>比较</li>
<li>查找</li>
<li>转换编码</li>
</ul>
<h3 id="字符串比较的方法："><a href="#字符串比较的方法：" class="headerlink" title="字符串比较的方法："></a>字符串比较的方法：</h3><pre><code class="objc">- (<span class="built_in">NSComparisonResult</span>)compare:(<span class="built_in">NSString</span> *)string; <span class="comment">// 1</span>
- (<span class="built_in">NSComparisonResult</span>)localizedStandardCompare:(<span class="built_in">NSString</span> *)string <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0); <span class="comment">// 2</span>
- (<span class="built_in">NSComparisonResult</span>)localizedCompare:(<span class="built_in">NSString</span> *)string; <span class="comment">// 3</span>
- (<span class="built_in">NSComparisonResult</span>)localizedCaseInsensitiveCompare:(<span class="built_in">NSString</span> *)string; <span class="comment">// 4</span>
- (<span class="built_in">NSComparisonResult</span>)compare:(<span class="built_in">NSString</span> *)string options: (<span class="built_in">NSStringCompareOptions</span>)mask range:(<span class="built_in">NSRange</span>)rangeOfReceiverToCompare locale:(<span class="keyword">nullable</span> <span class="keyword">id</span>)locale; <span class="comment">// 5</span>
</code></pre>
<p>第二个方法和第三个方法是对那些做了本地化的字符串进行比对。第四个可以对字符串的一部分进行比较，并且可以指定是否是大小写敏感等。如果数组中有字符串需要排序，那么我们可以用到上文中提到的，让数组中的元素分别调用其自身的方法。</p>
<pre><code class="objc"><span class="built_in">NSArray</span> *strings = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Larry"</span>,<span class="string">@"Curly"</span>,<span class="string">@"Moe"</span>, <span class="literal">nil</span>];
<span class="built_in">NSArray</span> *sortedArray = [strings sortedArrayUsingSelector:<span class="keyword">@selector</span>(localizedCompare:)];
</code></pre>
<h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><p>字符串查找的方法如下：</p>
<pre><code class="objc">- (<span class="built_in">NSRange</span>)rangeOfString:(<span class="built_in">NSString</span> *)searchString;
- (<span class="built_in">NSRange</span>)rangeOfString:(<span class="built_in">NSString</span> *)searchString options:(<span class="built_in">NSStringCompareOptions</span>)mask range:(<span class="built_in">NSRange</span>)rangeOfReceiverToSearch locale:(<span class="keyword">nullable</span> <span class="built_in">NSLocale</span> *)locale <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);
</code></pre>
<p>*注：如果有特殊字符，比如<code>Ó</code>，那么它在数组中是<code>O</code>，<code>´</code>两个分开存储，是占两个存储单位的，所以它自身rang的length是2。</p>
<p>字符串的查找中还支持正则表达式：</p>
<pre><code class="objc"><span class="built_in">NSString</span> *str = <span class="string">@"Going going gone!"</span>;
<span class="built_in">NSRange</span> found = [str rangeOfString:<span class="string">@"go(\\w*)"</span>
                           options:<span class="built_in">NSRegularExpressionSearch</span>
                             range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, str.length)];
</code></pre>
<p>这样我们就可以得到found的值：found.location = 6, found.length = 5;</p>
<h3 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h3><p>字符串和Data之间编码的相互转换：</p>
<pre><code class="objc"><span class="built_in">NSData</span> *someData = [<span class="built_in">NSData</span> dataWithContentsOfFile:<span class="string">@""</span>];
<span class="built_in">NSString</span> *inString = [[<span class="built_in">NSString</span> alloc]initWithData:someData encoding:<span class="built_in">NSUTF8StringEncoding</span>];
<span class="built_in">NSString</span> *outString = <span class="string">@"For Windows"</span>;
<span class="built_in">NSData</span> *converted = [outString dataUsingEncoding:<span class="built_in">NSUTF16StringEncoding</span>];
</code></pre>
<p>如果要将某个和文件系统相独立的字符串表示成文件系统调用时所指定的字符串表示，可以使用：</p>
<pre><code class="objc"><span class="keyword">const</span> <span class="keyword">char</span> *fileName = [outString fileSystemRepresentation];
</code></pre>
<p>将它表示成一个C类型的字符串，这个字符串在outString销毁的时候也跟着自动销毁。</p>
<p>更多的特性：</p>
<ul>
<li>打印格式</li>
<li>遍历逐个子字符串遍历，逐行遍历，逐段遍历</li>
<li>替换某个子字符串</li>
<li>路径补全</li>
</ul>
<h3 id="NSDateFormatter："><a href="#NSDateFormatter：" class="headerlink" title="NSDateFormatter："></a>NSDateFormatter：</h3><p>如果不想将一个<code>NSDate</code>转换成字符串的时候出现时间，那么可以将<code>timeStyle</code>设置为：<code>NSDateFormatterNoStyle</code>。</p>
<pre><code class="objc"><span class="built_in">NSDateFormatter</span> *fmt = [[<span class="built_in">NSDateFormatter</span> alloc]init];
[fmt setTimeStyle:<span class="built_in">NSDateFormatterNoStyle</span>];
[fmt setDateStyle:<span class="built_in">NSDateFormatterLongStyle</span>];
</code></pre>
<h3 id="Dates和Formatter小结"><a href="#Dates和Formatter小结" class="headerlink" title="Dates和Formatter小结"></a>Dates和Formatter小结</h3><ul>
<li>将NSDate和NSCalendar混合使用来计算时间</li>
<li>当展现日期和数字的时候使用foramtter</li>
</ul>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><h3 id="将数据以Plist的形式存储"><a href="#将数据以Plist的形式存储" class="headerlink" title="将数据以Plist的形式存储"></a>将数据以Plist的形式存储</h3><p>将数据转换成Plist：</p>
<pre><code class="objc"><span class="built_in">NSDictionary</span> *colors = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:<span class="string">@"Verde"</span>,<span class="string">@"Green"</span>,<span class="string">@"Rojo"</span>,<span class="string">@"Red"</span>,<span class="string">@"Amarillo"</span>,<span class="string">@"Yellow"</span>, <span class="literal">nil</span>];
<span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
<span class="built_in">NSData</span> *plist = [<span class="built_in">NSPropertyListSerialization</span> dataWithPropertyList:colors format:<span class="built_in">NSPropertyListXMLFormat_v1_0</span> options:<span class="number">0</span> error:&amp;error];
<span class="keyword">if</span> (!plist) {
    <span class="built_in">NSLog</span>(<span class="string">@"本地化失败"</span>);
}
[plist writeToFile:<span class="string">@"filePath"</span> atomically:<span class="literal">YES</span>];
</code></pre>
<p>将Plist转化成NSData：</p>
<pre><code class="objc"><span class="built_in">NSData</span> *readData = [<span class="built_in">NSData</span> dataWithContentsOfURL:urlOfFile];
<span class="built_in">NSDictionary</span> *newColors = [<span class="built_in">NSPropertyListSerialization</span> propertyListWithData:readData options:<span class="number">0</span> format:<span class="literal">nil</span> error:&amp;error];
</code></pre>
<h3 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h3><p>NSFileManager支持文件的复制，移动，链接，删除等。</p>
<pre><code class="objc"><span class="built_in">NSFileManager</span> *mgr = [[<span class="built_in">NSFileManager</span> alloc]init];
<span class="built_in">BOOL</span> res;
res = [mgr copyItemAtURL:src toURL:des error:&amp;error];
res = [mgr moveItemAtURL:src toURL:des error:&amp;error];
res = [mgr linkItemAtURL:src toURL:des error:&amp;error];
res = [mgr removeItemAtURL:src error:&amp;error];
</code></pre>
<p><code>linkItemAtURL</code>就是创建一个硬链接，硬链接就是给一个已经存在的文件重新创建另外一个名字，如果原来文件被删除了，那么硬链接的名字就会失效了。</p>
<p>NSFileManager还可以遍历某个目录下所有的内容：</p>
<pre><code class="objc"><span class="built_in">NSArray</span> *stuff = [mgr contentsOfDirectoryAtURL:dirURL includingPropertiesForKeys:[<span class="built_in">NSArray</span> array] options:<span class="number">0</span> error:&amp;error];
</code></pre>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/27/chat-nsdateformatter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/27/chat-nsdateformatter/" itemprop="url">如何优雅地使用DateFormatter？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-27T09:48:45+08:00">
                2017-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>之所以要聊<code>DateFormatter</code>是因为某次给项目做性能检测，发现创建DateFormatter太消耗性能，我们来做个对比，新建100000个日期。我们使用两种方式：第一种每次创建日期的时候新建一个NSDateFormatter，第二种共用一个NSDateFormatter，来生成日期：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">testWithMultipleInstantiation</span><span class="params">()</span></span> -&gt;<span class="type">CFTimeInterval</span> &#123;</div><div class="line">    </div><div class="line">        <span class="keyword">var</span> dateStrings:[<span class="type">String</span>] = []</div><div class="line">        dateStrings.reserveCapacity(<span class="number">100000</span>)</div><div class="line">        <span class="keyword">let</span> startTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">100000</span> &#123;</div><div class="line">            <span class="keyword">let</span> df = <span class="type">DateFormatter</span>()</div><div class="line">            df.dateStyle = .medium</div><div class="line">            df.timeStyle = .full</div><div class="line">            dateStrings.append(df.string(from: <span class="type">Date</span>()))</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">let</span> endTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">        <span class="keyword">return</span> endTime - startTime</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">testWithSingleInstance</span><span class="params">()</span></span> -&gt;<span class="type">CFTimeInterval</span> &#123;</div><div class="line">    </div><div class="line">        <span class="keyword">var</span> dateStrings: [<span class="type">String</span>] = []</div><div class="line">        dateStrings.reserveCapacity(<span class="number">100000</span>)</div><div class="line">        <span class="keyword">let</span> startTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">        <span class="keyword">let</span> df = <span class="type">DateFormatter</span>()</div><div class="line">        df.dateStyle = .medium</div><div class="line">        df.timeStyle = .full</div><div class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">100000</span> &#123;</div><div class="line">            dateStrings.append(df.string(from: <span class="type">Date</span>()))   </div><div class="line">        &#125;   </div><div class="line">        <span class="keyword">let</span> endTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">        <span class="keyword">return</span> endTime - startTime</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们调用这两个方法：</p>
<pre><code class="swift"><span class="built_in">print</span>(<span class="string">"testWithMultipleInstantiation--<span class="subst">\(testWithMultipleInstantiation()</span>)"</span>)
<span class="built_in">print</span>(<span class="string">"testWithSingleInstance--<span class="subst">\(testWithSingleInstance()</span>)"</span>)
</code></pre>
<p>打印结果是：</p>
<pre><code class="swift">testWithMultipleInstantiation--<span class="number">7.83139349098201</span>
testWithSingleInstance--<span class="number">0.742719032976311</span>
</code></pre>
<p>从中可以明显看到创建<code>DateFormatter</code>是很消耗性能的，多次创建DateFormatter比单次创建大约要慢11倍。如果我们要用DateFormatter，那么尽量创建一次，然后多次使用。</p>
<p>然后我们再做进一步的实验：创建一次<code>DateFormatter</code>，但是改变这个NSDateFormatter的<code>dateStyle</code>和<code>timeStyle</code>。</p>
<pre><code class="swift"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">testWithSingleInstanceChangeFormatter</span><span class="params">()</span></span> -&gt;<span class="type">CFTimeInterval</span> {

        <span class="keyword">var</span> dateStrings: [<span class="type">String</span>] = []
        dateStrings.reserveCapacity(<span class="number">100000</span>)
        <span class="keyword">let</span> startTime = <span class="type">CACurrentMediaTime</span>()
        <span class="keyword">let</span> df = <span class="type">DateFormatter</span>()
        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">100000</span> {

            df.dateStyle = .medium
            df.timeStyle = .full
            df.dateStyle = .full
            df.timeStyle = .medium
            dateStrings.append(df.string(from: <span class="type">Date</span>()))
        }

        <span class="keyword">let</span> endTime = <span class="type">CACurrentMediaTime</span>()
        <span class="keyword">return</span> endTime - startTime
    }
</code></pre>
<p>然后调用这个方法：</p>
<pre><code class="swift"><span class="built_in">print</span>(<span class="string">"ChangeFormatter--<span class="subst">\(testWithSingleInstanceChangeFormatter()</span>)"</span>)
</code></pre>
<p>这时输出的结果是：</p>
<pre><code class="swift"><span class="type">ChangeFormatter</span>--<span class="number">5.77827541399165</span>
</code></pre>
<p>从中我们可以看到，其对性能的消耗和多次创建DateFormatter相差并不多。最后我们得到这样一个结论：</p>
<blockquote>
<ol>
<li>每次使用DateFormatter时都新建是最消耗性能的</li>
<li>创建一个DateFormatter然后改变其<code>dateStyle</code>和<code>timeStyle</code>等和1中的性能消耗差不多</li>
<li>为每一种日期类型创建一种DateFormatter并且不改变其<code>dateStyle</code>和<code>timeStyle</code>等属性是性能最优的</li>
</ol>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过上面的结论，我们发现如果对DateFormatter做成单例，那么就必须保证每个DateFormatter的格式是相同的，因为改变DateFormatter的格式也是很消耗性能的。我们要做多个单例，每种单例是一种formatter，然后分别使用吗？显然太过于麻烦。<strong>我们可以使用缓存策略，将每种格式的DateFormatter缓存一份，下次如果有相同格式的Formatter，直接从缓存中取就可以了，这就避免了多次创建和多次改变格式的问题。</strong>为了解决这个问题，我使用NSCache做了一个DateFormatter的缓存池：<a href="https://github.com/MikeFighting/MFDateFormatterPool" target="_blank" rel="external">MFDateFormatterPool</a>，已经上传到了GitHub上，分为OC和Swift两个版本，如有问题可以联系我（Swift版稍后会加上）。</p>
<p><em>其它：NSDateFormatter在IOS7之前是非线程安全的，多线程可能引起崩溃，</em></p>
<h3 id="延伸阅读："><a href="#延伸阅读：" class="headerlink" title="延伸阅读："></a>延伸阅读：</h3><p><a href="https://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks#reuseobjects" target="_blank" rel="external">https://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks#reuseobjects</a><br><a href="http://www.chibicode.org/?p=41" target="_blank" rel="external">http://www.chibicode.org/?p=41</a><br><a href="https://stackoverflow.com/questions/18195051/crash-in-nsdateformatter-setdateformat-method" target="_blank" rel="external">https://stackoverflow.com/questions/18195051/crash-in-nsdateformatter-setdateformat-method</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/26/why-java-popular/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/why-java-popular/" itemprop="url">Java为什么会流行？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-26T09:17:48+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>下面是TIOBE对计算机语言流行度的最新排名：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-d7123c8e5701f435.png" alt="Language Rate"></p>
<p>我们可以看到Java名列第一，并且Java一直排名很靠前。为什么Java会如此流行呢？要了解Java为什么这么流行，我们先从它的起源说起。</p>
<h3 id="Java诞生的前奏"><a href="#Java诞生的前奏" class="headerlink" title="Java诞生的前奏"></a>Java诞生的前奏</h3><p>计算机业内一般认为：B语言导致了C语言的诞生，C语言演变出了C++，而C++会被Java语言所打败。是什么导致了Java的诞生？想要解决这个问题，我们先来看看Java的前辈们。</p>
<h4 id="C语言的诞生"><a href="#C语言的诞生" class="headerlink" title="C语言的诞生"></a>C语言的诞生</h4><p>C语言的产生是人们追求结构化、高效率、高级语言的结果，它可以替代汇编进行开发，它的出现改变了人们之前的编程方法和思路。</p>
<p>C语言的出现解决了之前语言的各种不足，比如：FORTRAN高效但不适用于编写系统程序。BASIC虽然容易学习，但是功能不够强大。汇编高效，但是学习成本很大，且很难调试。</p>
<p>另外，C语言之前的语言没有考虑结构化设计。它们大量使用<code>GOTO</code>语句来对程序进行控制。这样做的结果是<strong>程序极其混乱</strong>，各种跳转和条件分支交织在一起极大地影响了程序的可读性。人们解决该问题的愿望非常强烈，且日益迫切。20世界70年代初，计算机革命开始，人们对于软件的需求日益增加，使用当时的语言开发软件已经无法满足需求。人们在此期间进行了很多的尝试，但是没有发明出更好的语言。直到一个新机遇的到来：<strong>计算机硬件资源的富余</strong>。由于计算机硬件的增多，程序员可以随意的使用计算机，随意进行各种尝试，这就给了他们开发自己工具的机会。后来Ken Thompson发明了B语言，B语言演化到了C语言。1989年美国国家标准化组织制定了C语言的标准，C语言被正式标准化。C语言是由程序员对编程实践的总结而发明出来的，它能够解决早期语言的种种缺陷。</p>
<h4 id="C-的诞生"><a href="#C-的诞生" class="headerlink" title="C++的诞生"></a>C++的诞生</h4><p>C语言被用的好好的，为何出现了C++呢？原因是C语言太复杂了。当一个工程项目达到一定规模之后，使用结构化编程方法，编程人员就无法对它的复杂性进行有效管理。20世纪80年代初期，许多工程项目的复杂性都超过了结构化方法的极限。为了解决这个问题，面向对象诞生了。面向对象的特性：继承，封装，多态是用来帮助组织复杂程序的编程方法。因此出现了C++，C++的产生是基于C的，它包含了C的所有特征，属性和优点。</p>
<h4 id="Java出现的时机到了"><a href="#Java出现的时机到了" class="headerlink" title="Java出现的时机到了"></a>Java出现的时机到了</h4><p>在20世纪80年代末到90年代初，使用面向对象的C++语言占主导地位。然而，推动计算机语言进化的力量正在酝酿。万维网（WWW）和Internet在随后的几年达到了临界状态，这就促成了编程的另一场革命。</p>
<h3 id="Java诞生"><a href="#Java诞生" class="headerlink" title="Java诞生"></a>Java诞生</h3><p>由于嵌入式系统的发展，人们对一种独立于平台的语言更加渴望，这种语言可以嵌入微波炉，遥控器等各种家用电器设备的软件。用作控制器芯片的CPU是多种多样的，但是C和C++只能对特定目标进行编译。比如某个CPU要编译C++代码，那么就要创建一个针对该CPU的C++编译器，而创建编译器是一项耗时耗长，耗资大的工作。为了解决这个问题，Gosling和其他人一直在开发一种可移植，跨平台的语言。该语言能够生成运行于不同环境，不同CPU芯片上的代码。经过不懈的努力，在1991年被James Gosling，Patrick Naughton，Chris Warth，Ed Frank和Mike Sheridan发明出来。第一版花了18个月。刚开始叫Oak，于1995年更名为Java。</p>
<h3 id="Java流行"><a href="#Java流行" class="headerlink" title="Java流行"></a>Java流行</h3><p>在万维网（WWW）出现之前Java处于有用、摸摸无闻的用于电子消费品编程的状态。然而由于万维网的出现，Java被推到了计算机语言的设计的最前沿，<strong>因为万维网也需要可移植的程序。</strong></p>
<p>因特网是由不同的、分布式的系统组成，其中包含各种类型的计算机，操作系统和CPU。尽管许多类型的平台都可以与因特网连接，但是用户仍然希望他们能够运行同样的程序。</p>
<p>1993年，Java设计小组的成员发现解决嵌入式控制器可移植性的方法，也可以用来解决因特网的代码的可移植性问题。也就是Java不仅可以用来解决小范围的问题，也可以用来解决大范围的问题。这样他们将Java的重心由电子消费品，转移到Internet编程上。</p>
<h3 id="Java对Internet为什么重要"><a href="#Java对Internet为什么重要" class="headerlink" title="Java对Internet为什么重要"></a>Java对Internet为什么重要</h3><p>在网路中，在服务器和个人计算机间传递的信息有两大对象：被动的信息和动态的、主动运行的程序。比如阅读电子邮件是被动的数据，被服务器用来正确的显示服务器传递数据的程序是动态的。这中动态性是好的，但是其安全性和可移植行有严重的缺陷。在Java产生以前，赛百空间有一半的对象实体无法进入网络世界，是Java为它们打开了便利之门，而且在这个过程中定义了一种全新的程序形式:applet(小应用程序)。 </p>
<h4 id="Java小应用程序"><a href="#Java小应用程序" class="headerlink" title="Java小应用程序"></a>Java小应用程序</h4><p>Java可以用来生成两类程序：应用程序（Application）和小应用程序(Java applet)。应用程序不必说，小应用程序是可以再Internet中传输并在兼容Java的Web浏览器中运行的应用程序。小应用程序实际上就是小型的Java程序，它能够像图像文件、声音文件和视频片段那样通过网络动态下载。小程序的特点是，它是动态的智能的程序，可以对用户的输入作出反应，并变化。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>每次当你下载一个程序的时候，你都要冒着被病毒入侵的危险。Java出现之前，很多用户不经常下载可执行的程序文件。即使下载了，在运行它之前也要进行病毒检查。经管如此，很多用户还是担心他们的系统被病毒感染，除此之外，有些恶意程序可以搜索你计算机本地文件系统内容来收集你的私人信息，比如信用卡号码、银行账号和密码等。Java在网络程序和你的计算机之间提供了一道防火墙，消除了用户的顾虑。这道防火墙就是Java运行环境。Java程序被限制在了运行环境中，不允许它访问计算机的其他部分。</p>
<h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><p>链接到Internet上的计算机和操作系统不尽相同，要使它们都能动态地下载同一个程序，就需要有能够生成可移植性执行代码的方法。这个方法就是：Java编译器的输出并不是可执行的代码，而是字节码（bytecode）。字节码是一套设计用来在Java运行时环境下执行的高度优化的指令集，该Java运行时系统成为Java虚拟机（JavaVirtual Machine, JVM）。在标准形式下，JVM就是一个字节码解释器。只要某个平台安装了Java虚拟机，它就可以解释Java代码。当然对Java程序进行解释也有助于它的安全性。因为每个Java程序的运行都在Java虚拟机的控制之下，Java虚拟机可以包含这个程序，并且不让它在系统之外产生副作用。</p>
<h4 id="Java虚拟机的增强"><a href="#Java虚拟机的增强" class="headerlink" title="Java虚拟机的增强"></a>Java虚拟机的增强</h4><p>尽管Java被设计为解释执行的程序，但是这没有妨碍它将动态字节码编译为本机代码。SUN公司在Java 2发行版中提供了一个字节码编译器–JIT(Just In Time)。它可以根据需要，一部分一部分地将字节码实时编译为可执行代码。它不能将整个Java程序一次性全部编译为可执行的代码，因为Java要执行各种检查，而这些检查只有在运行时才执行。这种编译执行的方法使性能得到较大的提高。</p>
<p>经过上面的探讨我们发现，推动计算机语言发展的因素有两个：</p>
<blockquote>
<ul>
<li>适应正在变化的环境和需求</li>
<li>实现编程艺术的完善和提高</li>
</ul>
</blockquote>
<p>Java之所以流行主要因为万维网的发展和其自身安全性和可移植性的特点。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/24/avfoundation-capture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/avfoundation-capture/" itemprop="url">AVFoundation--媒体捕获</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-24T10:27:12+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了管理设备(比如摄像头或者麦克风)捕获的信息，你需要组合一些对象来代表输入和输出，并且使用<code>AVCaptureSession</code>对象来调节它们之间的数据。你最少需要如下步骤：</p>
<ul>
<li><code>AVCaptureDevice</code>对象来代表输入设备，比如：摄像头或者麦克风</li>
<li>具体的<code>AVCaptureInput</code>子类实例来配置输入设备的<code>port</code></li>
<li>具体<code>AVCaptureOutput</code>子类实例来输入一个视频文件或者静态图片</li>
<li>一个<code>AVCaptureSession</code>实例来协调输入到输入的数据流</li>
</ul>
<p>为了给用户预览正在录制的视频，你可以使用<code>AVCaptureVideoPreviewLayer</code>实例来实现。你可以通过一个单一的session来配置各种输入输出：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-c534307e74f3784f.png" alt="session work"></p>
<p>对于很多应用来说，这就已经够用了。然而对于某些操作来说，比如，你要检测音频频道的power level，你需要考虑某个输入设备的各种端口，以及这些端口是怎样和输出相连接的。<br>捕获输入和捕获输入之间的关联可以用<code>AVCaptureConnection</code>对象来表示。捕获输入（<code>AVCaptureInput</code>实例）有一到多个输入端口（<code>AVCaptureInputPort</code>实例）。捕获输出（<code>AVCaptureOutPut</code>实例）可以接受一到多个数据源（比如，一个<code>AVCaptureMovieFileOutput</code>对象可以接收视频或音频数据）。</p>
<p>当你往一个session中加入一个输入或者一个输出的时候，这个session可以形成针对所有捕获输入端口和捕获输出的连接。一个捕获输入和捕获输出之间的连接可以被一个<code>AVCaptureConnection</code>对象来表示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-5fc693a0e896e075.png" alt="Capture Connection"></p>
<p>对于指定的输入或者输出，你可以使用一个capture connection来使能或者关闭其数据流。你也可以使用connection来检测一个音频频道的平均及最高的power level。</p>
<p><em>注：媒体捕获不支持同时捕获IOS设备的前置和后置摄像头。</em></p>
<h2 id="使用捕获Session来调节数据流"><a href="#使用捕获Session来调节数据流" class="headerlink" title="使用捕获Session来调节数据流"></a>使用捕获Session来调节数据流</h2><p>一个<code>AVCaptureSessin</code>对象是你用来管理数据捕获的关键调节对象。你可以使用一个实例来调节视频音频输入到输出的数据。你可以给这个session添加捕获设备，然后通过调用session的<code>startRuning</code>方法来开始这个数据流，并且通过调用<code>stopRunning</code>方法来结束数据流。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</div><div class="line"><span class="comment">// Add inputs and outputs.</span></div><div class="line">[session startRunning];</div></pre></td></tr></table></figure>
<h3 id="配置Session"><a href="#配置Session" class="headerlink" title="配置Session"></a>配置Session</h3><p>使用<code>preset</code>来对session配置你所喜欢的图片质量和分辨率。一个preset是一个常量，它表明了很多种可选配置方案中的一种；在某些情况下实际的配置和具体的设备是相关的。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-7fb0bd8bbe4ae251.png" alt="prest"></p>
<p>如果你要对针对某个屏幕大小做配置，你需要在设置前检测其是否支持：</p>
<pre><code>if ([session canSetSessionPreset:AVCaptureSessionPreset1280x720]) {
    session.sessionPreset = AVCaptureSessionPreset1280x720;
} else { 
    // Handle the failure.
}
</code></pre><p>如果你要使用preset，以便在一个更加细粒度得调整session的参数，或者你要对一个执行中的session做某些改动，那么你需要你需要将你的方法添加在<code>beginConfiguration</code>和<code>commitConfiguration</code>方法中间。<code>beginConfiguration</code>和<code>commitConfiguration</code>可以确保设备的改变作为一组，最小的能见度或者状态的不兼容行。在调用<code>beginConfiguration</code>之后，你可以添加或者移除输出，改变<code>sessionPreset</code>属性，或者单独配置捕捉输入属性。只有在触发了<code>commitConfiguration</code>之后所有的改变才会生效，并且这些改变将会同时生效。</p>
<pre><code class="objc">session beginConfiguration];
<span class="comment">// Remove an existing capture device.</span>
<span class="comment">// Add a new capture device.</span>
<span class="comment">// Reset the preset.</span>
[session commitConfiguration];
</code></pre>
<h3 id="检测Capture-Session的状态"><a href="#检测Capture-Session的状态" class="headerlink" title="检测Capture Session的状态"></a>检测Capture Session的状态</h3><p>Capture session会在它开始，停止运行或者被打断的时候发出通知，你可以观察这些通知一遍被告知。你可以通过注册<code>AVCaptureSessionRuntimeErrorNotification</code>来观察一个运行时错误。你也可以通过查询session的<code>running</code>属性来判断其是否正在运行，以及其<code>interrupted</code>属性来判断其是否被打断了。除此之外，<code>running</code>属性和<code>interrupted</code>属性都支持KVO，这个会在主线程中被触发。</p>
<h2 id="AVCaptureDevice对象代表一个输入设备"><a href="#AVCaptureDevice对象代表一个输入设备" class="headerlink" title="AVCaptureDevice对象代表一个输入设备"></a>AVCaptureDevice对象代表一个输入设备</h2><p>一个<code>AVCaptureDevice</code>对象时对一个物理捕获设备的抽象，该对象可以给<code>AVCaptureSession</code>对象提供输入数据（比如，音频或者视频）。每个对象代表了一种输入设备，比如两个视频输入（前置后置摄像头），一个音频输入（麦克风）。<br>你可以通过使用<code>AVCaptureDevice</code>类方法<code>devices</code>和<code>devicesWithMediaType</code>来找出当前可用的捕获设备。并且，如果有必要的话你可以找出某个iPhone，iPad或者iPod所提供的特性。尽管如此，可用设备的列表是可以变化的。当前的输入设备可能变得不可用（如果它们被另外的应用所使用），新的输入设备变得可用（如果它们被另外的设备所放弃）。你可以注册<code>AVCaptureDeviceWasConnectedNotification</code>和<code>AVCaptureDeviceWasDisconnectedNotification</code>通知，以便在可用设备变化时候被通知到。你可以使用一个capture input来讲一个输入设备添加到<code>capture session</code>中。</p>
<h2 id="设备属性"><a href="#设备属性" class="headerlink" title="设备属性"></a>设备属性</h2><p>你可以查询某个设备的不同属性。使用<code>hasMediaType:</code>和<code>supportsAVCaptureSessionPreset:</code>方法，你可以检测某个设备是否提供某种媒体类型或者支持一种给定的capture session preset。为了给用户提供有用的信息，你可以找出捕获设备的位置(它在检测单元的前面还是后面)，以及它本地化后的名字。如果你要给用户展示一个捕获列表来让其选择，那么这种方式是很有用的。</p>
<p>下图展示了后置（AVCaptureDevicePositionBack）和前置（AVCaptureDevicePositionFront）摄像头。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-b1a87fc70f2f3de3.png" alt="front and back facing camera position"></p>
<p>下面的例子遍历了所有的可用设备并且打印出它们的名字（对于视频设备来说，还有它们的位置）。</p>
<pre><code class="objc"><span class="built_in">NSArray</span> *devices = [<span class="built_in">AVCaptureDevice</span> devices];
  <span class="keyword">for</span> (<span class="built_in">AVCaptureDevice</span> *device <span class="keyword">in</span> devices) {
      <span class="built_in">NSLog</span>(<span class="string">@"Device name: %@"</span>, [device localizedName]);
      <span class="keyword">if</span> ([device hasMediaType:<span class="built_in">AVMediaTypeVideo</span>]) {
          <span class="keyword">if</span> ([device position] == <span class="built_in">AVCaptureDevicePositionBack</span>) {
              <span class="built_in">NSLog</span>(<span class="string">@"Device position : back"</span>);

} <span class="keyword">else</span> { 
<span class="built_in">NSLog</span>(<span class="string">@"Device position : front"</span>);
          }
} }
</code></pre>
<p>除此之外，你可以找出设备的模型ID以及其唯一标示。</p>
<h3 id="设备捕获设置"><a href="#设备捕获设置" class="headerlink" title="设备捕获设置"></a>设备捕获设置</h3><p>不同的设备有不同的功能，比如，某些设备支持聚焦和flash模式，某些可以支持聚焦到某个兴趣点。<br>下面的代码段展说明了怎样找到有手电筒模式的视频输入设备，并且它支持一个给定的capture session preset：</p>
<pre><code class="objc"><span class="built_in">NSArray</span> *devices = [<span class="built_in">AVCaptureDevice</span> devicesWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];
<span class="built_in">NSMutableArray</span> *torchDevices = [[<span class="built_in">NSMutableArray</span> alloc] init];
<span class="keyword">for</span> (<span class="built_in">AVCaptureDevice</span> *device <span class="keyword">in</span> devices) {
    [<span class="keyword">if</span> ([device hasTorch] &amp;&amp;
         [device supportsAVCaptureSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>]) {
        [torchDevices addObject:device];
} }
</code></pre>
<p>如果你发现很多设备满足你的标准，那么你可以让用户从中选择他们喜欢的来使用。为了给用户描述这个设备，你可以使用它的<code>localizedName</code>属性。<br>你可以用相似的方式来使用不同的特性。指明一种特定的模式方法是固定的，并且你可以查看设备是否支持某种特定模式。在某些情况下，你可以观察一个属性以便属性改变时候得到通知。任何情况下，在某种特定的特性下更改模式前要锁住设备，这在下文的<code>配置设备</code>小结中会有提及。</p>
<p><em>注：聚焦兴趣点和曝光兴趣点是彼此独立的，它们分别是focus mode和exposure mode。</em></p>
<h4 id="聚焦模式"><a href="#聚焦模式" class="headerlink" title="聚焦模式"></a>聚焦模式</h4><p>有三种聚焦模式：</p>
<ul>
<li><code>AVCaptureFocusModeLocked</code>：聚焦位置是固定的。当你想在锁住聚焦的情况下，让用户来组成场景那么这是很有用的。</li>
<li><code>AVCaptureFocusModeAutoFocus</code>：摄像头做一次扫描聚焦，然后返回到被锁住的状态。如果你想聚焦选中某个特定的物体，并且对那个物体保持聚焦（尽管那个物体可能不在拍摄场景中心），那么这种模式是很合适的。</li>
<li><code>AVCaptureFocusModeContinuousAutoFocus:</code>在这种模式下摄像头在需要的情况下持续地进行自动对焦。</li>
</ul>
<p>在利用<code>focusMode</code>属性来设置聚焦模式前，你可以使用<code>isFocusModeSupported:</code>方法来决定某个设备是否支持给定的聚焦模式。<br>除此之外，某种设备可能会支持对某个兴趣点的聚焦。你可以使用<code>focusPointOfInterestSupported</code>属性来做判断。如果支持的话，你可以使用<code>focusPointOfInterest</code>属性来设置聚焦点。你可以传递一个CGPoint值来指定聚焦的点，其中{0,0}代表左上角，{1,1}在水平模式home键在右侧的情况下。如果设备在竖直模式下，那么这种坐标关系也是适用的。</p>
<p>使用<code>adjustingFocus</code>属性来决定是否某个设备当前正在聚焦。使用KVO的形式，你可以再设备开始和停止聚焦的时候收到通知。</p>
<p>如果你改变了聚焦模式的设置，你可以像下面一样，将它们返回到默认设置：</p>
<pre><code class="objc"><span class="keyword">if</span> ([currentDevice isFocusModeSupported:<span class="built_in">AVCaptureFocusModeContinuousAutoFocus</span>]) {
    <span class="built_in">CGPoint</span> autofocusPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);
    [currentDevice setFocusPointOfInterest:autofocusPoint];
    [currentDevice setFocusMode:<span class="built_in">AVCaptureFocusModeContinuousAutoFocus</span>];
}
</code></pre>
<h4 id="曝光模式（Exposure-Modes）"><a href="#曝光模式（Exposure-Modes）" class="headerlink" title="曝光模式（Exposure Modes）"></a>曝光模式（Exposure Modes）</h4><p>曝光模式有以下两种：</p>
<ul>
<li><code>AVCaptureExposureModeContinuousAutoExposure：</code>在需要的情况下设备自动调整曝光水平。</li>
<li><code>AVCaptureExposureModeLocked：</code>在当前水平曝光水平是固定的。</li>
</ul>
<p>使用<code>isExposureModeSupported:</code>方法来决定是否某个设备支持某种给定的曝光模式，然后使用<code>exposureMode</code>属性来进行设定。</p>
<p>除此之外，某个设备可能会支持兴趣点的曝光。你可以使用<code>exposurePointOfInterestSupported</code>来特使其是否支持。如果支持的话，你可以使用<code>exposurePointOfInterest</code>属性来进行设置。你可以传递一个CGPoint值来指定聚焦的点，其中{0,0}代表左上角，{1,1}在水平模式home键在右侧的情况下。如果设备在竖直模式下，那么这种坐标关系也是适用的。<br>使用<code>adjustingExposure</code>属性来决定是否某个设备当前正在改变其曝光设置。使用KVO的形式，你可以再设备开始和停止曝光设置的时候收到通知。</p>
<p>如果你改变了曝光设置，那么你可以返回默认设置：</p>
<pre><code class="objc"><span class="keyword">if</span> ([currentDevice
isExposureModeSupported:<span class="built_in">AVCaptureExposureModeContinuousAutoExposure</span>]) {
    <span class="built_in">CGPoint</span> exposurePoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);
    [currentDevice setExposurePointOfInterest:exposurePoint];
    [currentDevice setExposureMode:<span class="built_in">AVCaptureExposureModeContinuousAutoExposure</span>];
}
</code></pre>
<h4 id="闪光灯模式"><a href="#闪光灯模式" class="headerlink" title="闪光灯模式"></a>闪光灯模式</h4><p>闪光灯模式又以下三种：</p>
<ul>
<li><code>AVCaptureFlashModeOff</code>：闪光灯不会开启</li>
<li><code>AVCaptureFlashModeOn</code>：闪光灯总是开启</li>
<li><code>AVCaptureFlashModeAuto</code>：设备会根据周围的光线环境来决定是否开启闪光灯</li>
</ul>
<p>使用<code>hasFlash</code>方法可以确定某个设备是否有闪光灯。如果返回是<code>YES</code>，然后你可以使用<code>isFlashModeSupported：</code>方法来判断其是否支持某种给定的闪光灯模式，最后使用<code>flashMode</code>属性来对其进行配置。</p>
<h4 id="手电筒模式"><a href="#手电筒模式" class="headerlink" title="手电筒模式"></a>手电筒模式</h4><p>在手电筒模式下，为了照亮视频捕捉，闪光灯是在低电耗的情况下持续打开的。一共有三种手电筒模式：</p>
<ul>
<li><code>AVCaptureTorchModeOff</code>：手电筒关闭</li>
<li><code>AVCaptureTorchModeOn</code>：手电筒总是打开</li>
<li><code>AVCaptureTorchModeAuto</code>：根据需要手电筒选择打开或者关闭</li>
</ul>
<p>你可以使用<code>hasTorch</code>属性来检测一个设备是否有手电筒。然后你可以使用<code>isTorchModeSupported:</code>方法来检测一个设备是否有给定的手电筒模式，然后通过<code>torchMode</code>属性来设置手电筒模式。<br>对于有手电筒的设备，如果设备和一个执行中的capture session相连接，那么这个手电筒就会被打开。</p>
<h4 id="视频防抖"><a href="#视频防抖" class="headerlink" title="视频防抖"></a>视频防抖</h4><p>依赖于具体的硬件设备，对于操作视频的连接，视频防抖是用的。尽管如此，并非所有的源格式和视频分辨率都支持视频防抖。</p>
<p>使能视频防抖可能会给视频捕捉Pipeline引入多余的延迟。可以使用<code>videoStabilizationEnabled</code>属性来检测视频防抖是否正在使用。<code>enablesVideoStabilizationWhenAvailable</code>属性可以在摄像头支持的情况下让应用自动的使能视频防抖。由于以上的限制，默认情况下视频防抖是被关闭的。</p>
<h4 id="白色平衡"><a href="#白色平衡" class="headerlink" title="白色平衡"></a>白色平衡</h4><p>有两种白色平衡模式：</p>
<ul>
<li><code>AVCaptureWhiteBalanceModeLocked</code>：白平衡模式是固定的。</li>
<li><code>AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance</code>：在需要的情况下，摄像头持续调整白平衡。</li>
</ul>
<p>你可以使用<code>isWhiteBalanceModeSupported:</code>方法来确定某个设备是否支持一种给定的白平衡，然后使用<code>whiteBalanceMode</code>属性来设置白屏模式。</p>
<p>你可以使用<code>adjustingWhiteBalance</code>属性来决定某个设备是否正在改变其白光模式的设定。你可以通过KVO来观察一个设备开始或者终止其白光设定。</p>
<h4 id="设置设备方向"><a href="#设置设备方向" class="headerlink" title="设置设备方向"></a>设置设备方向</h4><p>对于一个<code>AVCaptureConnection</code>，你可以给它设定指定的方向来指明你在<code>AVCaptureOutput</code>（AVCaptureMovieFileOutput，AVCaptureStillImageOutput 以及AVCaptureVideoDataOutput）中图片的朝向。</p>
<p>使用<code>AVCaptureConnectionsupportsVideoOrientation</code>属性来确定设备是否支持改变视频的方向，也可以使用<code>videoOrientation</code>属性来指明你想在输出端口中的指向。下面的代码指明了如何将一个<code>AVCaptureConnection</code>属性设定为<code>AVCaptureVideoOrientationLandscapeLeft:</code></p>
<pre><code class="objc"><span class="built_in">AVCaptureConnection</span> *captureConnection = &lt;<span class="meta">#A capture connection#&gt;;</span>
<span class="keyword">if</span> ([captureConnection isVideoOrientationSupported])
{
<span class="built_in">AVCaptureVideoOrientation</span> orientation = <span class="built_in">AVCaptureVideoOrientationLandscapeLeft</span>; [captureConnection setVideoOrientation:orientation]; 
}
</code></pre>
<h4 id="设置设备"><a href="#设置设备" class="headerlink" title="设置设备"></a>设置设备</h4><p>为了给设备设置一个捕获属性，你必须使用<code>lockForConfiguration：</code>属性来获取该设备的锁。这会避免其它应用对该属性做出不能兼容的改变。下面的代码片段说明了怎样在一个设备上改变其聚焦模式（首先确定是否该模式是被支持的），然后尝试锁住该设备来重新配置。如果这个锁是可获取的，那么聚焦模式就被改变，随后这个锁会被立即释放掉。</p>
<pre><code class="objc"><span class="keyword">if</span> ([device isFocusModeSupported:<span class="built_in">AVCaptureFocusModeLocked</span>]) {
    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
    <span class="keyword">if</span> ([device lockForConfiguration:&amp;error]) {
        device.focusMode = <span class="built_in">AVCaptureFocusModeLocked</span>;
        [device unlockForConfiguration];
    }
    <span class="keyword">else</span> {
        <span class="comment">// Respond to the failure as appropriate.</span>
}
</code></pre>
<p>只要你需要这个可设置的设备属性保持不变，那么你就应该持有这把设备锁。在非必要的情况下持有设备锁可能会降低其它应用的捕获质量。</p>
<h4 id="转换设备"><a href="#转换设备" class="headerlink" title="转换设备"></a>转换设备</h4><p>有时你可能想让用户在不同的输入设备间进行切换，比如，从使用前置摄像头到使用后置摄像头。为了避免暂停或者卡顿，你可以在运行状态下配置一个session，然而你需要将你的配置改变放在<code>beginConfiguration</code>和<code>commitConfiguration</code>之间。</p>
<pre><code class="objc"><span class="built_in">AVCaptureSession</span> *session = &lt;<span class="meta">#A capture session#&gt;;</span>
[session beginConfiguration];
[session removeInput:frontFacingCameraDeviceInput];
[session addInput:backFacingCameraDeviceInput];
[session commitConfiguration];
</code></pre>
<p>当最外面的<code>commitConfiguration</code>被触发时候，所有的改变会同时被执行。这就确保了平滑的转变。</p>
<h3 id="使用Capture-Inputs来给一个Session添加捕获设备"><a href="#使用Capture-Inputs来给一个Session添加捕获设备" class="headerlink" title="使用Capture Inputs来给一个Session添加捕获设备"></a>使用Capture Inputs来给一个Session添加捕获设备</h3><p>你可以使用一个<code>AVCaptureDeviceInput</code>（一个抽象<code>AVCaptureInput</code>类的子类）实例来给一个capture session添加一个捕获设备。</p>
<pre><code class="objc"><span class="built_in">NSError</span> *error;
<span class="built_in">AVCaptureDeviceInput</span> *input =
        [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];
<span class="keyword">if</span> (!input) {
    <span class="comment">// Handle the error appropriately.</span>
}
</code></pre>
<p>你可以使用<code>addInput:</code>来个一个session添加输入。如果合适的话，你可以使用<code>canAddInput</code>来确定某个捕获输入是否和现存的session是兼容的。</p>
<pre><code class="objc"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;<span class="meta">#Get a capture session#&gt;;</span>
  <span class="built_in">AVCaptureDeviceInput</span> *captureDeviceInput = &lt;<span class="meta">#Get a capture device input#&gt;;</span>
  <span class="keyword">if</span> ([captureSession canAddInput:captureDeviceInput]) {
      [captureSession addInput:captureDeviceInput];
  }
  <span class="keyword">else</span> {
      <span class="comment">// Handle the failure.</span>
}
</code></pre>
<p>如果想知道如何重新配置一个运行中的session，你可以查看上文中的<strong>Configuring a session</strong>中的细节。</p>
<p>一个<code>AVCaptureInput</code>可以给媒体数据提供多个流。比如，一个输入设备可以提供视频或者音频数据。每个输入提供的媒体流都是用AVCaptureInputPort来表示的。一个捕获session使用一个<code>AVCaptureConnection</code>对象来决定一组<code>AVCaptureInputPort</code>对象和一个<code>AVCaptureOutput</code>之间的映射。</p>
<h3 id="使用捕获输出来获取一个Session的输出"><a href="#使用捕获输出来获取一个Session的输出" class="headerlink" title="使用捕获输出来获取一个Session的输出"></a>使用捕获输出来获取一个Session的输出</h3><p>为了从一个捕获session中获取输出，你需要添加一个或者多个output。一个output是一个<code>AVCaptureOutput</code>子类的实例。你使用：</p>
<ul>
<li><code>AVCaptureMovieFileOutput</code>来输出一个视频文件</li>
<li>如果你想处理正在被捕获的视频的frame，比如，你要创建你自己的ViewLayer，那么你可以使用<code>AVCaptureVideoDataOutput</code></li>
<li>如果你要处理正在被捕获的音频你可以使用<code>AVCaptureAudioDataOutput</code></li>
<li>如果你要捕获静态图片以及元数据你可以使用<code>AVCaptureStillImageOutput</code></li>
</ul>
<p>使用<code>addOutput：</code>你可以给某个捕获session添加outputs。通过使用<code>canAddOutput</code>，你可以检测是否某个捕获输出和现存session相兼容。在某个session运行的过程中，你可以根据需要添加或者移除输出。</p>
<pre><code class="objc"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;<span class="meta">#Get a capture session#&gt;;</span>
<span class="built_in">AVCaptureMovieFileOutput</span> *movieOutput = &lt;<span class="meta">#Create and configure a movie output#&gt;;</span>
<span class="keyword">if</span> ([captureSession canAddOutput:movieOutput]) {
    [captureSession addOutput:movieOutput];
}
<span class="keyword">else</span> {
    <span class="comment">// Handle the failure.</span>
}
</code></pre>
<h4 id="保存视频文件"><a href="#保存视频文件" class="headerlink" title="保存视频文件"></a>保存视频文件</h4><p>你可以使用<code>AVCaptureMovieFileOutput</code>对象来将某个视频数据保存到文件中。（<code>AVCaptureMovieFileOutput</code>是<code>AVCaptureFileOutput</code>的子类，它定义了很多基本操作）。你可以对一个视频文件输出的很多方面做以配置，比如录制的最大时长，文件大小。如果可用的磁盘空间小于指定的值你可以禁止视频的录制。</p>
<pre><code class="objc"><span class="built_in">AVCaptureMovieFileOutput</span> *aMovieFileOutput = [[<span class="built_in">AVCaptureMovieFileOutput</span> alloc]
init];
<span class="built_in">CMTime</span> maxDuration = &lt;<span class="meta">#Create a CMTime to represent the maximum duration#&gt;;</span>
aMovieFileOutput.maxRecordedDuration = maxDuration;
aMovieFileOutput.minFreeDiskSpaceLimit = &lt;<span class="meta">#An appropriate minimum given the quality of the movie format and the duration#&gt;;</span>
</code></pre>
<p>视频输出的分辨率和比特率取决于一个捕获session的<code>sessionPreset</code>值。视频编码通常是H.264格式，音频编码通常是AAC格式。实际的数值可能根据设备的不同而改变。</p>
<h4 id="开始录制"><a href="#开始录制" class="headerlink" title="开始录制"></a>开始录制</h4><p>使用<code>startRecordingToOutputFileURL:recordingDelegate:</code>你可以开始录制一个QuickTime视频。你需要提供一个基于文件的URL以及一个代理。这个URL一定不能和已存在文件相同，因为视频文件输出不会覆盖已存在的资源。同时，你也需要获得往某个指定的路径下写文件的权限。代理必须遵守<code>AVCaptureFileOutputRecordingDelegate</code>协议，并且必须要实现<code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code>方法。</p>
<pre><code class="objc"><span class="built_in">AVCaptureMovieFileOutput</span> *aMovieFileOutput = &lt;<span class="meta">#Get a movie file output#&gt;;</span>
<span class="built_in">NSURL</span> *fileURL = &lt;<span class="meta">#A file URL that identifies the output location#&gt;;</span>
[aMovieFileOutput startRecordingToOutputFileURL:fileURL recordingDelegate:&lt;<span class="meta">#The</span>
delegate<span class="meta">#&gt;];</span>
</code></pre>
<p>在实现<code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code>代理方法的时候，代理可以往相册中写入录制的视频。这也可以检测可能出现的错误。</p>
<h4 id="确保文件被成功写入"><a href="#确保文件被成功写入" class="headerlink" title="确保文件被成功写入"></a>确保文件被成功写入</h4><p>在实现<code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code>方法的时候，为了确保文件是否被成功的写入了，你不仅仅需要检查error，还需要检查error的user info字典中<code>AVErrorRecordingSuccessfullyFinishedKey</code>的值：</p>
<pre><code class="objc">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)captureOutput
        didFinishRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)outputFileURL
        fromConnections:(<span class="built_in">NSArray</span> *)connections
        error:(<span class="built_in">NSError</span> *)error {
    <span class="built_in">BOOL</span> recordedSuccessfully = <span class="literal">YES</span>;
    <span class="keyword">if</span> ([error code] != noErr) {
        <span class="comment">// A problem occurred: Find out if the recording was successful.</span>
        <span class="keyword">id</span> value = [[error userInfo]
objectForKey:<span class="built_in">AVErrorRecordingSuccessfullyFinishedKey</span>];
        <span class="keyword">if</span> (value) {
            recordedSuccessfully = [value boolValue];
} } 
    <span class="comment">// Continue as appropriate...</span>
</code></pre>
<p>你需要检测user info字典中的key<code>AVErrorRecordingSuccessfullyFinishedKeykey</code>的值，因为尽管有错误，文件还是可以被存储成功。这个错误可能标志着你达到了某个视频录制的限制，比如，<code>AVErrorMaximumDurationReached</code>或者<code>AVErrorMaximumFileSizeReached</code>。其它可能导致录制停止的原因有：</p>
<ul>
<li>磁盘占满了：AVErrorDiskFull</li>
<li>录制设备断开连接了：AVErrorDeviceWasDisconnected</li>
<li>session被中止了（比如，收到了一个电话）：AVErrorSessionWasInterrupted </li>
</ul>
<h4 id="给文件添加元数据"><a href="#给文件添加元数据" class="headerlink" title="给文件添加元数据"></a>给文件添加元数据</h4><p>任何时候你都可以给一个视频文件设置元数据，甚至是在录制的时候。在某些场景下这时很有用的，比如当视频录制开始的时候信息不可以拿到，这可能因为位置信息造成的。某个输出文件的元数据是由一组<code>AVMetaDataItem</code>对象来表示的；你使用它可变子类的一个实例，<code>AVMutableMetadataItem</code>来创建一个你自己的元数据。</p>
<pre><code class="objc">VCaptureMovieFileOutput *aMovieFileOutput = &lt;<span class="meta">#Get a movie file output#&gt;;</span>
<span class="built_in">NSArray</span> *existingMetadataArray = aMovieFileOutput.metadata;
<span class="built_in">NSMutableArray</span> *newMetadataArray = <span class="literal">nil</span>;
<span class="keyword">if</span> (existingMetadataArray) {
    newMetadataArray = [existingMetadataArray mutableCopy];
}
<span class="keyword">else</span> {
    newMetadataArray = [[<span class="built_in">NSMutableArray</span> alloc] init];
} 
<span class="built_in">AVMutableMetadataItem</span> *item = [[<span class="built_in">AVMutableMetadataItem</span> alloc] init];
item.keySpace = <span class="built_in">AVMetadataKeySpaceCommon</span>;
item.key = <span class="built_in">AVMetadataCommonKeyLocation</span>;
<span class="built_in">CLLocation</span> *location - &lt;<span class="meta">#The location to set#&gt;;</span>
item.value = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%+08.4lf%+09.4lf/"</span>
    location.coordinate.latitude, location.coordinate.longitude];
[newMetadataArray addObject:item];
aMovieFileOutput.metadata = newMetadataArray;
</code></pre>
<h4 id="处理视频帧"><a href="#处理视频帧" class="headerlink" title="处理视频帧"></a>处理视频帧</h4><p>一个<code>AVCaptureVideoDataOutput</code>对象使用代理来处理视频帧。你可以通过<code>setSampleBufferDelegate:queue:</code>方法来设置代理。除了设置代理，你还可以指定该代理方法被调用的队列。你必须使用一个串行队列来确保传递给代理的帧是按照合适顺序进行的。你可以使用队列来改变既定的调度和处理视频帧的优先权。参考<code>SquareCam</code>来作为一个实现的例子。</p>
<p>在代理方法里，帧作为一个<code>CMSampleBufferRef</code>类型的实例来被表示<code>captureOutput:didOutputSampleBuffer:fromConnection:</code>。默认情况下，缓冲是以视频最有效的格式被发发出的。你可以使用<code>videoSettings</code>属性来指明一种定制的输出格式。视频的设定属性是一个字典；目前为止，唯一支持的key是<code>kCVPixelBufferPixelFormatTypeKey</code>。</p>
<p>推荐的像素格式是通过<code>availableVideoCVPixelFormatTypes</code>属性来返回的，同时<code>availableVideoCodecTypes</code>属性返回支持的数值。Core Graphics和OpenGL都和BGRA格式配合的很好。</p>
<pre><code class="objc"><span class="built_in">AVCaptureVideoDataOutput</span> *videoDataOutput = [<span class="built_in">AVCaptureVideoDataOutput</span> new];
<span class="built_in">NSDictionary</span> *newSettings =
                @{ (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey :
@(kCVPixelFormatType_32BGRA) };
videoDataOutput.videoSettings = newSettings;
 <span class="comment">// discard if the data output queue is blocked (as we process the still image</span>
[videoDataOutput setAlwaysDiscardsLateVideoFrames:<span class="literal">YES</span>];)
<span class="comment">// create a serial dispatch queue used for the sample buffer delegate as well as</span>
when a still image is captured
<span class="comment">// a serial dispatch queue must be used to guarantee that video frames will be</span>
delivered <span class="keyword">in</span> order
<span class="comment">// see the header doc for setSampleBufferDelegate:queue: for more information</span>
videoDataOutputQueue = dispatch_queue_create(<span class="string">"VideoDataOutputQueue"</span>,
DISPATCH_QUEUE_SERIAL);
[videoDataOutput setSampleBufferDelegate:<span class="keyword">self</span> queue:videoDataOutputQueue];
<span class="built_in">AVCaptureSession</span> *captureSession = &lt;<span class="meta">#The Capture Session#&gt;;</span>
<span class="keyword">if</span> ( [captureSession canAddOutput:videoDataOutput] )
     [captureSession addOutput:videoDataOutput];
</code></pre>
<h4 id="处理视频时考虑的性能因素"><a href="#处理视频时考虑的性能因素" class="headerlink" title="处理视频时考虑的性能因素"></a>处理视频时考虑的性能因素</h4><p>对于你的应用来说，你应该给这个session设置最低的可用分辨率。将输出设定到一个比需求更高的分辨率会浪费处理循环以及消耗更多的电量。<br>你必须确保你实现了<code>captureOutput:didOutputSampleBuffer:fromConnection</code>方法，以便在创建一帧的时候可以处理一个采样缓冲。如果这耗费过长的时间，并且你保持了这个视频帧率，那么AV Foundation对象就会停止传送帧，不尽停止给你的代理传递帧，还会停止向其它的输出传递帧，比如preview layer。<br>你可以使用捕获视频数据输出的<code>minFrameDuration</code>属性来确定你在没有被停止的情况下消耗更少的帧率，以便你有足够的时间来处理这一帧。你也许也要确保<code>alwaysDiscardsLateVideoFrames</code>属性也被设置成<code>YES</code>（默认情况下也是YES）。这个属性确保了任何延迟了的帧都会被丢弃而不是移交给你进行处理。换句话说，如果你正在录制视频，并且如果输出帧有些延迟不会造成影响，并且你想获取所有的帧，那么你可以将这个属性的值设定为NO。这并不意味这不会掉帧（也就是说，帧仍然会掉），但是它不会掉的那么早或者由于效率原因掉帧。</p>
<h3 id="捕获静态图片"><a href="#捕获静态图片" class="headerlink" title="捕获静态图片"></a>捕获静态图片</h3><p>如果你想捕获静态图片以及元数据，那么你可以使用<code>AVCaptureStillImageOutput</code>来输出。这个图片的分辨率取决于这个session的preset以及这个设备。</p>
<h4 id="像素和编码格式"><a href="#像素和编码格式" class="headerlink" title="像素和编码格式"></a>像素和编码格式</h4><p>不同的设备支持不同的图片格式。分别使用<code>availableImageDataCVPixelFormatTypes</code>和<code>availableImageDataCodecTypes</code>你可以找出某个设备支持的pixel和codec类型。每个方法会返回指定设备所支持数据的数组。你可以设置<code>outputSettings</code>字典来设置你所想要的图片格式，比如：</p>
<pre><code class="objc"><span class="built_in">AVCaptureStillImageOutput</span> *stillImageOutput = [[<span class="built_in">AVCaptureStillImageOutput</span> alloc]
init];
<span class="built_in">NSDictionary</span> *outputSettings = @{ <span class="built_in">AVVideoCodecKey</span> : <span class="built_in">AVVideoCodecJPEG</span>};
[stillImageOutput setOutputSettings:outputSettings];
</code></pre>
<p>如果你要获取一张JPEG格式的图片，那么你通常不需要指定你自己的压缩格式。相反，因为它的压缩格式是硬件驱动的，所以你应该让静态图片输出来给你压缩。尽管你改变了图片的元数据，如果你要得到一张图片的数据表示，那么你可以使用<code>jpegStillImageNSDataRepresentation:</code>来得到没有被再次压缩数据的<code>NSData</code>对象。</p>
<h4 id="捕获一张图片"><a href="#捕获一张图片" class="headerlink" title="捕获一张图片"></a>捕获一张图片</h4><p>当你想捕获一张图片的时候，你可以调用输出的captureStillImageAsynchronouslyFromConnection:completionHandler:方法。第一个参数是你为了捕获要用的连接。你需要找到这个连接，它的输入端是一个，它的输入端口正在搜集视频：</p>
<pre><code> AVCaptureConnection *videoConnection = nil;
  for (AVCaptureConnection *connection in stillImageOutput.connections) {
       for (AVCaptureInputPort *port in [connection inputPorts]) {
          if ([[port mediaType] isEqual:AVMediaTypeVideo] ) {
              videoConnection = connection;
break; } 
} 
      if (videoConnection) { break; }
     }
</code></pre><p><code>captureStillImageAsynchronouslyFromConnection:completionHandler:</code>方法的第二个参数是一个具有两个参数的block：一个包含了图片数据的<code>CMSampleBuffer</code>类和一个error。采样缓冲自身包含了比如EXIF字典等元数据作为其附属。如果你想你可以改变这个附属，但是要注意在<strong>像素和编码格式</strong>中提到的对JPEG图片的优化。</p>
<pre><code class="objc">[stillImageOutput captureStillImageAsynchronouslyFromConnection:videoConnection
completionHandler:
    ^(<span class="built_in">CMSampleBufferRef</span> imageSampleBuffer, <span class="built_in">NSError</span> *error) {
        <span class="built_in">CFDictionaryRef</span> exifAttachments =
            <span class="built_in">CMGetAttachment</span>(imageSampleBuffer, kCGImagePropertyExifDictionary,
<span class="literal">NULL</span>);
        <span class="keyword">if</span> (exifAttachments) {
            <span class="comment">// Do something with the attachments.</span>
        }
        <span class="comment">// Continue as appropriate.</span>
    }];
</code></pre>
<h3 id="展示录制的内容"><a href="#展示录制的内容" class="headerlink" title="展示录制的内容"></a>展示录制的内容</h3><p>你可以给用户提供视频录制的预览（利用preview layer）,或者音频录制的预览（通过监听音频channel）。</p>
<h4 id="视频预览"><a href="#视频预览" class="headerlink" title="视频预览"></a>视频预览</h4><p>使用<code>AVCaptureVideoPreviewLayer</code>对象，你可以给用户提供一个录制内容的预览。<code>AVCaptureVideoPreviewLayer</code>是<code>CALayer</code>的子类。为了展示预览，你不需要输出任何东西。</p>
<p>在视频展示给用户之前，使用<code>AVCaptureVideoDataOutput</code>类可以让客户端程序具有获取视频像素的能力。</p>
<p>和捕获输出不一样，一个视频预览layer保持一个对其关联session的一个强引用。这就确保了在该layer试图播放视频的时候session不会被释放。下面的代码展示了初始化一个预览layer的方式。</p>
<pre><code class="objc"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;<span class="meta">#Get a capture session#&gt;;</span>
<span class="built_in">CALayer</span> *viewLayer = &lt;<span class="meta">#Get a layer from the view in which you want to present the</span>
 preview<span class="meta">#&gt;;</span>
<span class="built_in">AVCaptureVideoPreviewLayer</span> *captureVideoPreviewLayer = [[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc] initWithSession:captureSession]; 
[viewLayer addSublayer:captureVideoPreviewLayer];
</code></pre>
<p>一般来说，这个preview layer在渲染树中和其它的CALayer对象是一样的。你可以像处理其它layer一样对图片进行伸缩，旋转等。其中有一个不同点是：为了指明来自摄像头的图片怎样旋转，你需要设置layer的<code>orientation</code>属性。除此之外，你可以通过查询<code>supportsVideoMirroring</code>属性来决定某个设备是否支持视频镜像。如果有需要你可以设置<code>videoMirrored</code>属性，尽管当<code>automaticallyAdjustsVideoMirroring</code>属性默认情况下是YES，这个镜像值基于session的配置而自动被设定的。</p>
<h4 id="视频重力模式"><a href="#视频重力模式" class="headerlink" title="视频重力模式"></a>视频重力模式</h4><p>这个preview layer支持三种重力模式，你可以通过<code>videoGravity</code>属性来设置：</p>
<ul>
<li><code>AVLayerVideoGravityResizeAspect</code>：这会按照固定的比例保存视频，当视频不能铺满整个可用屏幕大小的时候会留下黑条。</li>
<li><code>AVLayerVideoGravityResizeAspectFill</code>：这会保质视频的比例，但是会铺满整个屏幕，并且在需要的时候剪裁视频。</li>
<li><code>AVLayerVideoGravityResize</code>：这会拉伸视频来铺满整个可用的屏幕空间，尽管这样可能让图片扭曲。</li>
</ul>
<h4 id="给预览添加点击捕获功能"><a href="#给预览添加点击捕获功能" class="headerlink" title="给预览添加点击捕获功能"></a>给预览添加<code>点击捕获</code>功能</h4><p>在视频连接的时候，使用preview layer来实现点击捕获，你需要小心。你必须要考虑预览方向和layer的重力，以及这个预览可能被镜像的可能性。参考示例代码中IOS的<code>AVCam</code>项目来实现这个功能。</p>
<h3 id="展示音频等级（Audio-Level）"><a href="#展示音频等级（Audio-Level）" class="headerlink" title="展示音频等级（Audio Level）"></a>展示音频等级（Audio Level）</h3><p>为了在一个捕获连接中的音频通道中检测平均power和峰值power峰值，你可以使用<code>AVCaptureAudioChannel</code>对象。因为音频等级不是KVO的，所以你必须按照你需要的频率来访问其数值来更新UI（比如，每秒钟10次）。</p>
<pre><code class="objc"><span class="built_in">AVCaptureAudioDataOutput</span> *audioDataOutput = &lt;<span class="meta">#Get the audio data output#&gt;;</span>
<span class="built_in">NSArray</span> *connections = audioDataOutput.connections;
<span class="keyword">if</span> ([connections count] &gt; <span class="number">0</span>) {
    <span class="comment">// There should be only one connection to an AVCaptureAudioDataOutput.</span>
    <span class="built_in">AVCaptureConnection</span> *connection = [connections objectAtIndex:<span class="number">0</span>];
    <span class="built_in">NSArray</span> *audioChannels = connection.audioChannels;
    <span class="keyword">for</span> (<span class="built_in">AVCaptureAudioChannel</span> *channel <span class="keyword">in</span> audioChannels) {
        <span class="keyword">float</span> avg = channel.averagePowerLevel;
        <span class="keyword">float</span> peak = channel.peakHoldLevel;
        <span class="comment">// Update the level meter user interface.</span>
} }
</code></pre>
<h2 id="综合：像UIImage对象一样捕获视频帧"><a href="#综合：像UIImage对象一样捕获视频帧" class="headerlink" title="综合：像UIImage对象一样捕获视频帧"></a>综合：像UIImage对象一样捕获视频帧</h2><p>下面简明的代码实例向你展示了怎样捕获一个视频并且将你得到的视频帧转换成UIImage对象。它有以下的功能：</p>
<ul>
<li>创建一个<code>AVCaptureSession</code>对象来协调一个AV输入的数据流到一个输出</li>
<li>对你想要的输入类型找到<code>AVCaptureDevice</code>对象</li>
<li>给该设备创建一个<code>AVCaptureDeviceInput</code>对象</li>
<li>创建一个<code>AVCaptureVideoDataOutput</code>对象来产生视频帧</li>
<li>对<code>AVCaptureVideoDataOutput</code>对象实现一个代理对象来处理视频帧</li>
<li>实现一个方法来将该代理收到的<code>CMSampleBuffer</code>转换成一个UIImage对象</li>
</ul>
<h3 id="创建并且配置一个捕获Session"><a href="#创建并且配置一个捕获Session" class="headerlink" title="创建并且配置一个捕获Session"></a>创建并且配置一个捕获Session</h3><p>你可以使用<code>AVCaptureSession</code>对象来把来自一个AV输入设备的数据流来转换为一个输出。创建一个session，并且配置它来生成中等分辨率的视频帧：</p>
<pre><code class="objc"><span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];
session.sessionPreset = <span class="built_in">AVCaptureSessionPresetMedium</span>;
</code></pre>
<h3 id="创建配置设备及设备输入"><a href="#创建配置设备及设备输入" class="headerlink" title="创建配置设备及设备输入"></a>创建配置设备及设备输入</h3><p>捕获设备是由<code>AVCaptureDevice</code>对象表示的，该类提供了获取你想要的输入类型的方法。一个设备有一个或者多个端口，这些端口使用<code>AVCaptureInput</code>对象来配置。通常情况下，在它的默认配置上，你使用捕获输入。</p>
<p>找到一个视频捕获设备，然后利用该设备创建一个设备输入并且将其添加到session里面。如果一个合适的设备不能够被加载，那么<code>deviceInputWithDevice:error:</code>方法将会返回一个引用的错误。</p>
<pre><code class="objc"><span class="built_in">AVCaptureDevice</span> *device =
        [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];
<span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
<span class="built_in">AVCaptureDeviceInput</span> *input =
        [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];
<span class="keyword">if</span> (!input) {
    <span class="comment">// Handle the error appropriately.</span>
}
[session addInput:input];
</code></pre>
<h3 id="创建和配置视频输出数据"><a href="#创建和配置视频输出数据" class="headerlink" title="创建和配置视频输出数据"></a>创建和配置视频输出数据</h3><p>你使用一个<code>AVCaptureVideoDataOutput</code>对象来处理正在被捕获而未被压缩的帧。通常情况下，你可以配置一个输出的很多方面。比如，对于视频来说，你可以通过<code>videoSettings</code>属性来表明像素格式以及通过设置<code>minFrameDuration</code>属性来设置帧率的峰值。</p>
<p>创建和配置一个视频数据的输出并将其添加到session中，通过将<code>minFrameDuration</code>属性值设置为1/15来将帧率峰值设置为15fps：</p>
<pre><code class="objc"><span class="built_in">AVCaptureVideoDataOutput</span> *output = [[<span class="built_in">AVCaptureVideoDataOutput</span> alloc] init];
[session addOutput:output];
output.videoSettings =
                @{ (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey :
@(kCVPixelFormatType_32BGRA) };
output.minFrameDuration = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">15</span>);=
</code></pre>
<p>数据输出对象使用代理来提视频帧。这个代理必须遵守<code>AVCaptureVideoDataOutputSampleBufferDelegate</code>协议。当你设置数据输出代理的时候，你也必须提供一个回调将要被触发的队列。</p>
<pre><code class="objc"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"MyQueue"</span>, <span class="literal">NULL</span>);
[output setSampleBufferDelegate:<span class="keyword">self</span> queue:queue];
dispatch_release(queue);
</code></pre>
<p>你使用该队列改变给定的优先权来传递和处理视频帧。</p>
<h3 id="实现帧缓存的代理方法"><a href="#实现帧缓存的代理方法" class="headerlink" title="实现帧缓存的代理方法"></a>实现帧缓存的代理方法</h3><p>在该代理类里，实现<code>captureOutput:didOutputSampleBuffer:fromConnection:</code>方法，这个方法会在一个采样缓存被写入的时候被调用。视频数据的输出对象以<code>CMSampleBuffer</code>类型的形式来传递帧，因此，你需要将一个<code>CMSampleBuffer</code>对象转换为一个UIImage对象。这个转换的方法会在<code>Converting CMSampleBuffer to UIImage Object</code>中说明。</p>
<pre><code class="objc">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput
          didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer
          fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection {

      <span class="built_in">UIImage</span> *image = imageFromSampleBuffer(sampleBuffer);
     <span class="comment">// Add your code here that uses the image.</span>
 }
</code></pre>
<p>这个代理方法被触发的队列就是你在<code>setSampleBufferDelegate:queue:</code>中指明的队列；如果你要更新UI，那么你必须在主线程中执行相关的代码。</p>
<h3 id="开始和终止录制"><a href="#开始和终止录制" class="headerlink" title="开始和终止录制"></a>开始和终止录制</h3><p>在配置完capture session之后，你应该确保根据用户的偏好设置里你有录制视频的权限。</p>
<pre><code class="objc"><span class="built_in">NSString</span> *mediaType = <span class="built_in">AVMediaTypeVideo</span>
[<span class="built_in">AVCaptureDevice</span> requestAccessForMediaType:mediaType completionHandler:^(<span class="built_in">BOOL</span>
granted) {
    <span class="keyword">if</span> (granted)
    {
        <span class="comment">//Granted access to mediaType</span>
        [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">YES</span>];
    }
<span class="keyword">else</span> { 
        <span class="comment">//Not granted access to mediaType</span>
        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        [[[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"AVCam!"</span>
message:<span class="string">@"AVCam doesn't have permission to use Camera, please change privacy settings"</span> 
}); } 
}]; 
                   delegate:<span class="keyword">self</span>
          cancelButtonTitle:<span class="string">@"OK"</span>
          otherButtonTitles:<span class="literal">nil</span>] show];
[<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">NO</span>];
</code></pre>
<p>如果摄像头的session被配置完成并且用户隐私设定允许使用摄像头，你可以调用<code>startRunning</code>方法来执行session在串行队列上的启动，以便主队列不会被阻塞（这可以让UI更加快速的被响应）。看iOS的AVCam作为一个实现的例子。</p>
<pre><code class="objc">[session startRunning];
</code></pre>
<p>通过调用<code>stopRunning</code>方法，你可以停止录制视频。</p>
<h3 id="高帧率的视频捕获"><a href="#高帧率的视频捕获" class="headerlink" title="高帧率的视频捕获"></a>高帧率的视频捕获</h3><p>在选中的硬件上，iOS7.0引入了高帧率的视频捕获（也称作”SloMo”视频）。所有的AV Foundation框架都支持高帧率的内容。<br>你可以使用<code>AVCaptureDeviceFormat</code>类来确定某个设备的捕获能力。该类也有返回诸如：所支持的媒体类型，帧率，视图的field，最大放大倍数以及视频防抖是否被支持等参数。</p>
<ul>
<li>捕获支持在60fps下全720p分辨率，其中包括视频防抖，可掉P帧（H264编码视频的特性，这种特性可以让视频播放很流畅，及时在老设备上也可以这样。）</li>
<li>视频播放可以提高音频对慢速和快速播放的支持，这就让音频的捕获时间（time pitch）可以在更低或者更高的速度下被保存。</li>
<li>在可变合成的中，可以支持缩放编辑。</li>
<li>在支持60fps视频的时候，输出提供了两种选择。可变的帧率，慢速或快速的移动，都会被保存或者视频帧率将会变得更小，比如30fps。</li>
</ul>
<h4 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h4><p>一个<code>AVPlayer</code>实例可以通过<code>setRate：</code>方法来自动设置大多数的播放速度。该数值会作为播放速度的一个放大倍数。1.0数值表示正常的播放，0.5数值表示以一半的速度播放，5.0数值表示以正常速度5倍的速度来播放。</p>
<p><code>AVPlayerItem</code>对象支持<code>audioTimePitchAlgorithm</code>属性。使用<code>Time Pitch Algorithm Settings</code>常量，该属性让你可以指明音频在不同帧率下的播放方式。<br>下表展示了所支持的time pitch算法，数量，该算法是否会造成音频在某个指定帧率下停止，以及每个算法支持的帧率范围。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-f751221f7dba579d.png" alt="Time Pitch Algorithm"></p>
<h4 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h4><p>编辑的时候，你可以使用<code>AVMutableComposition</code>类来建立临时的编辑。</p>
<ul>
<li>使用<code>composition</code>类方法来创建一个新的<code>AVMutableComposition</code>实例</li>
<li>使用<code>insertTimeRange:ofAsset:atTime:error</code>方法来插入你的视频asset</li>
<li>使用<code>scaleTimeRange:toDuration</code>来设定某个合成中某个部分的时间比例</li>
</ul>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>使用<code>AVAssetExportSession</code>类来导出60fps的视频输出一个asset。该内容可以用以下两种方式输出：</p>
<ul>
<li>使用<code>AVAssetExportPresetPassthrough</code>preset来避免视频的重编码。通过对标志为60fps的媒体片段进行时间重置，这些媒体片段就会减速或者加速。</li>
<li>为了最大播放兼容，使用恒定帧率输出。设定视频合成的<code>frameDuration</code>属性为30fps。你也可以通过设定导出session的<code>audioTimePitchAlgorithm</code>属性来指定捕获时间(time pitch)。</li>
</ul>
<h4 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h4><p>使用<code>AVCaptureMovieFileOutput</code>类，你可以捕获高帧率的视频，它自动支持高帧率捕获。它会自动选择正确的H264捕获水平。</p>
<p>为了使用定制的录制，你必须使用<code>AVAssetWriter</code>类，这需要额外的设置。</p>
<pre><code class="objc">assetWriterInput.expectsMediaDataInRealTime=<span class="literal">YES</span>;
</code></pre>
<p>该设置可以确保捕获可以和输入的数据保持同步。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/24/avfoundation-edit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/avfoundation-edit/" itemprop="url">AVFoundation--视频编辑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-24T10:26:09+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AV Foundation框架提供了很多类来方便对视频和音频的资源处理。AV Foundation框架的核心API是合成。一个合成仅仅是对一种或多种不同媒体资源track的组合。<code>AVMutableComposition</code>类提供了一个插入，移除以及管理track临时顺序的接口。你可以使用一个mutable composition来将一个新的asset和已经存在的asset集合组合在一起。如果你仅仅需要将很多的asset按序组装到一起，这些就够了。如果你想在合成的过程中执行任何定制的视频，音频处理，你需要分别加入音频混合（audio mix）和视频合成。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-78492783e7c8d858.png" alt="Mutable Composition"></p>
<p>使用<code>AVMutableAudioMix</code>类，你可以在合成的过程中定制音频。同时，你可以指定一个音轨（audio track）的最大音量，或者设定一个音量坡度（volume ramp）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-c1cb33719c5023b8.png" alt="AudioMix"></p>
<p>对于视频合成中的video track如果要编辑的话，你可以使用<code>AVMutableVideoComposition</code>类来进行处理。对于单一的视频合成来说，你可以对输出的视频文件指明渲染的大小，比例，以及时长。通过一个视频的合成指令（<code>AVMutableVideoCompositionInstruction</code>类提供），你可以改变视频的背景色并且使用layer指令。在合成过程中，你可以使用这些layer指令(<code>AVMutableVideoCompositionLayerInstruction</code>类)来对video track实现旋转，旋转坡度（transform ramps），透明度，透明度坡度（opacity ramp）。视频合成类也可以让你使用核心动画来产生响应的效果（使用<code>animationTool</code>属性）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-615e5cde04c0c133.png" alt="Video Composition"></p>
<p>使用<code>AVAssetExportSession</code>，你可以将音频混合（audio mix）和视频合成同时组合到你的合成中去。用你的composition初始化这个export session，然后将音频混合和视频混合分别赋值给<code>audioMix</code>和<code>videoComposition</code>属性即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-eea273fda859f11e.png" alt="Audio Mix And Video Composition"></p>
<h2 id="创建一个Composition"><a href="#创建一个Composition" class="headerlink" title="创建一个Composition"></a>创建一个Composition</h2><p>使用<code>AVMutableComposition</code>类来创建你自己的composition。为了添加媒体数据到你的composition，你必须通过<code>AVMutableCompositionTrack</code>类来添加一个或者多个composition tracks。最简单的情况就是用video track和audio track来创建一个mutable composition。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div></pre></td><td class="code"><pre><div class="line">AVMutableComposition *mutableComposition = [AVMutableComposition composition];</div><div class="line">// Create the video composition track.</div><div class="line">AVMutableCompositionTrack *mutableCompositionVideoTrack = [mutableComposition</div><div class="line">addMutableTrackWithMediaType:AVMediaTypeVideo</div><div class="line">preferredTrackID:kCMPersistentTrackID_Invalid];</div><div class="line">// Create the audio composition track.</div><div class="line">AVMutableCompositionTrack *mutableCompositionAudioTrack = [mutableComposition</div><div class="line">addMutableTrackWithMediaType:AVMediaTypeAudio</div><div class="line">preferredTrackID:kCMPersistentTrackID_Invalid];</div><div class="line">```   </div><div class="line"></div><div class="line">### 初始化一个Composition Track时的选项</div><div class="line"></div><div class="line">当你要往一个composition中添加一个新的track的时候，你必须提供一个media type和一个track ID。尽管视频和音频是最常用的media type，你还可以设置其它的media type，比如`AVMediaTypeSubtitle`（字幕）`AVMediaTypeText`（文本）。</div><div class="line"></div><div class="line">每一个和试听数据相关的track都有一个唯一标示叫做 track ID。如果你将这个track ID赋值为`kCMPersistentTrackID_Invalid`，那么在关联的时候系统会自动给你创建一个唯一标识。</div><div class="line"></div><div class="line">## 给一个Composition添加音视频数据</div><div class="line"></div><div class="line">一旦你使用一个或者多个track创建一个composition，那么你就可以开始将你的媒体数据media数据添加到合适的tracks上。为了将媒体数据添加到一个composition track，你需要使用AVAsset对象（媒体数据存储在这个对象内部）。你可以在某个track上使用mutable composition track接口来将多个具有相同隐含媒体类型的`track`放到一起。接下来的例子说明了怎样将两种video asset track按序放到某种composition track中：</div><div class="line"></div><div class="line">```objc</div><div class="line"></div><div class="line">// You can retrieve AVAssets from a number of places, like the camera roll for</div><div class="line">example.</div><div class="line">AVAsset *videoAsset = &lt;#AVAsset with at least one video track#&gt;;</div><div class="line">AVAsset *anotherVideoAsset = &lt;#another AVAsset with at least one video track#&gt;;</div><div class="line"></div><div class="line">// Get the first video track from each asset.</div><div class="line">AVAssetTrack *videoAssetTrack = [[videoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0]; </div><div class="line">AVAssetTrack *anotherVideoAssetTrack = [[anotherVideoAsset</div><div class="line">tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];</div><div class="line"></div><div class="line">// Add them both to the composition.</div><div class="line">[mutableCompositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,videoAssetTrack.timeRange.duration)</div><div class="line">ofTrack:videoAssetTrack atTime:kCMTimeZero error:nil];</div><div class="line"></div><div class="line">[mutableCompositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,anotherVideoAssetTrack.timeRange.duration) ofTrack:anotherVideoAssetTrack atTime:videoAssetTrack.timeRange.duration error:nil]; </div><div class="line"></div><div class="line">```   </div><div class="line"></div><div class="line">### 检索兼容的Composition Track</div><div class="line"></div><div class="line">如果可能的话，你应该对每一种媒体类型仅有一个composition track。可兼容asset track的统一可以将资源的利用降低到最少。当序列地展示媒体数据的时候，你应该将任何相同类型的媒体数据都放到同一个compsition track中。你可以查询一个mutable composition来找出和你需要的asset track相兼容的任何composition track：</div><div class="line"></div><div class="line">```objc</div><div class="line">AVMutableCompositionTrack *compatibleCompositionTrack = [mutableComposition</div><div class="line">mutableTrackCompatibleWithTrack:&lt;#the AVAssetTrack you want to insert#&gt;];</div><div class="line">if (compatibleCompositionTrack) &#123;</div><div class="line">    // Implementation continues.</div><div class="line">&#125; </div><div class="line">```   </div><div class="line"></div><div class="line">*注：将多个视频片段放到同一个composition track，在过个媒体片段转换时可能会隐性的造成掉帧现象，这种情况在嵌入式设备中尤其明显。对你的视频片段选择合适的合成track完全取决于你App的设计以及其将要展示的平台*</div><div class="line"></div><div class="line">###  生成音量坡度（Volume Ramp）</div><div class="line"></div><div class="line">在你的composition中，一个简单的`AVMutableAudioMix`对象可以单独对所有的音频track进行常用的音频处理。在你合成的过程中，使用`audioMix`类方法来创建一个audio mix，然后使用`AVMutableAudioMixInputParameters`实例来将这个audio mix和特定的track相关联。接下来的例子将会说明说明如何在一个指定的`audio track`上设置一个音量坡度来让音量在合成的过程中缓慢的消失。</div><div class="line"></div><div class="line">```objc</div><div class="line">AVMutableAudioMix *mutableAudioMix = [AVMutableAudioMix audioMix];</div><div class="line">// Create the audio mix input parameters object.</div><div class="line">AVMutableAudioMixInputParameters *mixParameters = [AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack]; </div><div class="line">// Set the volume ramp to slowly fade the audio out over the duration of the</div><div class="line">composition.</div><div class="line">[mixParameters setVolumeRampFromStartVolume:1.f toEndVolume:0.f</div><div class="line">timeRange:CMTimeRangeMake(kCMTimeZero, mutableComposition.duration)];</div><div class="line">// Attach the input parameters to the audio mix.</div><div class="line">mutableAudioMix.inputParameters = @[mixParameters];</div><div class="line">```    </div><div class="line"></div><div class="line">### 运用透明度坡度（Opacity Ramp）</div><div class="line"></div><div class="line">视频合成指令也可以用于视频和成Layer指令。一个`AVMutableVideoCompsitionLayerInstruction`对象可以对某个composition内部的某个video track使用旋转，旋转坡度，透明度，透明度坡度。某个视频合成指令的`layerInstructions`数组中layer指令的顺序决定了合成指令的过程中，来自source track的视频帧怎样被分层堆放，怎样被合成。在接下来的代码片段说明了怎样设置透明度坡度来在第一个视频结束切换第二个视频的时候产生缓慢消失的效果。</div><div class="line"></div><div class="line">```objc</div><div class="line">AVAsset *firstVideoAssetTrack = &lt;#AVAssetTrack representing the first video segment played in the composition#&gt;; </div><div class="line">AVAsset *secondVideoAssetTrack = &lt;#AVAssetTrack representing the second video</div><div class="line">  segment played in the composition#&gt;;</div><div class="line">  </div><div class="line">// Create the first video composition instruction.</div><div class="line">AVMutableVideoCompositionInstruction *firstVideoCompositionInstruction =</div><div class="line">[AVMutableVideoCompositionInstruction videoCompositionInstruction];</div><div class="line"></div><div class="line">// Set its time range to span the duration of the first video track.</div><div class="line">  firstVideoCompositionInstruction.timeRange = CMTimeRangeMake(kCMTimeZero,</div><div class="line">  firstVideoAssetTrack.timeRange.duration);</div><div class="line">  </div><div class="line">// Create the layer instruction and associate it with the composition video track. </div><div class="line">  AVMutableVideoCompositionLayerInstruction *firstVideoLayerInstruction =</div><div class="line">  [AVMutableVideoCompositionLayerInstruction</div><div class="line">  videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack];</div><div class="line">  </div><div class="line">// Create the opacity ramp to fade out the first video track over its entire duration.</div><div class="line"> [firstVideoLayerInstruction setOpacityRampFromStartOpacity:1.f toEndOpacity:0.f</div><div class="line">  timeRange:CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration)];</div><div class="line">  </div><div class="line">// Create the second video composition instruction so that the second video track isn't transparent.</div><div class="line"> AVMutableVideoCompositionInstruction *secondVideoCompositionInstruction =</div><div class="line"> [AVMutableVideoCompositionInstruction videoCompositionInstruction];</div><div class="line">  </div><div class="line">// Set its time range to span the duration of the second video track.</div><div class="line">secondVideoCompositionInstruction.timeRange =</div><div class="line">  CMTimeRangeMake(firstVideoAssetTrack.timeRange.duration,</div><div class="line">  CMTimeAdd(firstVideoAssetTrack.timeRange.duration,</div><div class="line">  secondVideoAssetTrack.timeRange.duration));</div><div class="line">  </div><div class="line">// Create the second layer instruction and associate it with the composition video track.</div><div class="line"> AVMutableVideoCompositionLayerInstruction *secondVideoLayerInstruction =</div><div class="line">  [AVMutableVideoCompositionLayerInstruction</div><div class="line">  videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack];</div><div class="line">  </div><div class="line">// Attach the first layer instruction to the first video composition instruction.</div><div class="line">firstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction]; </div><div class="line"></div><div class="line">// Attach the second layer instruction to the second video composition instruction. </div><div class="line">secondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction]; </div><div class="line"></div><div class="line">// Attach both of the video composition instructions to the video composition.</div><div class="line">  mutableVideoComposition.instructions = @[firstVideoCompositionInstruction,</div><div class="line">  secondVideoCompositionInstruction];</div><div class="line">```   </div><div class="line"></div><div class="line">### 加入核心动画效果</div><div class="line"></div><div class="line">通过使用`animationTool`属性，你可以在合成视频的时候添加核心动画效果。通过这个animation tool，你可以完成给视频添加水印，添加标题或者动画覆盖。在视频合成过程中，核心动画有两种不同的使用方式：你可以在它自己composition track的视频帧中添加一个Core Animation layer,或者你可以直接使用（Core Animation layer）来渲染核心动画效果。接下来的代码展示了怎样使用第二种方式在视频的中间来添加一个水印。</div><div class="line"></div><div class="line">```objc </div><div class="line">CALayer *watermarkLayer = &lt;#CALayer representing your desired watermark image#&gt;;</div><div class="line">CALayer *parentLayer = [CALayer layer];</div><div class="line">CALayer *videoLayer = [CALayer layer];</div><div class="line">parentLayer.frame = CGRectMake(0, 0, mutableVideoComposition.renderSize.width,</div><div class="line">mutableVideoComposition.renderSize.height);</div><div class="line">videoLayer.frame = CGRectMake(0, 0, mutableVideoComposition.renderSize.width,</div><div class="line">mutableVideoComposition.renderSize.height);</div><div class="line">[parentLayer addSublayer:videoLayer];</div><div class="line">watermarkLayer.position = CGPointMake(mutableVideoComposition.renderSize.width/2,</div><div class="line"> mutableVideoComposition.renderSize.height/4);</div><div class="line">[parentLayer addSublayer:watermarkLayer];</div><div class="line">mutableVideoComposition.animationTool = [AVVideoCompositionCoreAnimationTool</div><div class="line">videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer:videoLayer</div><div class="line">inLayer:parentLayer];</div><div class="line">```   </div><div class="line"></div><div class="line">## 综合：综合各种Assets并且保存到Camera Roll中</div><div class="line"></div><div class="line">接下来的代码例子说明了如何将两个视频asset track和一个音频asset track综合来创建一个简单的video file。它的主要功能有</div><div class="line"></div><div class="line">* 创建一个`AVMutableComposition`对象并且添加很多的`AVMutableCompositionTrack`对象</div><div class="line">* 给可兼容的composition track通过`AVAssetTrack`对象添加时间范围</div><div class="line">* 检查一个video asset的`preferredTransform`属性来确定视频的方向</div><div class="line">* 在一个合成过程中使用`AVMutableVideoCompositionLayerInstruction`对象来对一个视频track实现旋转效果</div><div class="line">* 给一个video composition对象设置合适的`renderSize`和`frameDuration`属性值。</div><div class="line">* 在导出视频文件的时候使用合成结合另一个视频合成</div><div class="line">* 将视频文件导出到`Camera Roll`文件中</div><div class="line"></div><div class="line">*注：为了展示最关键的代码，该实例略去了一个完整的应用所需要的功能点，比如：内存管理，注销观察者（对KVO的观察或者对某个通知的监听）。为了能够很好的使用AV Foundation，你需要对Cocoa有丰富的经验，以便处理可能遗漏的功能点。*</div><div class="line"></div><div class="line">### 创建Composition </div><div class="line"></div><div class="line">为了将几个不同的assets创建放到一起，你可以使用一个`AVMutableComposition`对象。创建这个composition并且将一个音频和视频track添加进去。</div><div class="line"></div><div class="line">```objc</div><div class="line">AVMutableComposition *mutableComposition = [AVMutableComposition composition];</div><div class="line">AVMutableCompositionTrack *videoCompositionTrack = [mutableComposition</div><div class="line">addMutableTrackWithMediaType:AVMediaTypeVideo</div><div class="line">preferredTrackID:kCMPersistentTrackID_Invalid];</div><div class="line">AVMutableCompositionTrack *audioCompositionTrack = [mutableComposition</div><div class="line">addMutableTrackWithMediaType:AVMediaTypeAudio</div><div class="line">preferredTrackID:kCMPersistentTrackID_Invalid];</div><div class="line">```  </div><div class="line"></div><div class="line">### 添加Assets</div><div class="line"></div><div class="line">一个空的composition没有什么作用。添加两个video asset track和audio asset track到这个composition中。</div><div class="line"></div><div class="line">```objc</div><div class="line">AVAssetTrack *firstVideoAssetTrack = [[firstVideoAsset</div><div class="line">tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];</div><div class="line">AVAssetTrack *secondVideoAssetTrack = [[secondVideoAsset</div><div class="line">tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];</div><div class="line">[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,</div><div class="line">firstVideoAssetTrack.timeRange.duration) ofTrack:firstVideoAssetTrack</div><div class="line">atTime:kCMTimeZero error:nil];</div><div class="line">[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,</div><div class="line">secondVideoAssetTrack.timeRange.duration) ofTrack:secondVideoAssetTrack</div><div class="line">atTime:firstVideoAssetTrack.timeRange.duration error:nil];</div><div class="line">[audioCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration)) ofTrack:[[audioAsset tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0] atTime:kCMTimeZero error:nil]; </div><div class="line">```  </div><div class="line"></div><div class="line">*注：假设你有两个assets，它们每一个至少包含了一个video track，第三个asset中至少包含了一个audio track。这个视频可以从Camera Roll中获取，audio track可以从音乐库或者视频自己的audio tack中获取。*</div><div class="line"></div><div class="line">### 检测视频方向</div><div class="line"></div><div class="line">一旦你将音频和视频track添加到这个composition中，你需要确保两个video track的方向正确的。默认情况下，所有的视频track假定都是水平模式的。如果你的video track在竖直模式拍摄，那么当它们输出的时候是不能被正确输出的。同样的，如果你试图将一个竖直模式的视频和一个水平模式的视频合成一个视频，那么这个输出的session就会失败。</div><div class="line"></div><div class="line">```objc</div><div class="line">BOOL isFirstVideoPortrait = NO;</div><div class="line">CGAffineTransform firstTransform = firstVideoAssetTrack.preferredTransform;</div><div class="line"></div><div class="line">// Check the first video track's preferred transform to determine if it was recorded in portrait mode. </div><div class="line">if (firstTransform.a == 0 &amp;&amp; firstTransform.d == 0 &amp;&amp; (firstTransform.b == 1.0 ||</div><div class="line"> firstTransform.b == -1.0) &amp;&amp; (firstTransform.c == 1.0 || firstTransform.c ==</div><div class="line">-1.0)) &#123;</div><div class="line">    isFirstVideoPortrait = YES;</div><div class="line">&#125; </div><div class="line">BOOL isSecondVideoPortrait = NO;</div><div class="line">CGAffineTransform secondTransform = secondVideoAssetTrack.preferredTransform;</div><div class="line"></div><div class="line">// Check the second video track's preferred transform to determine if it was</div><div class="line">recorded in portrait mode.</div><div class="line">if (secondTransform.a == 0 &amp;&amp; secondTransform.d == 0 &amp;&amp; (secondTransform.b == 1.0</div><div class="line"> || secondTransform.b == -1.0) &amp;&amp; (secondTransform.c == 1.0 || secondTransform.c</div><div class="line">== -1.0)) &#123;</div><div class="line">    isSecondVideoPortrait = YES;</div><div class="line">&#125; </div><div class="line">if ((isFirstVideoAssetPortrait &amp;&amp; !isSecondVideoAssetPortrait) ||</div><div class="line">(!isFirstVideoAssetPortrait &amp;&amp; isSecondVideoAssetPortrait)) &#123;</div><div class="line">    UIAlertView *incompatibleVideoOrientationAlert = [[UIAlertView alloc]</div><div class="line">initWithTitle:@"Error!" message:@"Cannot combine a video shot in portrait mode</div><div class="line">with a video shot in landscape mode." delegate:self cancelButtonTitle:@"Dismiss"</div><div class="line">otherButtonTitles:nil];</div><div class="line">    [incompatibleVideoOrientationAlert show];</div><div class="line">return; </div><div class="line">&#125; </div><div class="line">```   </div><div class="line"></div><div class="line">### 使用视频合成层指令</div><div class="line"></div><div class="line">一旦你知道视频片段有可兼容的视频方向，那么你就可以对每个视频段使用必要的图层指令来，并且将这些图层指令添加到视频合成中。</div><div class="line"></div><div class="line">```objc    </div><div class="line">BOOL isFirstVideoPortrait = NO;</div><div class="line">CGAffineTransform firstTransform = firstVideoAssetTrack.preferredTransform;</div><div class="line">// Check the first video track's preferred transform to determine if it was recorded in portrait mode. </div><div class="line">if (firstTransform.a == 0 &amp;&amp; firstTransform.d == 0 &amp;&amp; (firstTransform.b == 1.0 ||</div><div class="line"> firstTransform.b == -1.0) &amp;&amp; (firstTransform.c == 1.0 || firstTransform.c ==</div><div class="line">-1.0)) &#123;</div><div class="line">    isFirstVideoPortrait = YES;</div><div class="line">&#125; </div><div class="line">BOOL isSecondVideoPortrait = NO;</div><div class="line">CGAffineTransform secondTransform = secondVideoAssetTrack.preferredTransform;</div><div class="line">// Check the second video track's preferred transform to determine if it was</div><div class="line">recorded in portrait mode.</div><div class="line">if (secondTransform.a == 0 &amp;&amp; secondTransform.d == 0 &amp;&amp; (secondTransform.b == 1.0</div><div class="line"> || secondTransform.b == -1.0) &amp;&amp; (secondTransform.c == 1.0 || secondTransform.c</div><div class="line">== -1.0)) &#123;</div><div class="line">    isSecondVideoPortrait = YES;</div><div class="line">&#125; </div><div class="line">if ((isFirstVideoAssetPortrait &amp;&amp; !isSecondVideoAssetPortrait) ||</div><div class="line">(!isFirstVideoAssetPortrait &amp;&amp; isSecondVideoAssetPortrait)) &#123;</div><div class="line">    UIAlertView *incompatibleVideoOrientationAlert = [[UIAlertView alloc]</div><div class="line">initWithTitle:@"Error!" message:@"Cannot combine a video shot in portrait mode</div><div class="line">with a video shot in landscape mode." delegate:self cancelButtonTitle:@"Dismiss"</div><div class="line">otherButtonTitles:nil];</div><div class="line">    [incompatibleVideoOrientationAlert show];</div><div class="line">return; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的<code>AVAssetTrack</code>对象都有一个<code>preferredTransform</code>属性，该属性中包含了这个asset track对象的方向信息。只要这个asset track在屏幕上展示，那么这个<code>transform</code>都将会被使用。在上面的代码中，这个<code>layer instruction transform</code>被设置成了这个<code>asset track</code>的transform，以便于这个视频在新的合成中一旦调整渲染尺寸，仍然可以正常展示。</p>
<h3 id="设置渲染尺寸和帧时长"><a href="#设置渲染尺寸和帧时长" class="headerlink" title="设置渲染尺寸和帧时长"></a>设置渲染尺寸和帧时长</h3><p>为了将视频的方向固定，你必须响应地调整<code>renderSize</code>属性。你也应该对<code>frameDuration</code>属性挑选一个合适的值。比如每秒钟30次（或者30帧每秒）。默认情况下，renderScale属性被设置为1.0，这在本次合成过程中是合适的。</p>
<pre><code class="objc">  <span class="built_in">CGSize</span> naturalSizeFirst, naturalSizeSecond;
  <span class="comment">// If the first video asset was shot in portrait mode, then so was the second one</span>
   <span class="keyword">if</span> we made it here.
  <span class="keyword">if</span> (isFirstVideoAssetPortrait) {
  <span class="comment">// Invert the width and height for the video tracks to ensure that they display</span>
  properly.
      naturalSizeFirst = <span class="built_in">CGSizeMake</span>(firstVideoAssetTrack.naturalSize.height,
  firstVideoAssetTrack.naturalSize.width);
      naturalSizeSecond = <span class="built_in">CGSizeMake</span>(secondVideoAssetTrack.naturalSize.height,
  secondVideoAssetTrack.naturalSize.width);
} <span class="keyword">else</span> { 
  <span class="comment">// If the videos weren't shot in portrait mode, we can just use their natural</span>
  sizes.
      naturalSizeFirst = firstVideoAssetTrack.naturalSize;
      naturalSizeSecond = secondVideoAssetTrack.naturalSize;
  }
  <span class="keyword">float</span> renderWidth, renderHeight;
  <span class="comment">// Set the renderWidth and renderHeight to the max of the two videos widths and</span>
  heights.
  <span class="keyword">if</span> (naturalSizeFirst.width &gt; naturalSizeSecond.width) {
      renderWidth = naturalSizeFirst.width;
} <span class="keyword">else</span> { 
      renderWidth = naturalSizeSecond.width;
  }
  <span class="keyword">if</span> (naturalSizeFirst.height &gt; naturalSizeSecond.height) {
      renderHeight = naturalSizeFirst.height;
} <span class="keyword">else</span> { 
      renderHeight = naturalSizeSecond.height;
  }

 mutableVideoComposition.renderSize = <span class="built_in">CGSizeMake</span>(renderWidth, renderHeight);
  <span class="comment">// Set the frame duration to an appropriate value (i.e. 30 frames per second for</span>
  video).
 mutableVideoComposition.frameDuration = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>,<span class="number">30</span>);
</code></pre>
<h3 id="导出合成，并且将它保存到Camera-Roll中"><a href="#导出合成，并且将它保存到Camera-Roll中" class="headerlink" title="导出合成，并且将它保存到Camera Roll中"></a>导出合成，并且将它保存到Camera Roll中</h3><p>在该过程的最后一个步骤设计到将整个合成保存到一个单独的视频文件，并且将视频存储到Camera Roll中。你可以使用<code>AVAssetExportSession</code>对象来创建这个新的video文件，然后你将它传递到输出文件期望的<code>URL</code>中。然后使用<code>ALAssetLibrary</code>对象来保存这个结果视频文件到Camera Roll中。</p>
<pre><code class="objc"><span class="comment">// Create a static date formatter so we only have to initialize it once.</span>
  <span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *kDateFormatter;
  <span class="keyword">if</span> (!kDateFormatter) {
      kDateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];
      kDateFormatter.dateStyle = <span class="built_in">NSDateFormatterMediumStyle</span>;
      kDateFormatter.timeStyle = <span class="built_in">NSDateFormatterShortStyle</span>;
} 

<span class="comment">// Create the export session with the composition and set the preset to the highest quality. </span>
  <span class="built_in">AVAssetExportSession</span> *exporter = [[<span class="built_in">AVAssetExportSession</span> alloc]
  initWithAsset:mutableComposition presetName:<span class="built_in">AVAssetExportPresetHighestQuality</span>];

<span class="comment">// Set the desired output URL for the file created by the export process.</span>
exporter.outputURL = [[[[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> 
create:@YES error:<span class="literal">nil</span>] URLByAppendingPathComponent:[kDateFormatter stringFromDate:[<span class="built_in">NSDate</span> date]]] URLByAppendingPathExtension:<span class="built_in">CFBridgingRelease</span>(UTTypeCopyPreferredTagWithClass((<span class="built_in">CFStringRef</span>)<span class="built_in">AVFileTypeQuickTimeMovie</span>, 
   kUTTagClassFilenameExtension))];

<span class="comment">// Set the output file type to be a QuickTime movie.</span>
  exporter.outputFileType = <span class="built_in">AVFileTypeQuickTimeMovie</span>;
  exporter.shouldOptimizeForNetworkUse = <span class="literal">YES</span>;
  exporter.videoComposition = mutableVideoComposition;

<span class="comment">// Asynchronously export the composition to a video file and save this file to the camera roll once export completes. </span>
 [exporter exportAsynchronouslyWithCompletionHandler:^{
      <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
          <span class="keyword">if</span> (exporter.status == <span class="built_in">AVAssetExportSessionStatusCompleted</span>) {

 ALAssetsLibrary *assetsLibrary = [[ALAssetsLibrary alloc] init];
              <span class="keyword">if</span> ([assetsLibrary
  videoAtPathIsCompatibleWithSavedPhotosAlbum:exporter.outputURL]) {

[assetsLibrary writeVideoAtPathToSavedPhotosAlbum:exporter.outputURL completionBlock:<span class="literal">NULL</span>]; 
         } 
      } 
   }); 
}];
</code></pre>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/23/sdwebimage-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/23/sdwebimage-1/" itemprop="url">从SDWebImage中学到的（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-23T09:52:09+08:00">
                2017-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文是根据SDWebImage，Tag2.0到Tag2.6所做的总结。</p>
<h2 id="注意判空"><a href="#注意判空" class="headerlink" title="注意判空"></a>注意判空</h2><p>为了安全起见，方法中每个参数的值的异常我们都需考虑到，我们要有一个guard，然后直接返回，否则在某些特殊情况下，比如这个参数是服务端返回的，某次服务端没有返回，就会崩溃，加了guard之后就不会了，在swift中加入了<code>guard</code>关键字来做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">guard</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 变量不符合条件判断,则返回</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">```     </div><div class="line"></div><div class="line">因为在<span class="type">OC</span>中没有这样的判断，所以我们需要添加如下的代码：</div><div class="line">```objc </div><div class="line">  <span class="keyword">if</span> (!url)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">self</span>.image = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">```   </div><div class="line"></div><div class="line">## 针对某个机型做接口适配</div><div class="line"></div><div class="line">如果某个机型的手机需要做一些特殊处理，我们可以这么做：</div><div class="line"></div><div class="line">```objc</div><div class="line"> #ifdef __IPHONE_4_0</div><div class="line"> <span class="type">UIDevice</span> *device = [<span class="type">UIDevice</span> currentDevice];</div><div class="line">        <span class="keyword">if</span> ([device respondsToSelector:@selector(isMultitaskingSupported)] &amp;&amp; device.multitaskingSupported)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// When in background, clean memory in order to have less chance to be killed</span></div><div class="line">            [[<span class="type">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">                                                     selector:@selector(clearMemory)</div><div class="line">                                                         name:<span class="type">UIApplicationDidEnterBackgroundNotification</span></div><div class="line">                                                       object:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">```   </div><div class="line"></div><div class="line">这样一来就只有iPhone4会执行里面的代码（__IPHONE_4_0是系统自带的宏）。</div><div class="line"></div><div class="line">## 多线程中如何使用`<span class="type">NSFileManager</span>`</div><div class="line"></div><div class="line">如果某个方法是在后台线程中执行的，并且这个线程中使用了`<span class="type">NSFileManager</span>`，为了避免资源竞争，需要使用`[[<span class="type">NSFileManager</span> alloc] <span class="keyword">init</span>]`的方式进行初始化：</div><div class="line"></div><div class="line">```objc</div><div class="line">  <span class="comment">// Can't use defaultManager another thread</span></div><div class="line">    <span class="type">NSFileManager</span> *fileManager = [[<span class="type">NSFileManager</span> alloc] <span class="keyword">init</span>];</div><div class="line">```   </div><div class="line"></div><div class="line">## 存储图片时候不改变其图片类型</div><div class="line"></div><div class="line">如果我们在存储图片的时候要存储成某种格式的图片类型，那么可以使用：</div><div class="line"></div><div class="line">```objc</div><div class="line"> [fileManager createFileAtPath:[<span class="keyword">self</span> cachePathForKey:key] contents:<span class="type">UIImageJPEGRepresentation</span>(image, (<span class="type">CGFloat</span>)<span class="number">1.0</span>) attributes:<span class="literal">nil</span>];</div><div class="line">```   </div><div class="line"></div><div class="line">如果我们不想改变存储时候的数据类型，那么可以使用：</div><div class="line"></div><div class="line">```objc</div><div class="line">   [fileManager createFileAtPath:[<span class="keyword">self</span> cachePathForKey:key] contents:data attributes:<span class="literal">nil</span>];</div><div class="line">```   </div><div class="line"></div><div class="line">来完成。</div><div class="line"></div><div class="line">## 在<span class="type">NSOperationQueue</span>中添加立即执行的任务</div><div class="line"></div><div class="line">如果要在<span class="type">NSOperationQueue</span>中添加要立即执行的任务，那么可以这样做：</div><div class="line"></div><div class="line">```objc</div><div class="line">[cacheOutQueue addOperation:[[[<span class="type">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:@selector(queryDiskCacheOperation:) object:arguments]</div><div class="line">```   </div><div class="line"></div><div class="line"></div><div class="line">## 头文件引入过多</div><div class="line"></div><div class="line">如果我们的头文件引入过多，那么我们需要将这些头文件都放到一个新的文件中去，然后引入那个单独的文件即可，比如<span class="type">SDWebImageCompat</span>文件的存在就是为了解决这个问题：</div><div class="line"></div><div class="line">```objc</div><div class="line">#<span class="keyword">import</span> &lt;TargetConditionals.h&gt;</div><div class="line">#<span class="keyword">if</span> !<span class="type">TARGET_OS_IPHONE</span></div><div class="line">#<span class="keyword">import</span> &lt;AppKit/AppKit.h&gt;</div><div class="line">#ifndef <span class="type">UIImage</span></div><div class="line">#define <span class="type">UIImage</span> <span class="type">NSImage</span></div><div class="line">#endif</div><div class="line">#ifndef <span class="type">UIImageView</span></div><div class="line">#define <span class="type">UIImageView</span> <span class="type">NSImageView</span></div><div class="line">#endif</div><div class="line">#<span class="keyword">else</span></div><div class="line">#<span class="keyword">import</span> &lt;UIKit/UIKit.h&gt;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<h2 id="从数组中找到指向同一块内存空间的指针"><a href="#从数组中找到指向同一块内存空间的指针" class="headerlink" title="从数组中找到指向同一块内存空间的指针"></a>从数组中找到指向同一块内存空间的指针</h2><p>如果要从数组中找到数值相同的指针，我们可以使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">    <span class="built_in">NSUInteger</span> idx = [cacheDelegates indexOfObjectIdenticalTo:delegate];</div><div class="line">    <span class="keyword">if</span> (idx == <span class="built_in">NSNotFound</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Request has since been canceled</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">```     </div><div class="line"></div><div class="line">这种形式，但是要注意没有找到时候的处理。</div><div class="line"></div><div class="line"><span class="meta">## UIImage的解压缩</span></div><div class="line"></div><div class="line">PNG和JPEG等只是一种图片压缩格式，PNG是无损压缩，含有alpha通道，JPEG是有损压缩，没有alpha通道。我们每次展示图片的时候都需要先将<span class="built_in">UIImage</span>进行解压缩。解压缩默认是在主线程中进行的，如果图片较大则会造成很大的性能消耗，如果在IO线程中进行则会提高性能，框架中使用的方式是：</div><div class="line"></div><div class="line">```objc</div><div class="line"><span class="built_in">CGImageRef</span> imageRef = image.CGImage;</div><div class="line"><span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line"><span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</div><div class="line">                                                 <span class="built_in">CGImageGetWidth</span>(imageRef),</div><div class="line">                                                 <span class="built_in">CGImageGetHeight</span>(imageRef),</div><div class="line">                                                 <span class="number">8</span>,</div><div class="line">                                                 <span class="comment">// Just always return width * 4 will be enough</span></div><div class="line">                                                 <span class="built_in">CGImageGetWidth</span>(imageRef) * <span class="number">4</span>,</div><div class="line">                                                 <span class="comment">// System only supports RGB, set explicitly</span></div><div class="line">                                                 colorSpace,</div><div class="line">                                                 <span class="comment">// Makes system don't need to do extra conversion when displayed.</span></div><div class="line">                                                 kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Little); </div><div class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">    <span class="keyword">if</span> (!context) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>, <span class="built_in">CGImageGetWidth</span>(imageRef), <span class="built_in">CGImageGetHeight</span>(imageRef)&#125;;</div><div class="line">    <span class="built_in">CGContextDrawImage</span>(context, rect, imageRef);</div><div class="line">    <span class="built_in">CGImageRef</span> decompressedImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</div><div class="line">    <span class="built_in">CGContextRelease</span>(context);</div><div class="line"></div><div class="line">    <span class="built_in">UIImage</span> *decompressedImage = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:decompressedImageRef];</div><div class="line">    <span class="built_in">CGImageRelease</span>(decompressedImageRef);</div><div class="line">    <span class="keyword">return</span> [decompressedImage autorelease];</div><div class="line">```     </div><div class="line"></div><div class="line">关于<span class="built_in">UIImage</span>的解压缩，可以参考相关文章：</div><div class="line">[怎样避免<span class="built_in">UIImage</span>解压缩造成的性能消耗？](https:<span class="comment">//www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/)，[IOS中的图片解压缩](http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/)，[UIImage解压缩的两种形式](https://stackoverflow.com/questions/19682804/why-does-this-code-decompress-a-uiimage-so-much-better-than-the-naive-approach)，[谈谈IOS中图片的解压缩](http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/)</span></div><div class="line"></div><div class="line"><span class="meta">## 怎样获取某个目录下的文件大小？</span></div><div class="line"></div><div class="line">```objc</div><div class="line">-(<span class="keyword">int</span>)getSize</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">    <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [[<span class="built_in">NSFileManager</span> defaultManager] enumeratorAtPath:diskCachePath];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *fileName <span class="keyword">in</span> fileEnumerator)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSString</span> *filePath = [diskCachePath stringByAppendingPathComponent:fileName];</div><div class="line">        <span class="built_in">NSDictionary</span> *attrs = [[<span class="built_in">NSFileManager</span> defaultManager] attributesOfItemAtPath:filePath error:<span class="literal">nil</span>];</div><div class="line">        size += [attrs fileSize];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125; </div><div class="line">```  </div><div class="line"></div><div class="line"><span class="meta">## Struct初始化</span></div><div class="line"></div><div class="line">在某些情况下，Struct可以使用如下的方法进行初始化：</div><div class="line"></div><div class="line">```objc</div><div class="line"><span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>, &#123; <span class="built_in">CGImageGetWidth</span>(imageRef), <span class="built_in">CGImageGetHeight</span>(imageRef) &#125;&#125;;</div></pre></td></tr></table></figure>
<h2 id="调用方法是需要注意"><a href="#调用方法是需要注意" class="headerlink" title="调用方法是需要注意"></a>调用方法是需要注意</h2><p>在某种特殊情况下，调用方法前要判断是否该对象具有某个方法，以免引起崩溃：</p>
<pre><code class="objc">-    <span class="keyword">if</span> ([((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] &gt;= <span class="number">400</span>)
+    <span class="keyword">if</span> ([response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] &amp;&amp; [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] &gt;= <span class="number">400</span>)
</code></pre>
<p>因为在上述代码中<code>response</code>可能不是HTTP的response。</p>
<h2 id="ImageIO实现图片边下边展示效果"><a href="#ImageIO实现图片边下边展示效果" class="headerlink" title="ImageIO实现图片边下边展示效果"></a>ImageIO实现图片边下边展示效果</h2><p>实现渐下渐放效果是在<code>SDWebImageDownloader.m</code>文件的<code>- (void)connection:(NSURLConnection *)aConnection didReceiveData:(NSData *)data{}</code>方法中。其中的关键代码为：</p>
<pre><code class="objc"> <span class="comment">/// Create the image</span>
            <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);

<span class="meta">#ifdef TARGET_OS_IPHONE</span>
            <span class="comment">// Workaround for iOS anamorphic image</span>
            <span class="keyword">if</span> (partialImageRef)
            {
                <span class="keyword">const</span> size_t partialHeight = <span class="built_in">CGImageGetHeight</span>(partialImageRef);
                <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();
                <span class="built_in">CGContextRef</span> bmContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, width * <span class="number">4</span>, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);
                <span class="built_in">CGColorSpaceRelease</span>(colorSpace);
                <span class="keyword">if</span> (bmContext)
                {
                    <span class="built_in">CGContextDrawImage</span>(bmContext, (<span class="built_in">CGRect</span>){.origin.x = <span class="number">0.0</span>f, .origin.y = <span class="number">0.0</span>f, .size.width = width, .size.height = partialHeight}, partialImageRef);
                    <span class="built_in">CGImageRelease</span>(partialImageRef);
                    partialImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(bmContext);
                    <span class="built_in">CGContextRelease</span>(bmContext);
                }
                <span class="keyword">else</span>
                {
                    <span class="built_in">CGImageRelease</span>(partialImageRef);
                    partialImageRef = <span class="literal">nil</span>;
                }
            }
</code></pre>
<p>然后根据<code>CGImageRef</code>生成对应的<code>UIImage</code>并且将结果返回给delegate：</p>
<pre><code class="objc"><span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:partialImageRef];
[delegate imageDownloader:<span class="keyword">self</span> didUpdatePartialImage:image];
</code></pre>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/14/wwdc-protocol-value-type-uikit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/wwdc-protocol-value-type-uikit/" itemprop="url">怎样在UIKit中更好的使用ValueType</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-14T09:06:45+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ValueType怎样用到UIView中？"><a href="#ValueType怎样用到UIView中？" class="headerlink" title="ValueType怎样用到UIView中？"></a>ValueType怎样用到UIView中？</h2><p><strong>如果两个类没有相同的父类，我们又想对它们写一个相同的逻辑</strong>，怎么办？我们可以让它们遵守同一个协议，该协议中有它们共有的属性，然后就可以复用了。这样我们就依赖Protocol而不是SuperClassl来建立一个多态。<br>分享代码不必使用继承了：<br>UIView的组合不是最优的，因为UIView的创建需要很长的时间，并且需要开辟堆空间，需要处理事件。</p>
<p>我们接下来看看怎样利用ValueType将Layout和具体的类进行分开。因为我们可能会用<code>UIView</code>也可能用<code>SKNode</code>来做其ContentView。<br>按照之前的情况，我们可能这样写：  </p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">DecoratingLayoutCell</span> : <span class="title">UITableViewCell</span> </span>{
   <span class="keyword">var</span> content: <span class="type">UIView</span>
   <span class="keyword">var</span> decoration: <span class="type">UIView</span>
   <span class="comment">// Perform layout...</span>
}
</code></pre>
<p>为了将具体的Cell和其Layout分开，我们创建一个Struct：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span> </span>{
   <span class="keyword">var</span> content: <span class="type">UIView</span>
   <span class="keyword">var</span> decoration: <span class="type">UIView</span>   
<span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
   <span class="comment">// Perform layout...</span>
   } 
}
</code></pre>
<p>然后在Cell中我们就可以这样写：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">DreamCell</span> : <span class="title">UITableViewCell</span> </span>{
   ...
   <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> {

   <span class="keyword">var</span> decoratingLayout = <span class="type">DecoratingLayout</span>(content: content, decoration:decoration)
   decoratingLayout.layout(<span class="keyword">in</span>:bounds)
}
</code></pre>
<p>同时，我们可以对UIView也用同样的Layout（封装变化）。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">DreamDetailView</span> : <span class="title">UIView</span> </span>{
   ...
   <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> {
      <span class="keyword">var</span> decoratingLayout = <span class="type">DecoratingLayout</span>(content: content, decoration:decoration)
   decoratingLayout.layout(<span class="keyword">in</span>:bounds)
} }
</code></pre>
<p>将Layout分开之后还非常有利于单元测试，比如我们想要测试我们的Layout创建出来的两个View是否符合我们的预期，我们可以这样：</p>
<pre><code class="Swift"> <span class="keyword">let</span> child1 = <span class="type">UIView</span>()
   <span class="keyword">let</span> child2 = <span class="type">UIView</span>()
   <span class="keyword">var</span> layout = <span class="type">DecoratingLayout</span>(content: child1, decoration: child2)
   layout.layout(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">120</span>, height: <span class="number">40</span>))
} 
<span class="type">XCTAssertEqual</span>(child2.frame, <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">5</span>, width: <span class="number">35</span>, height: <span class="number">30</span>))
<span class="type">XCTAssertEqual</span>(child2.frame, <span class="type">CGRect</span>(x: <span class="number">35</span>, y: <span class="number">5</span>, width: <span class="number">70</span>, height: <span class="number">30</span>))
</code></pre>
<p>因为我们的Layout代码量很小并且和其它代码是隔离的（没有继承，不是Reference Type），那么这样我们就可以很好的做局部分析。</p>
<p>有一天，我们要对SKNode也做同样的操作。所以我们也需要<code>NodeDecoratingLayout</code>：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">ViewDecoratingLayout</span> </span>{
   <span class="keyword">var</span> content: <span class="type">UIView</span>
   <span class="keyword">var</span> decoration: <span class="type">UIView</span>   
<span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
   <span class="comment">// Perform layout...</span>
   } 
} 
<span class="class"><span class="keyword">struct</span> <span class="title">NodeDecoratingLayout</span> </span>{
   <span class="keyword">var</span> content: <span class="type">SKNode</span>
   <span class="keyword">var</span> decoration: <span class="type">SKNode</span>   
<span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
   <span class="comment">// Perform layout...</span>
   content.frame = ....
   decoration.frame = ...
   } 
}
</code></pre>
<p>我们可以看到这和<code>VIewDecoratingLayout</code>是一样的。所以我们要将它封装起来，怎么封装？UIView和SKNode没有共同的父类。因为这两个结构体都有一个属性，那么我们就用一个Layout的<code>Protocol</code>来解决这个问题：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>{
   <span class="keyword">var</span> frame: <span class="type">CGRect</span> {<span class="keyword">get</span> <span class="keyword">set</span>}
}
<span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span> </span>{
   <span class="keyword">var</span> content: <span class="type">Layout</span>
   <span class="keyword">var</span> decoration: <span class="type">Layout</span>
   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
      content.frame = ...
      decoration.frame = ...
   }
}
</code></pre>
<p>然后为了让<code>UIView</code>和<code>SKNode</code>都是用这个<code>Layout</code>，我们只用<code>Protocol Extension</code>。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> : <span class="title">Layout</span></span>{}
<span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span> : <span class="title">Layout</span></span>{}
</code></pre>
<blockquote>
<p>我们用Protocol和Extension实现了多态，而没有使用继承!</p>
</blockquote>
<p> 这样我们的Layout就不必依赖于UIKit了。</p>
<p>但是上面的代码有一个Bug，我们不能保证<code>content</code>和<code>decoration</code>是相同的类型，他们可能一个是<code>UIView</code>，一个是<code>SKNode</code>。我们可以使用<strong>泛型</strong>来解决这个问题。我们可以给<code>DecoratingLayout</code>添加泛型：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span>: <span class="title">Layout</span>&gt; </span>{
   <span class="keyword">var</span> content: <span class="type">Child</span>
   <span class="keyword">var</span> decoration: <span class="type">Child</span>
   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
      content.frame = ...
      decoration.frame = ...
   }
}
</code></pre>
<p>这样我么就可以保证了，content和decoration有相同的类型。使用泛型，可以让编译器对代码有一个更好的理解，然后会对代码做很多的优化。</p>
<p>但是如果出现了更加相似的布局，我们该怎样重用我们的代码呢？比如：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-c5236656635ca10c.png" alt="SimilarLayout"></p>
<p>重用代码，我们最先想到的是继承，但是继承会造成Override及变量的变更，这样我们很难从子类中就明确的推断出代码的含义，那么我们用组合来做这个事情，面对上面的第二张图，我们通常的做法是，创建两个UIView：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-8a14f1f51e4c035c.png" alt="Composition"></p>
<p>但是这样做有弊端的：类对象是很消耗性能的：开辟堆空间，内存管理，除此之外，UIView还有：绘制，事件处理。然而Struct是几乎不消耗性能，并且由于其实Value Type，所以它可以做更好的封装，你不需要关系别人对其进行修改。</p>
<p>我们可以使用如下方式：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">CascadingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>&gt; </span>{
   <span class="keyword">var</span> children: [<span class="type">Child</span>]
   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
... } 
} 
<span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>&gt; </span>{
   <span class="keyword">var</span> content: <span class="type">Child</span>
   <span class="keyword">var</span> decoration: <span class="type">Child</span>
   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
      content.frame = ...
      decoration.frame = ...
   }
}
</code></pre>
<p>这两种方式组合，这里我们不需要<code>Layout</code>协议有frame属性，我们只需要其有<code>layout()</code>方法即可</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>{
 <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>
}
</code></pre>
<p>然后，我们的<code>DecoratingLayout</code>和<code>CascadingLayout</code>遵守该协议即可：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>, ...&gt; : <span class="title">Layout</span> </span>{}
<span class="class"><span class="keyword">struct</span> <span class="title">CascadingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>{}
</code></pre>
<p>这之后我们就可以用组合的方式实现上文提到的UI效果了：</p>
<pre><code class="Swift"><span class="comment">// Composition of Values</span>
<span class="keyword">let</span> decoration = <span class="type">CascadingLayout</span>(children: accessories)
<span class="keyword">var</span> composedLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration)
composedLayout.layout(<span class="keyword">in</span>: rect)
</code></pre>
<p>为了实现这种UIView的叠加效果，我们给Layout协议添加<code>contents</code>属性：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>{
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>
  <span class="keyword">var</span> contents:[<span class="type">Layout</span>]{<span class="keyword">get</span>}  <span class="comment">// 这里可以是UIView或者SKNode</span>
}
</code></pre>
<p>但是这回出现和之前所说的一样的Bug，我们没有办法保证这个contents属性里是否既有UIView还有SKNode，为了解决这个问题，我们加上一个关联属性：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>{
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>
  associatedtype <span class="type">Content</span>
  <span class="keyword">var</span> contents:[<span class="type">Content</span>]{<span class="keyword">get</span>}  <span class="comment">// 这里可以是UIView或者SKNode</span>
}
</code></pre>
<p>然后在<code>DecoratingLayout</code>中，我们这样做：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>{
   ...
   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>
   <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">Child</span>.<span class="type">Content</span>
   <span class="keyword">var</span> contents: [<span class="type">Content</span>] { <span class="keyword">get</span> }
</code></pre>
<p>如果我们要对其中的内容做以限制，那么我们可以这样做：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span>:<span class="title">Layout</span>, <span class="title">Decoration</span>:<span class="title">Layout</span> <span class="title">where</span> <span class="title">Child</span>.<span class="title">Content</span> == <span class="title">Decoration</span>.<span class="title">Content</span>&gt; : <span class="title">Layout</span> </span>{
    <span class="keyword">var</span> content: <span class="type">Child</span>
    <span class="keyword">var</span> decoration: <span class="type">Decoration</span>
    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>
    <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">Child</span>.<span class="type">Content</span>
    <span class="keyword">var</span> contents: [<span class="type">Content</span>] { <span class="keyword">get</span> }
}
</code></pre>
<p>这样我们的单元测试就不必依赖于具体的UIView或者是SKNode：</p>
<pre><code class="Swift">  <span class="function"><span class="keyword">func</span> <span class="title">testLayout</span><span class="params">()</span></span> {
   <span class="keyword">let</span> child1 = <span class="type">TestLayout</span>()
   <span class="keyword">let</span> child2 = <span class="type">TestLayout</span>()
   <span class="keyword">var</span> layout = <span class="type">DecoratingLayout</span>(content: child1, decoration: child2)
   layout.layout(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">120</span>, height: <span class="number">40</span>))
   <span class="type">XCTAssertEqual</span>(layout.contents[<span class="number">0</span>].frame, <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">5</span>, width: <span class="number">35</span>, height: <span class="number">30</span>))
   <span class="type">XCTAssertEqual</span>(layout.contents[<span class="number">1</span>].frame, <span class="type">CGRect</span>(x: <span class="number">35</span>, y: <span class="number">5</span>, width: <span class="number">70</span>, height: <span class="number">30</span>))
}

<span class="class"><span class="keyword">struct</span> <span class="title">TestLayout</span> : <span class="title">Layout</span> </span>{
   <span class="keyword">var</span> frame: <span class="type">CGRect</span>
   ...  
}
</code></pre>
<h2 id="ValueType怎样用到Controller中"><a href="#ValueType怎样用到Controller中" class="headerlink" title="ValueType怎样用到Controller中"></a>ValueType怎样用到Controller中</h2><p>我们增加了Favoriate功能之后，我们的撤销功能消失了。为了隔离我们的Model，我们将其变为一个Struct，并且拥有之前的属性：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>{
   <span class="keyword">var</span> model: <span class="type">Model</span>
... 
} 
<span class="class"><span class="keyword">struct</span> <span class="title">Model</span> : <span class="title">Equatable</span> </span>{
    <span class="keyword">var</span> dreams: [<span class="type">Dream</span>]
    <span class="keyword">var</span> favoriteCreature: <span class="type">Creature</span>
}
</code></pre>
<p>然后将Model和View隔离的做法极其容易出bug，因为我们的Model的任何改变都要对应相应View的位置。<br>我们可以将其合并起来：</p>
<pre><code class="Swift"><span class="comment">/// Diffs the model changes and updates the UI based on the new model.</span>
    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">modelDidChange</span><span class="params">(diff: Model.Diff)</span></span> {
        <span class="comment">// Check to see if we need to update any rows that present a dream.</span>
        <span class="keyword">if</span> diff.hasAnyDreamChanges {
            <span class="keyword">switch</span> diff.dreamChange {
                <span class="keyword">case</span> .inserted?:
                    <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: diff.from.dreams.<span class="built_in">count</span>, section: <span class="type">Section</span>.dreams.rawValue)
                    tableView.insertRows(at: [indexPath], with: .automatic)

                <span class="keyword">case</span> .removed?:
                    <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: diff.from.dreams.<span class="built_in">count</span> - <span class="number">1</span>, section: <span class="type">Section</span>.dreams.rawValue)
                    tableView.deleteRows(at: [indexPath], with: .automatic)

                <span class="keyword">case</span> .updated(<span class="keyword">let</span> indexes)?:
                    <span class="keyword">let</span> indexPaths = indexes.<span class="built_in">map</span> { <span class="type">IndexPath</span>(row: $<span class="number">0</span>, section: <span class="type">Section</span>.dreams.rawValue) }
                    tableView.reloadRows(at: indexPaths, with: .automatic)

                <span class="keyword">case</span> <span class="literal">nil</span>: <span class="keyword">break</span>
            }
        }
</code></pre>
<p>如果我们的UI有各种状态，并且我们要处理这种状态，这时，该怎样处理才比较好呢？比如我们的这个App中有:展示、选择、分享三种状态。这时如果遇到状态的切换就会遇到问题，因为Cell是复用的，所以就会出现忘记清除前一种Cell的状态而引起的Bug。<br>这种情况出现的原因就是我们的ViewController持有了这些不同的状态，如果状态逐渐变多，那么就会有非常复杂的业务逻辑需要处理。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>{
    <span class="keyword">var</span> isInViewingMode: <span class="type">Bool</span>
    <span class="keyword">var</span> sharingDreams: [<span class="type">Dream</span>]?
    <span class="keyword">var</span> selectedRows: <span class="type">IndexSet</span>?
    ... 
}
</code></pre>
<p>因为UI只能出现一种状态，所以每次我们切换状态，我们就需要给其它的两种状态进行置空，这时就很容易引起Bug，为了解决这个问题，我们可以使用<code>Enum</code>来讲这些状态进行封装。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>{
    <span class="keyword">case</span> viewing
    <span class="keyword">case</span> sharing(dreams:[<span class="type">Dream</span>])
    <span class="keyword">case</span> selecting(selectedRows: <span class="type">IndexSet</span>)
}
</code></pre>
<p>这样我们就可以避免因为状态转换而产生的Bug了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/13/server-side-json-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/13/server-side-json-model/" itemprop="url">Vapor制作JSON Model</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-13T18:16:34+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上篇博客中我们讲到了怎样配置数据库，以及怎样将数据库中的数据读出并且返回给客户端，本文将说明怎样将数据库中的数据用Model来表示，并且怎样对Model进行各种操作。</p>
<h2 id="建立Class"><a href="#建立Class" class="headerlink" title="建立Class"></a>建立Class</h2><p>我们建立以个简单的<code>User</code>类，如下：</p>
<pre><code class="Swift"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{
 <span class="keyword">var</span> id: <span class="type">String</span>
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> age: <span class="type">Int</span>
    <span class="keyword">var</span> gender: <span class="type">String</span>
    <span class="keyword">var</span> imageUrl: <span class="type">String</span>
    <span class="keyword">var</span> oatch: <span class="type">String</span>

    <span class="keyword">init</span>(id: <span class="type">String</span>, name: <span class="type">String</span>, age:<span class="type">Int</span>, gender: <span class="type">String</span>, imageUrl: <span class="type">String</span>, oatch: <span class="type">String</span>) 
    {

        <span class="keyword">self</span>.id = id
        <span class="keyword">self</span>.age = age
        <span class="keyword">self</span>.name = name
        <span class="keyword">self</span>.gender = gender
        <span class="keyword">self</span>.imageUrl = imageUrl
        <span class="keyword">self</span>.oatch = oatch
    }
}
</code></pre>
<h2 id="遵守NodeRepresentable和NodeRepresentable协议"><a href="#遵守NodeRepresentable和NodeRepresentable协议" class="headerlink" title="遵守NodeRepresentable和NodeRepresentable协议"></a>遵守NodeRepresentable和NodeRepresentable协议</h2><p>从之前返回JSON时，JSONS的生成过程<code>JSON(node:someNode)</code>，那么Node是什么呢？其实就是一个遵守<code>NodeRepresentable</code>的对象，我们让User遵守<code>NodeRepresentable</code>协议，兵且实现其<code>makeNode</code>方法，这样就可以传入<code>JSON(node:user)</code>了：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">makeNode</span><span class="params">(<span class="keyword">in</span> context: Context?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Node</span> {

        <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">Node</span>(node:[
            <span class="string">"id"</span>:id,
            <span class="string">"name"</span>:name,
            <span class="string">"age"</span>:age,
            <span class="string">"gender"</span>:gender,
            <span class="string">"imageUrl"</span>:imageUrl,
            <span class="string">"oatch"</span>:oatch
            ])
    }
</code></pre>
<p>我们这样不调用<code>JSON</code>的方法，只使用我们的Model就可以创建出来JSON对象呢？我们只需要遵守<code>JSONRepresentable</code>对象即可，然后添加其需要实现的协议方法。</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">makeJSON</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">JSON</span> {
    <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">JSON</span>(node: <span class="keyword">self</span>)
}
</code></pre>
<p>然后我们就可以使用<code>user.makeJSON()</code>来创建JSON对象了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="击水湘江" />
          <p class="site-author-name" itemprop="name">击水湘江</p>
           
              <p class="site-description motion-element" itemprop="description">努力让明天的自己爱上今天的自己！</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">击水湘江</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script>


  

</body>
</html>
