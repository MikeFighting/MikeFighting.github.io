<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.3">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:type" content="website">
<meta property="og:title" content="击水湘江">
<meta property="og:url" content="https://mikefighting.github.io/index.html">
<meta property="og:site_name" content="击水湘江">
<meta property="og:description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="击水湘江">
<meta name="twitter:description" content="努力让明天的自己爱上今天的自己！">






  <link rel="canonical" href="https://mikefighting.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>击水湘江</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">击水湘江</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Born To Fight!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2018/01/17/frame-work-sdWebImage1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/17/frame-work-sdWebImage1/" itemprop="url">SDWebImage学习笔记（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-17T10:44:35+08:00">2018-01-17</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="内存缓存大小的限制"><a href="#内存缓存大小的限制" class="headerlink" title="内存缓存大小的限制"></a>内存缓存大小的限制</h2><p>在设计缓存框架是的时候，如果内存我们使用的类是NSDictionary，或则NSArray这种通用类的话，如果内存占用率过高，导致系统RAM中少于12M内存（这个数值可能会随着系统版本和手机机型的不同而不同），那么系统的看门狗（watch dog）会将我们的App杀死。这时，我们要限制占用内存的大小。获取系统内存大小的方案如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;mach/mach.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;mach/mach_host.h&gt;</span></span></div><div class="line"><span class="keyword">static</span> natural_t minFreeMemLeft = <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">12</span>; <span class="comment">// reserve 12MB RAM</span></div><div class="line"><span class="comment">// inspired by http://stackoverflow.com/questions/5012886/knowing-available-ram-on-an-ios-device</span></div><div class="line"><span class="keyword">static</span> natural_t get_free_memory(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    mach_port_t host_port;</div><div class="line">    mach_msg_type_number_t host_size;</div><div class="line">    vm_size_t pagesize;</div><div class="line"></div><div class="line">    host_port = mach_host_self();</div><div class="line">    host_size = <span class="keyword">sizeof</span>(vm_statistics_data_t) / <span class="keyword">sizeof</span>(integer_t);</div><div class="line">    host_page_size(host_port, &amp;pagesize);</div><div class="line"></div><div class="line">    vm_statistics_data_t vm_stat;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size) != KERN_SUCCESS)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Failed to fetch vm statistics"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Stats in bytes */</span></div><div class="line">    natural_t mem_free = vm_stat.free_count * pagesize;</div><div class="line">    <span class="keyword">return</span> mem_free;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们定义了最小的内存空间12M，然后在框架中，如果我们使用<code>get_free_memory</code>获取可用内存小于<code>minFreeMemLeft</code>，那么我们就移除内存缓存：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="built_in">UIImage</span> *)image imageData:(<span class="built_in">NSData</span> *)data forKey:(<span class="built_in">NSString</span> *)key toDisk:(<span class="built_in">BOOL</span>)toDisk</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!image || !key)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (get_free_memory() &lt; minFreeMemLeft)</div><div class="line">    &#123;</div><div class="line">        [memCache removeAllObjects];</div><div class="line">    &#125;</div><div class="line">    [memCache setObject:image forKey:key];</div><div class="line">    <span class="comment">//.....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果既想避免占用内存过高而被Kill掉，同时也想避免在每个方法中都去判断当前内存可用空间的大小，那么使用<code>NSCache</code>替代上文中提到的NSDictionary或者NSArray来做内存缓存的类，因为NSCache在内存吃紧的情况下会自动清除部分缓存。</p>
</blockquote>
<h2 id="关于图片的Alpha通道"><a href="#关于图片的Alpha通道" class="headerlink" title="关于图片的Alpha通道"></a>关于图片的Alpha通道</h2><p>图片的Alpha通道会造成离屏渲染从而带来FPS的下降，所以没有特别必要的情况下应该尽量避免使用Alpha通道，如果从网络上下载下来的图片含有Alpha通道该怎样处理呢？我们可以在强制解码阶段来将Alpha通道去除：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">UIImage</span> *)decodedImageWithImage:(<span class="built_in">UIImage</span> *)image</div><div class="line">&#123;</div><div class="line">    <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</div><div class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">    <span class="comment">// 使用kCGImageAlphaNoneSkipLast，去除了Alpha通道</span></div><div class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</div><div class="line">                                                 <span class="built_in">CGImageGetWidth</span>(imageRef),</div><div class="line">                                                 <span class="built_in">CGImageGetHeight</span>(imageRef),</div><div class="line">                                                 <span class="number">8</span>,</div><div class="line">                                                 kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Little);</div><div class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">    <span class="keyword">if</span> (!context) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>,&#123;<span class="built_in">CGImageGetWidth</span>(imageRef), <span class="built_in">CGImageGetHeight</span>(imageRef)&#125;&#125;;</div><div class="line">    <span class="built_in">CGContextDrawImage</span>(context, rect, imageRef);</div><div class="line">    <span class="built_in">CGImageRef</span> decompressedImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</div><div class="line">    <span class="built_in">CGContextRelease</span>(context);</div><div class="line"></div><div class="line">    <span class="built_in">UIImage</span> *decompressedImage = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:decompressedImageRef scale:image.scale orientation:image.imageOrientation];</div><div class="line">    <span class="built_in">CGImageRelease</span>(decompressedImageRef);</div><div class="line">    <span class="keyword">return</span> SDWIReturnAutoreleased(decompressedImage);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果想要保存原图片的Alpha通道，那么可以先获取原图片的Alpha通道信息，然后在调用CGBitmapContextCreate的时候将Alpha信息传递过去：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef);</div><div class="line"><span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</div><div class="line">                                             <span class="built_in">CGImageGetWidth</span>(imageRef),</div><div class="line">                                             <span class="built_in">CGImageGetHeight</span>(imageRef),</div><div class="line">                                             <span class="number">8</span>,</div><div class="line">                                             alphaInfo | kCGBitmapByteOrder32Little);</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/12/20/note-concurrency-jmm-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/20/note-concurrency-jmm-0/" itemprop="url">Java内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-20T10:22:33+08:00">2017-12-20</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JVM不能保证64位的long型和double型具有顺序一致性"><a href="#JVM不能保证64位的long型和double型具有顺序一致性" class="headerlink" title="JVM不能保证64位的long型和double型具有顺序一致性"></a>JVM不能保证64位的long型和double型具有顺序一致性</h2><p>CPU和内存中的通信是通过总线进行的，总线的宽度是固定的，如果有多个CPU同时请求总线进行读/写总线事务的话，会由总线仲裁（Bus Arbitration）进行裁决，然后获胜的CPU才可以进行数据传递。并且在某个CPU占用了总线之后，其它CPU要请求总线仲裁是要被拒的。这种机制就保证了CPU对内存的访问是以串行的方式进行的。如果有一个32位的处理器，但是要进行64位的写数据操作，这时CPU会将数据分为两个32位的写操作，并且这两个32位数据在请求总线仲裁的时候可能被分配到了不同的总线事务中，所以此时这个64位的写操作就不具有原子性了。这时如果处理器A写入了高32位，在写入低32位期间，处理器B对该数据进行了访问，那么就会产生错误的数据。（Java5之前读写都可以被拆分，Java5之后写操作可以被拆分，但是读操作必须是原子的）。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="volatile对变量读写的影响"><a href="#volatile对变量读写的影响" class="headerlink" title="volatile对变量读写的影响"></a>volatile对变量读写的影响</h3><p>某个变量如果被声明为volatile，那么对它的读操作和写操作就具有原子性，但是如果是复合操作，那么就不具有原子性，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileFeaturesExample</span> </span>&#123;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> v1 = <span class="number">0L</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span></span>&#123;</div><div class="line">        v1 = l;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span></span>&#123;</div><div class="line">        returen v1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span><span class="params">()</span></span>&#123;</div><div class="line">        v1 ++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里set和get方法的语义和加了锁是一样的，其中getAndIncrement其实可以分为以下三个部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncrement</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">long</span> tempt = get();</div><div class="line">    temp += <span class="number">1L</span>;</div><div class="line">    set(tempt);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这其中get和set方法是加锁的，但是<code>tempt += 1L;</code>就不具有原子性了，也就是说volatile让单个读和写操作具有原子性，但是对于复合操作是没有原子性的。</p>
<h3 id="volatile变量读写的内存语义"><a href="#volatile变量读写的内存语义" class="headerlink" title="volatile变量读写的内存语义"></a>volatile变量读写的内存语义</h3><blockquote>
<p>对volatile变量执行写操作，会将线程的本地内存值刷新到主存中；对volatile变量执行度操作，会将变量所在线程的本地内存置为无效，线程然后会从主内存中读取该volatile变量。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/12/16/note-concurrency-in-practice-advance-3-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/16/note-concurrency-in-practice-advance-3-0/" itemprop="url">显式锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-16T10:59:57+08:00">2017-12-16</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="内置锁和显示锁"><a href="#内置锁和显示锁" class="headerlink" title="内置锁和显示锁"></a>内置锁和显示锁</h2><p>在Java5中<code>ReentrantLock</code>相比内置锁有很大的性能提升，但是在Java6中内置锁的性能有了很大的提升，他们的性能相差不大。并且由于<code>synchronized</code>是JVM的内置属性，所以它在未来可以进行更深层次的优化。<br>内置锁相比显式锁拥有以下的优势：</p>
<ul>
<li>结构更加紧凑</li>
<li>使用内置锁不用手动进行解锁，所以具有更低的危险性</li>
<li>在线程转储(thread dumps)过程中能给出哪些帧获取了哪些锁(<code>ReentrantLock</code>在Java6之后也支持)</li>
<li>可以检测和识别反生死锁的线程</li>
</ul>
<blockquote>
<p>当使用某些内置锁不能满足的高级功能时，比如：可定时的，可轮询的，可中断的锁，公平队列，以及非结构的锁时。则需要考虑使用<code>ReentrantLock</code>。</p>
</blockquote>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>公平锁就是说每个请求锁的线程按照先到先得的顺序获得锁，后到的线程在它前一个线程没有释放锁时是不能获取锁的，没有获取的锁的线程就被放到队列里挂起。非公平锁就是说每个请求锁的线程，如果发现该锁没有被占用就去请求锁，而不管其前面有没有线程在等待，这将提升吞吐量。由于线程的挂起和重新唤醒，线程的调度会带来很大的性能损耗，所以，如果请求锁的平均时间间隔非常短，那么最好使用非公平锁。反之，如果持有锁的时间较长，或者请求锁的时间间隔较长，那么性能的瓶颈就不在切换线程上了，这时就应该使用公平锁，使用非公平锁”插队”的方式所带来吞吐量的提升将会是非常微弱的。内置锁和<code>ReentrantLock</code>都没有提供确定的公平性保证，因为一般来说实现总体的公平性已经足够了。</p>
<h2 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h2><p>首先为什么会出现条件队列呢？我们知道要保证某个多线程的方法被调用成功可以使用线程休眠的方式，但是这种方式会有问题：如果休眠的时间过短，那么会导致CPU的资源消耗过高，如果休眠的时间很长，这时如果其它某个线程修改了判断条件，这时休眠的线程不能及时响应，只有在休眠之后才会响应。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ThreadSafe</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepyBoundedBuffer</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SleepyBoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(size);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!isFull()) &#123;</div><div class="line">            doPut(v);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     Thread.sleep( SLEEP_GRANULARITY );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!isEmpty())</div><div class="line">            <span class="keyword">return</span> doTake();</div><div class="line">    &#125;</div><div class="line">     Thread.sleep( SLEEP_GRANULARITY ); &#125;</div><div class="line">  &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>使用条件队列就可以解决这种问题：条件队列就是说在条件不满足时候线程休眠(调用wait方法)，当条件满足的时候线程会收到通知并且被唤醒(调用notify方法)，这样就不会产生多余的开销。<br><br>调用<code>wait</code>方法之后会发生以下事情：</p>
<ol>
<li>释放锁</li>
<li>阻塞当前线程并等待直到超时</li>
<li>线程被终端或者被一个通知唤醒</li>
<li>唤醒后，wait在返回前还要重新获取锁</li>
</ol>
<p>在步骤3和步骤4之间可能有另外一个线程获取了锁，并且改变了对象的标志，这个时候其实条件已经变成假的了。或者这个被唤醒的原因并不是条件变成了真，而是其它的线程的某个条件变成了真，那个线程调用了notify或者notifyAll方法。所以说即使线程被notify唤醒了，并不一定是因为条件满足了，所以在唤醒之后还要继续检查条件，这时要将wati放在一个。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">stateDependentMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"><span class="comment">// condition predicate must be guarded by lock</span></div><div class="line"><span class="keyword">synchronized</span>(lock) &#123;</div><div class="line"><span class="keyword">while</span> (!conditionPredicate())&#123;</div><div class="line">    lock.wait();</div><div class="line">    <span class="comment">// object is now in desired state</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/12/14/note-java-concurrency-in-practice-2-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/14/note-java-concurrency-in-practice-2-2/" itemprop="url">Java并发编程-性能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-14T16:52:07+08:00">2017-12-14</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>并发的目的就是提高系统的性能和响应速度，但是这些都要建立在安全性的基础之上的，也就是说先要保证系统能够正常的运行，满足现有的业务需求，然后再考虑性能。并且在提升性能的同时往往会增加系统的复杂性，因为很多性能的优化需要牺牲掉代码的可理解性和面向对象的原则（同时可能会出现活跃性的问题），增加系统的维护成本，并且有时不会增加系统的性能反而会降低系统的性能。</p>
<h2 id="多线程带来的开销"><a href="#多线程带来的开销" class="headerlink" title="多线程带来的开销"></a>多线程带来的开销</h2><p>多线程的引入会造成一些额外的开销，比如：线程的创建和销毁，线程的调度，上下文的切换，线程之间的协调（例如加锁，触发信号以及内存同步）。如果这些性能开销大于吞吐量，响应性所带来的性能提升那么就会得不偿失。</p>
<h2 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h2><p>什么是可伸缩性？可伸缩性指的是通过增加计算机的资源（例如CPU，内存，存储容量或IO带宽），程序的吞吐量或者处理能力能相应的增加。但是这种伸缩性往往是有极限的，比如下面提到的Amdahl定律。</p>
<h2 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h2><p>增加CPU的个数也不能一直提高性能。Amdahl定律就指明了这一点：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-d38318f874db2020.png" alt="Amdahl公式"><br>在这个公式中：<em>F表示串行执行的部分占所有部分的比重，N代处理器的个数，最后的结果代表和单一处理器时速度的比例。</em>我们假设两个极限：</p>
<ul>
<li>在处理器个数等于一时，其数值是1，也就是说它的速度没有提升。</li>
<li>在处理器个数为正无穷的时候，其数值为1/F。</li>
</ul>
<p>所以只提高处理器的个数是不不能一直提高执行速度的。我们来举个例子：</p>
<p>放假了班主任给小明同学布置了两份作业：</p>
<p>一、9张英语作业：将英语单词第一单元抄写九遍<br>二、数学第二单元的课后习题做完</p>
<p>假设做数学习题所用的时间是1小时，写英语单词的时间为每单元1小时，所以说如果有小明一个人来做需要10个小时才能完成。小明很贪玩，到了周日晚上才发现自己作业没有写，小明急了，于是就找同学帮他写英语单词，因为英语单词是抄写9份，所以他找了9个小伙伴给他抄，他自己做数学习题（假设数学题不能多个人来做），这样本来是个小时完成的任务，小明最后用了2小时完成了，按照Amdahl定律，其F是0.1，N是10，所以最后的数值是5.26倍。然后我们假设小明有无数个小伙伴都来帮他抄写英语单词，那么最后他需要的时间就接近于1小时，做以按照Amdahl定律，其F实0.1，N是正无穷，所以最后数值是10，也就是说他的速度是原来的10倍。也就是说无论他找多少个小伙伴都不能突破一小时的时间，<strong>因为这一小时只能是串行执行的，不能由其他的处理器来协助完成。</strong></p>
<p>然而要能够使用Amdahl定律需要首先估算出串行执行的部分所占的比例。<br>同时如果增加了处理器的个数，那么每个处理器的利用率都会下降，其中串行所占比例越重的系统，其利用率下降的越厉害。</p>
<h2 id="内存的同步"><a href="#内存的同步" class="headerlink" title="内存的同步"></a>内存的同步</h2><p>在使用<code>synchronized</code>和<code>volatile</code>以提供可见性的同时也引入了需要内存同步的问题，因为其使用了内存栅栏（Memory Barrier），使用内存栅栏是可以刷新缓存，使得缓存无效的。某个线程的同步会影响到其它线程的性能，因为同不会增加内存总线上的通信量，总线的带宽是有限的，并且所有处理器都共享这个带宽。但是现在的JVM会对代码做相应的优化，比如下面两段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span> (<span class="keyword">new</span> Object()) &#123;</div><div class="line">           <span class="comment">// do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里永远不会有任何两个线程会去竞争这个锁的，因为每次进入这个方法都会新建一把锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getStoogeNames</span><span class="params">()</span> </span>&#123;</div><div class="line">List&lt;String&gt; stooges = <span class="keyword">new</span> Vector&lt;String&gt;();</div><div class="line">stooges.add(<span class="string">"Moe"</span>);</div><div class="line">stooges.add(<span class="string">"Larry"</span>);</div><div class="line">stooges.add(<span class="string">"Curly"</span>);</div><div class="line"><span class="keyword">return</span> stooges.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用<code>Vector</code>可能会进行四次获取锁和释放锁的操作，但是由于这个<code>stooges</code>是一个局部变量，局部变量是属于线程栈的，每个线程中的不一样，所以没有必要加锁。在这两种情况下，如果编译器够智能，就会进行优化从而去掉锁。并且如果编译器没有进行逸出分析，那么也可能进行锁的粒度粗化。也就是说将原来需要加四次锁的地方改为加一次锁。也就是说再非竞争同步的时候，我们就不必担心，JVM已经帮我们做了优化，我们需要关心的就是可能引发竞争的地方。</p>
<blockquote>
<p>在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。</p>
</blockquote>
<h2 id="锁分段和减少锁的粒度"><a href="#锁分段和减少锁的粒度" class="headerlink" title="锁分段和减少锁的粒度"></a>锁分段和减少锁的粒度</h2><p>锁分段的意思是有一个数据集合A,B,C,D,那么线程T1和线程T2一般情况不会同时访问A，而是访问不同的数据，所以在T1和T2访问不同的数据时就是没有必要加锁的，这时可以根据数据集合的量配置若干个锁，比如ConcurrentHashMap中使用的是16个锁来增大吞吐量。而减少锁的粒度是如果之前很多个资源都用同一个锁，并且各个资源之间没有相互的依赖，那么可以将原来的一个锁变为多个锁。锁分段往往将锁放入Collection中，而减少锁的粒度往往是声明若干个锁。<em>其实锁分段也是一种减少锁粒度的方式。</em></p>
<h2 id="不能滥用对象池"><a href="#不能滥用对象池" class="headerlink" title="不能滥用对象池"></a>不能滥用对象池</h2><p>有时候某个对象会重复的使用，我们为了不重新new对象（事实上Java的分配操作要比C语言的malloc的调用速度还要快）以及垃圾回收带来的开销，常常会建一个池子将已经创建的对象保存进池子以备后用。但是这样做需要考虑以下几点：对象池的大小很重要，如果对象池很小，那么将不会起到相应的作用；如果对象池很大，那么将会占用很多内存资源，这会对垃圾回收器带来压力。如果用在多线程，那么会造成更加严重的性能问题，因为如果不用线程池，那么每个新建的对象就会在线程本地的内存块中。如果使用多线程，那么情况会更加糟糕，因为需要协调每个线程之间的调用，在协调的过程中可能导致某个线程的死锁。并且多个线程之间的同步，如果使用锁，那么及时没有竞争，只是加锁和解锁所带来的性能损耗要比new对象带来的损耗大得多。这看似一个性能优化的技术点，但实际上会导致可伸缩性的问题。</p>
<blockquote>
<p>同步的开销要比new对象的开销少的得多。</p>
</blockquote>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>上下文切换是什么？<br>锁竞争的过程中会发生上下文切换，越多的上下文切换将会造成越低的吞吐量。如果某个执行IO操作的线程被阻塞了，同时这个线程还持有一把锁，那么如果有越来越多的线程来请求这个锁，也将被阻塞而挂起，这就会增加上下文切换的次数。所以要尽量减少持有锁的时间来减少上下文切换。</p>
<p>参考资料：</p>
<ol>
<li><p><a href="https://stackoverflow.com/questions/5440128/thread-context-switch-vs-process-context-switch" target="_blank" rel="external">线程上下文切换和进程上下文</a></p>
</li>
<li><p><a href="http://www.linfo.org/context_switch.html" target="_blank" rel="external">上下文切换的定义</a></p>
</li>
<li></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/12/12/note-java-concurrency-in-practice-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/12/note-java-concurrency-in-practice-2/" itemprop="url">Java中的活跃性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-12T13:15:34+08:00">2017-12-12</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在多线程开发中，我们往往为了安全性而去加锁，如果锁过多，就可能出现<strong>顺序死锁</strong>。如果不适用锁，使用信号量和线程池来限制对资源的访问，那么又可能出现<strong>资源死锁</strong>。那么究竟怎样判断死锁？死锁的种类都有哪些？怎样避免死锁呢?</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>我们如果把每个线程都想像成有向图中的一个点，如果线程A等待线程B所占用的资源，那么就从A向B画一条直线，如果最终这个图形成了一个环形，那么就出现了资源的相互依赖，就造成了死锁。</p>
<h2 id="死锁之后的处理形式"><a href="#死锁之后的处理形式" class="headerlink" title="死锁之后的处理形式"></a>死锁之后的处理形式</h2><p>死锁之后该怎么处理分为两种方式，第一种方式就是什么都不做不了，应用程序将到此结束（也可能是某个子系统停止或者性能降低），直到重新启动，才会解除本次死锁。第二种方式就是干涉死锁。比如数据库操作在两个事务之间出现了死锁，那么数据库服务器会选择一个牺牲者并且放弃这个事务。作为牺牲者的事务将放弃它的所有资源，从而使其它事务继续进行。让后等待其它任务执行完成之后再去执行这个被牺牲了的任务。</p>
<h2 id="顺序死锁"><a href="#顺序死锁" class="headerlink" title="顺序死锁"></a>顺序死锁</h2><p>如果有left和right两把锁，同时有A线程和B线程去访问，如果按照下面的顺序就可能造成死锁。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-56118e0094e4a64d.png" alt="order_dead_lock"></p>
<p>线程A持有了left锁，再获取了right锁的时候才可以进行下一步的执行，并且只有获得了right锁才可以释放掉left锁。线程B已经获取了right锁，在获取了left锁的时候才可以进行下一步的执行，也只有获取了right锁才可能释放掉right锁。所以就造成了最后的死锁。这个死锁引起的原因就是锁的顺序不一致，也就是说在使用锁进行同步的过程中如果有两把锁，那么锁的顺序需要保持一致，否则就可能造成死锁。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftRightDeadLock</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object left = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object right = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(left) &#123;</div><div class="line">            <span class="keyword">synchronized</span>(right) &#123;</div><div class="line">                doSomething();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(right) &#123;</div><div class="line">            <span class="keyword">synchronized</span>(left) &#123;</div><div class="line">                doSomethingElse();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="动态的锁顺序死锁"><a href="#动态的锁顺序死锁" class="headerlink" title="动态的锁顺序死锁"></a>动态的锁顺序死锁</h2><p>有些时候我们没有很明确的在两个不同的方法中使用两把锁，但是仍然可能造成死锁，这种死锁往往不容易被发现，比如我们要给将账户A的钱转给账户B，那么我们可以使用下面的方法来确保转账的原子性，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account fromAccount, Account toAccount,</span></span></div><div class="line">DollarAmount amount) <span class="keyword">throws</span> InsufficientFundsException &#123;</div><div class="line"><span class="keyword">synchronized</span> (fromAccount) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (toAccount) &#123;</div><div class="line"><span class="keyword">if</span> (fromAccount.getBalance().compareTo(amount) &lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</div><div class="line">    &#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">    fromAccount.debit(amount); toAccount.credit(amount);</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个死锁的原因就是可能调用方在两个线程中使用的参数顺序可能相反，这就造成死锁，因为我们不能确定调用方是怎么调用我们写的接口的。比如下面的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A: transferMoney(myAccount, yourAccount,<span class="number">10</span>);</div><div class="line">B: transferMoney(yourAccount, myAccount,<span class="number">20</span>);</div></pre></td></tr></table></figure>
<p>这时就造成了死锁，并且这种死锁是在一般情况下是不会发生的，这就造成了难以排查的错误。这时该如何去做呢？我们的目的是想让外界两个参数的改变不会影响到内部锁的顺序，所以，我们可以拿两个入参的<code>identityHashCode</code>去作为判断条件，根据hash值的大小来改变加锁的顺序。当然，这里面可能有哈希碰撞的情况（这种情况发生的几率是非常低的），如果有这种情况的出现，那么就给这两个同步操作外部再加一个锁，这样来确保这个操作的原子性，就不会有死锁的情况了。这里面如果加锁的两个对象有唯一的键值，那么就可以直接用其键值，这样就不必再使用额外的锁了。</p>
<h2 id="协作对象之间发生的死锁"><a href="#协作对象之间发生的死锁" class="headerlink" title="协作对象之间发生的死锁"></a>协作对象之间发生的死锁</h2><p>比如下面的Taxi和Dispatcher对象都使用了锁，并且它们之前是相互协作的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</div><div class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination; <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Taxi</span><span class="params">(Dispatcher dispatcher)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.dispatcher = dispatcher;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> location;</div><div class="line">   &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.location = location;</div><div class="line"><span class="keyword">if</span> (location.equals(destination)) &#123;</div><div class="line">    dispatcher .notifyAvailable (<span class="keyword">this</span> );</div><div class="line"> &#125;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</div><div class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis; <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</div><div class="line">       taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;(); availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</div><div class="line">        availableTaxis .add(taxi);</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</div><div class="line">    Image image = <span class="keyword">new</span> Image();</div><div class="line">    <span class="keyword">for</span> (Taxi t : taxis) &#123;</div><div class="line">     image.drawMarker(t.getLocation()); <span class="keyword">return</span> image;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里面<code>setLocation</code>方法需要先获取<code>Taxi</code>的锁，再获取<code>Dispatcher</code>的锁。而<code>getImage</code>方法需要先获取<code>Dispatcher</code>的锁，然后再获取<code>Taxi</code>的锁，这样就可能造成上文中所说的顺序锁的问题。并且这种锁是更加难以排查的。所以最好不要使用<code>synchronize</code>(管程)。</p>
<blockquote>
<p>在持有锁的过程中调用某个外部方法，那么将可能会出现活跃性的问题。</p>
</blockquote>
<h2 id="丢失信号死锁"><a href="#丢失信号死锁" class="headerlink" title="丢失信号死锁"></a>丢失信号死锁</h2><p>多线程访问某个资源，在有条件谓词作为前置条件，如果条件为假，那么我们会调用wait方法将线程阻塞。如果某个线程将条件变为了真，并且这个wait的线程没有收到这个信号。那么原来wait的线程将会永远等待下去，进而导致死锁。也就是说，线程A通知了一个条件队列，而线程B随后进入这个条件队列，但是线程B将被阻塞而不能执行，因为其需要等待另外一个通知的到来。</p>
<h2 id="开放调用"><a href="#开放调用" class="headerlink" title="开放调用"></a>开放调用</h2><p>之所以出现上述协作对象之间发生的死锁，是因为在调用另外一个对象的方法的过程中，已经持有了一把锁。这种调用称作不开放，所谓的开放调用就是指：在调用某个方法的时候不需要持有锁。通常来说开放调用要比非开放调用更加安全，更加不容易产生死锁，所以我们要尽可能地使用开放调用。我们可以使用开放调用的方法来解决上述遇到的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ThreadSafe</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</div><div class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</div><div class="line"><span class="keyword">private</span> Point location, destination; <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> location;</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> reachedDestination; <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    <span class="keyword">this</span>.location = location;</div><div class="line">    reachedDestination = location.equals(destination);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (reachedDestination) &#123;</div><div class="line">    dispatcher .notifyAvailable (<span class="keyword">this</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@ThreadSafe</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</div><div class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</div><div class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</div><div class="line">availableTaxis .add(taxi); &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</div><div class="line">    Set&lt;Taxi&gt; copy;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">copy = <span class="keyword">new</span> HashSet&lt;Taxi&gt;(taxis);</div><div class="line">&#125;</div><div class="line">Image image = <span class="keyword">new</span> Image(); <span class="keyword">for</span> (Taxi t : copy)</div><div class="line">image.drawMarker(t.getLocation()); <span class="keyword">return</span> image;</div></pre></td></tr></table></figure>
<p>这样就可以将多个锁区分开来，从而在多个对象调用的时候就不会死锁了。</p>
<h2 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h2><p>资源死锁的起因也是由于访问资源的原子性和访问资源的顺序所造成的互相牵制。比如：线程A已经建立了和数据库D1的链接，正在尝试连接数据库D2；与此同时，线程B已经建立了和数据库D2的连接，正在尝试连接数据库D1。这时就造成了资源死锁。（当然这和数据库同时连接的个数，以及资源的大小有关。资源越大，连接的个数越多，那么出现死锁的可能性就越少。）<br>在资源死锁中，还有一种线程饥饿死锁的情况，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDeadlock</span> </span>&#123;</div><div class="line">ExecutorService exec = Executors.newSingleThreadExecutor();</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderPageTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Future&lt;String&gt; header, footer;</div><div class="line">        header = exec.submit(<span class="keyword">new</span> LoadFileTask(<span class="string">"header.html"</span>));</div><div class="line">        footer = exec.submit(<span class="keyword">new</span> LoadFileTask(<span class="string">"footer.html"</span>));</div><div class="line">        String page = renderBody();</div><div class="line">        <span class="comment">// Will deadlock -- task waiting for result of subtask</span></div><div class="line">        <span class="keyword">return</span> header.get() + page + footer.get();</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这会出现死锁，因为<code>header.get()</code>和<code>fotter.get()</code>是阻塞的，它将会等待exec执行完毕，而exec想要执行必须要等到<code>header.get() + page + footer.get();</code>执行完毕，这样就造成了线程饥饿死锁。(RenderPageTask是任务1，header.get() + page + footer.get()是任务2)。</p>
<h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>饥饿就是指某个线程始终不能获取其所需要的资源，导致它不能继续执行，引起饥饿的最常见资源就是CPU的时钟周期。Java中提供了10中线程的优先级，然而对应到操作系统中，可能某些优先级会重合（因为操作系统可能没有这么多的优先级）。并且设置线程的优先级可能不会起到明显的效果，反而可能因为优先级翻转而造成死锁，所以我们尽量不要去改动线程的优先级。但是这种情况也不是绝对的，比如有一个CPU密集的后台任务在执行，那么这个任务很可能会和主线程去抢占CPU资源，从而导致主线程响应性降低，为了解决这个问题，我们可以将后台线程的优先级降低，从而提高主线程的响应性。</p>
<blockquote>
<p>尽量避免使用线程优先级，因为这会增加平台依赖性，并且可能会导致活跃性问题。在大多数并发应用程序中，都应该使用默认的线程优先级。</p>
</blockquote>
<h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>活锁是指没有发生死锁，但是程序一直在重试，并且重试一直错误，导致程序不能正常往下执行。（产生这种情况的原因是对错误的估计不对：本来是不能解决的错误，却以为可以通过重试解决）。<br>同时，多个线程之间的协作也可能造成死锁，因为可能两个协作的线程都对彼此进行响应，响应完之后使得任何一个线程都不能继续执行，解决这种活锁的问题可以通过在重试机制中引入随机性，也就是说某个重试完之后，另一个线程在随机的时间段之后再进行重试，从而避免了和之前线程的碰撞。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/12/01/note-java-concurrency-in-practice-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/01/note-java-concurrency-in-practice-1/" itemprop="url">Java结构化并发应用程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T20:50:39+08:00">2017-12-01</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java结构化并发应用程序"><a href="#Java结构化并发应用程序" class="headerlink" title="Java结构化并发应用程序"></a>Java结构化并发应用程序</h1><h2 id="线程池和队列的关系"><a href="#线程池和队列的关系" class="headerlink" title="线程池和队列的关系"></a>线程池和队列的关系</h2><p>线程池和队列之间的关系是很紧密的。队列是用来放任务的，它有并行和串行之分。其中并行队列中的任务可以并发的执行；串行队列中的任务只能按照顺序一个一个执行，正是因为这个原因，串行队列也可以实现线程安全，也可以作为锁来用。而线程池就是很多的线程的容器，这些线程负责从队列中取出任务执行任务并且返回线程池以等待下个任务的到来。<br>在Java中通常会有如下几种创建线程池的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> <span class="comment">// 创建的线程数量是固定的</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> <span class="comment">// 利用所有可用的处理器资源创建一个'工作密取'的线程池</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> <span class="comment">// 创建一个单线程的线程池，放入线程池中的任务顺序执行</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> <span class="comment">// 创建一个缓存的线程池，如果之前有可用的线程就用，如果没有就重新创建，如果执行的任务量小并且多的时候用这个线程池会提高性能。如果一个线程在60s之内没有被使用，那么这个线程将会被中断并且被移除线程池。所以说如果这个线程池如果一直是idel状态的时候，那么它不会消耗任何的资源</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledExecutor</span><span class="params">()</span> <span class="comment">// 创建一个具有定时功能的线程池</span></div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure>
<p>在IOS开发中GCD就是典型的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</div></pre></td></tr></table></figure>
<p>这个函数调用时候是这样子的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> concruntQueue = dispatch_queue_create(<span class="string">"come.mike.fighting0.com"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    <span class="built_in">dispatch_async</span>(concruntQueue, ^&#123;</div><div class="line"></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"我正在做一项耗时的任务"</span>);</div><div class="line"></div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>这段代码就是说吧一个耗时的任务放到了一个并行的队列中，然后调用<code>dispatch_async</code>，在调用这个方法时系统会自动的给我们创建好一个线程池并且从其中取出一个线程，来执行我们的任务。这样，我们就不用自己再去创建并管理线程了，避免了不必要的错误并且避免了频繁创建线程所带来的开销，同时避免了任务到来的时候再去创建线程从而造成一定程度的响应延迟。</p>
<h2 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h2><p><code>Executor</code>的创建在上文中已经说明了，下面说下它的关闭。<code>Executor</code>的终止方式有以下两种：</p>
<ul>
<li>缓慢关闭，让已经执行的任务执行完毕，然后不再接受正在等待的任务或者新来的其它任务(<code>shutdown</code>方法)</li>
<li>暴力关闭，直接关闭线程池，不管已经执行的任务(<code>shutdownNow</code>方法)</li>
</ul>
<h2 id="Timer和SecheduledThreadPoolExecutor的对比"><a href="#Timer和SecheduledThreadPoolExecutor的对比" class="headerlink" title="Timer和SecheduledThreadPoolExecutor的对比"></a>Timer和SecheduledThreadPoolExecutor的对比</h2><blockquote>
<p>因为Timer的调度机制是基于绝对时间而不是相对时间的，因此任务的执行对系统的时钟很敏感，而<code>SecheduledThreadPoolExecutor</code>是基于相对时间调度的，所以更加准确。<br></p>
</blockquote>
<ul>
<li>Timer会将所有的定时任务都放到一个线程中去执行，所以如果某个任务的执行时间长于所设定的时间间隔那么这个Timer就会不准确。而线程池就能很好的解决这个问题，因为它是在多个线程中执行不同的任务的，所以各个任务之间彼此没有影响。</li>
<li>TimerTask如果抛出一个异常，那么Timer不会处理它，反而会终止所有的任务，包括正在执行的任务和将要执行的任务。在这之后也没有可以恢复Timer的方式。</li>
</ul>
<p>那么问题来了，在Java中如果要实现自己的调度任务不使用Timer，该使用什么呢？应该使用<code>DelayQueue</code>，它内部的每个对象都有一个延迟时间的方法。</p>
<h2 id="任务和线程处理中断的方式"><a href="#任务和线程处理中断的方式" class="headerlink" title="任务和线程处理中断的方式"></a>任务和线程处理中断的方式</h2><p>虽然每个任务都在一个线程中执行，但是这个线程并不被这个任务所拥有。拥有这个线程和管理这个线程的<em>主人</em>是线程池，所以在遇到中断的时候，通常会将其抛出，然后让上层的代码来处理中断。举个例子：你在一个朋友家玩耍，这时忽然来了一个收租金的人大吵大闹要交房租（中断），这时你不应该处理，而是应该保留这个现场，并且把问题抛给你的朋友，因为这是他的家。这也就是什么很多阻塞库框架都会在遇到中断的时候抛出来<code>InterruptedException</code>，以便上层代码进行处理（尽快的退出，并且将中断尽快的传递给上层也是最温和的响应策略）。也就是说任务本身对中断不应该做任何的处理，不应该对中断策略做任何的假想，除非这个框架的中断处理策略已经定了，不需要再将中断抛给上层代码了。除了将中断传递给上层的调用者之外，任务还需要保存中断的状态，以备后续上层代码的处理，保存状态的方式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thread.currentThread().interrupt();</div></pre></td></tr></table></figure>
<p>调用之后就会保持线程的中断状态，恢复中断状态的目的就是让调用栈中更高层的代码看到引发了一个中断，并且这个线程的状态是<code>interrupted</code>的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Thread myThread =  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">throw</span>  <span class="keyword">new</span> InterruptedException();</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    Thread.currentThread().interrupt();</div><div class="line">                    System.out.println(<span class="string">"thread status:"</span> + Thread.currentThread().isInterrupted());</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">myThread.run();</div></pre></td></tr></table></figure>
<p>这段代码如果不加<code>Thread.currentThread().interrupt();</code>，那么下面的<code>Thread.currentThread().isInterrupted()</code>就将会返回<code>false</code>。如果没有确定上层代码是否要处理异常，那么切记不能catch中这个中止的异常而不做任何的事情。</p>
<h2 id="Executor的作用"><a href="#Executor的作用" class="headerlink" title="Executor的作用"></a>Executor的作用</h2><p>既然已经有了线程，那么Executor的作用是什么呢？它是将任务的提交和任务的执行分离开了。也就是说把复杂的业务过程分割开了，这样就更加便于我们修改执行策略。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/12/01/chat-locks-of-ios/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/01/chat-locks-of-ios/" itemprop="url">如何选择IOS中的锁？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T17:34:14+08:00">2017-12-01</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于IOS中的锁很多文章都曾谈过，也有很多基本的用法，比如：<a href="http://www.cocoachina.com/ios/20161129/18216.html" target="_blank" rel="external">IOS中的各种锁</a>,<a href="https://www.jianshu.com/p/6773757a6cd5" target="_blank" rel="external">探讨IOS开发中各种锁</a>,<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">ibireme的不再安全的OSSpinLock</a>，这里面对每种锁的用法和加解锁的时间都给出了说明，但是对每种锁的适用场景和在此场景下各种锁的优劣，都没有给予说明，导致我们虽然知道锁的基本用法，但是在选择的时候还是无从下手，本文就是为了解决这个问题的。</p>
<h2 id="IOS中各种锁的试用场景"><a href="#IOS中各种锁的试用场景" class="headerlink" title="IOS中各种锁的试用场景"></a>IOS中各种锁的试用场景</h2><h3 id="OSSpinLock和dispatch-semaphore"><a href="#OSSpinLock和dispatch-semaphore" class="headerlink" title="OSSpinLock和dispatch_semaphore"></a>OSSpinLock和dispatch_semaphore</h3><p>从ibireme的测试中，我们知道自旋锁的加锁和解锁时间是最快的，为什么自旋锁会这么快呢？我们知道当多线程为了争夺一个锁，这时没有争到锁的线程可能会挂起，如果锁被释放了，那么其它被挂起的线程就会被重新唤醒来重新竞争锁。在线程被挂起和重新唤醒的过程中会发生上下文切换，上下文切换是很消耗性能的。如果说每次获取锁之后执行的任务时间很短，那么这些上下文切换造成的性能损耗就会很大。而OSSpinLock这种锁，不会让线程挂起，而是会让线程自旋，不断的去判断锁的状态，如果锁可用就去获得锁，如果不可用就会一直自旋。这样就没有了上下文切换造成的性能损耗，既然自旋锁的加锁开锁速度最快，那么是不是说所有涉及线程安全的地方都应该使用自旋锁呢？不是的。如果说加锁之后任务执行的时间很长，那么所有的没有得到锁的线程都在自循空等，那么就会造成CPU资源的浪费，这些浪费还会影响执行任务线程的执行。这时就可以考虑使用信号量来作为锁，信号量也是非常快的，但是它会让线程休眠而不是空旋，并且在现在比较智能的处理器上，如果使用信号量来加锁，那么它会先让各自的线程先自旋一段时间，如果这个时间之内，线程还没有获得锁，那么就让其休眠。</p>
<blockquote>
<p>如果任务执行的时间非常短（比如给对象的属性赋值），并且资源的竞争很激烈，那么最好使用OSSpinLock，否则使用dispatch_semaphore较好</p>
</blockquote>
<h3 id="NSCondition和NSConditionLock"><a href="#NSCondition和NSConditionLock" class="headerlink" title="NSCondition和NSConditionLock"></a>NSCondition和NSConditionLock</h3><p>条件锁是为了解决生产者消费者问题而产生的一类锁。也就是说在生产者消费者模式中，生产者的生产量达到了消费者可以消费的水平时就释放锁，否则就持有锁。消费者只有在生产者释放锁之后才可以进行消费，并且在消费完成之后就也释放对生产者的锁，然后生产者就可以重新进行生产。也就是说条件锁解决了多个相互关联任务之间的执行顺序问题。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><p>用@synchronized包住需要进行同步的代码是非常简单的方法同时也不必考虑加锁之后不能释放锁的误操作，但是利用这种方式加锁和开锁需要较大的性能损耗，</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cocoachina.com/ios/20161129/18216.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20161129/18216.html</a><br><br><a href="https://stackoverflow.com/questions/195853/spinlock-versus-semaphore" target="_blank" rel="external">https://stackoverflow.com/questions/195853/spinlock-versus-semaphore</a><br><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW1" target="_blank" rel="external">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW1</a><br></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/11/21/note-concurrency-in-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/note-concurrency-in-practice/" itemprop="url">Java多线程基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-21T14:09:19+08:00">2017-11-21</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多个线程安全类的方法在一起一定是线程安全的吗？"><a href="#多个线程安全类的方法在一起一定是线程安全的吗？" class="headerlink" title="多个线程安全类的方法在一起一定是线程安全的吗？"></a>多个线程安全类的方法在一起一定是线程安全的吗？</h2><p>  尽管线程安全类的每个方法都是原子的，但是当很多原子操作合并为一个复合操作的时候，需要额外加锁，否则就会出现竞态条件（race condition）造成线程不安全。但是这里额外的加锁可能会导致性能损耗并且可能引起死锁。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!vector.contains(element))</div><div class="line">    vector.add(element);</div></pre></td></tr></table></figure>
<p>这里<code>contains</code>方法和<code>add</code>方法都是线程安全的，但是综合起来就是非线程安全的了。</p>
<h2 id="方法的局部变量无需加锁"><a href="#方法的局部变量无需加锁" class="headerlink" title="方法的局部变量无需加锁"></a>方法的局部变量无需加锁</h2><p>   某个线程进入一个方法就会创建一个栈，这个栈中存储了某个局部变量，这个局部变量是每个线程所独有，不是共享的，他们之间互不影响，没有必要加锁。</p>
<h2 id="加锁时所发生的事情"><a href="#加锁时所发生的事情" class="headerlink" title="加锁时所发生的事情"></a>加锁时所发生的事情</h2><ul>
<li>操作互斥，很多个线程不能同时对一个代码块进行操作</li>
<li>加锁之后可以保证变量的可见性</li>
<li>抑制了编译器优化，导致指令不会被重排序</li>
<li>使用内存栅栏（Memory Barrier）从而使缓存无效</li>
<li>由于锁竞争而导致阻塞时，持有锁的线程在释放锁的时候需要告诉操作系统，这个锁可以用了，进而操作系统会唤醒其它被挂起的线程</li>
</ul>
<h2 id="锁的粒度该怎样控制"><a href="#锁的粒度该怎样控制" class="headerlink" title="锁的粒度该怎样控制"></a>锁的粒度该怎样控制</h2><p>代码块加锁的粒度应该越小越好，但是如果代码块中加锁的粒度很小（代码中相互竞争的临界资源没有相互的依赖性，可以将每种资源加一把锁），频繁的加锁和开锁也会造成性能的开销，降低CPU的利用率，所以并不是加锁越多越好。同时加锁也会造成代码的复杂性，这就是简单性和性能之间存在的互相制约。当我们实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性。</p>
<h2 id="可见性和原子性"><a href="#可见性和原子性" class="headerlink" title="可见性和原子性"></a>可见性和原子性</h2><p>   <code>volatile</code>保证了属性的可见性，但是不能保证某个操作的原子性。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> number;</div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMethod</span><span class="params">()</span> </span>&#123;</div><div class="line"> number++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  这里的<code>number</code>就是可见的，但是<code>addMethod</code>这个方法不是线程安全的，也就是说<code>number++</code>这个操作不是原子操作，因为它只是保证了，线程<code>A</code>对<code>number</code>的操作对线程<code>B</code>是可见的，但是不能保证在线程<code>A</code>对<code>number</code>操作的时候，线程<code>B</code>也可以对<code>number</code>进行操作。比如线程<code>A</code>和<code>B</code>同时读取了<code>number</code>的数值，发现它是<code>12</code>，这时线程A和线程B</p>
<blockquote>
<p>当执行时间较长的计算或者可能无法快速完成的操作时一定不要加锁，比如：网络IO或者控制台IO。</p>
</blockquote>
<h2 id="如何正确地发布对象"><a href="#如何正确地发布对象" class="headerlink" title="如何正确地发布对象"></a>如何正确地发布对象</h2><p> 这里的发布指的是将某个类的属性值公开。这里如果没有正确的公开，那么就会造成线程不安全。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</div><div class="line">      <span class="keyword">private</span> <span class="keyword">int</span> n;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Holder</span> <span class="params">(<span class="keyword">int</span> n )</span> </span>&#123;<span class="keyword">this</span>.n = n;&#125;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertSanity</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span>(n != n)</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"This statement is false."</span>);</div><div class="line">      &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这里如果在线程A中创建对象，这时线程B调用这个对象的<code>assertSanity</code>方法，那么这个方法就可能会触发断言，也就是说在对象的创建过程中，它的属性n的值可能还没有确定，<code>this.n = n;</code>。这个代码还没有被执行，而在执行<code>n != n</code>的过程中执行了。</p>
<h2 id="对象的可见性"><a href="#对象的可见性" class="headerlink" title="对象的可见性"></a>对象的可见性</h2><p>   对象的引用对另外的线程可见，并不意味着对象的状态对另外的线程可见。<br>   As we’ve seen, that an object reference becomes visible to another thread does not necessarily mean that the state of that object is visible to the consuming thread。</p>
<h2 id="不可变对象的线程安全性"><a href="#不可变对象的线程安全性" class="headerlink" title="不可变对象的线程安全性"></a>不可变对象的线程安全性</h2><p>   不可变对象在正确的初始化之后是线程安全的，所以发布的时候就不必使用锁机制。但是如果某个引用是不可见的，并且引用的对象是可变的，那么在这个不可变的引用在发布的时候也需要加锁。</p>
<h2 id="哪些操作必须是原子的？"><a href="#哪些操作必须是原子的？" class="headerlink" title="哪些操作必须是原子的？"></a>哪些操作必须是原子的？</h2><p>   如果有两个变量，其中一个变量值的更改会影响另外一个变量的，那么如果要同时改变这两个变量，那么它们需要是原子的，否则其中一个变量改变，而另外的一个变量没有变，那么从这个没有变化的变量中取到的值就有可能是过期的值。比如：</p>
<ul>
<li>我们给每个请求都做一个<strong>标记</strong>，如果某个请求和上一个请求的标记相同，那么就从<strong>缓存</strong>去取这个结果。在这里，这个标记和这个结果是一体的，所以对它们两个的操作必须是原子操作，否则就不能保证取出的结果就是正确的。因为有可能<strong>标记变了，但是缓存还没有变。</strong></li>
<li>我们有一个Range这样的对象，它有一个<strong>下界</strong>和一个<strong>上界</strong>，上界要大于下界，所以对上下界的操作就必须保证是原子的，否则如果一个线程改变了下界，这时上界没有跟着变化，就可能会造成下界大于上界的情况。</li>
</ul>
<p>也就是说：</p>
<blockquote>
<p>是规则和限制产生了必须要原子操作的需要，这就是线程安全的需要。</p>
</blockquote>
<h2 id="线程安全是有粒度的"><a href="#线程安全是有粒度的" class="headerlink" title="线程安全是有粒度的"></a>线程安全是有粒度的</h2><p>某个类不是线程安全的，但是如果封装它的类做了线程安全的处理，那么使用它的时候也就是线程安全的了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSet</span> </span>&#123;</div><div class="line">   <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Person&gt; mySet = <span class="keyword">new</span> HashSet&lt;Person&gt;();</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Person p)</span> </span>&#123;</div><div class="line">        mySet.add(p);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsPerson</span><span class="params">(Person p)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mySet.contains(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如果某个类包含了一个线程安全的类，那么它不一定是线程安全，比如："><a href="#如果某个类包含了一个线程安全的类，那么它不一定是线程安全，比如：" class="headerlink" title="如果某个类包含了一个线程安全的类，那么它不一定是线程安全，比如："></a>如果某个类包含了一个线程安全的类，那么它不一定是线程安全，比如：</h2><p>两个<code>AtomicLong</code>类型的变量，这两个变量有关联，那么就必须让对这两个变量的操作变为原子化之后才可以是线程安全的，否则仍然不是线程安全的。</p>
<h2 id="给线程安全的类添加线程安全的方法"><a href="#给线程安全的类添加线程安全的方法" class="headerlink" title="给线程安全的类添加线程安全的方法"></a>给线程安全的类添加线程安全的方法</h2><p>如果要给线程安全的类添加线程安全的方法，那么最好不要使用类扩展，因为如果使用类扩展，那么原来类的线程安全策略做了改动，那么被扩展的类就失效了，比如改了线程安全所用的锁，有些时候这些错误还很难被发现。同时需要特别注意多个线程对线程安全类的同时操作，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</div><div class="line"><span class="keyword">return</span> list.get(lastIndex);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</div><div class="line">list.remove(lastIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面两个方法都是针对于线程安全的<code>Vector</code>所做的，那么它们是线程安全的吗？答案是否定的。<br>比如在<code>getLast</code>方法中，如果线程A在执行完<code>int lastIndex = list.size() - 1;</code>之后恰巧有线程B也对这个Vector做了<code>deleteLast</code>操作，那么就可能引起<code>list.get</code>越界的情况。也就是说，所有针对同一个Vector的操作都应该是原子的。所以正确的做法应该是这样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (list) &#123;</div><div class="line"><span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</div><div class="line"><span class="keyword">return</span> list.get(lastIndex); &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (list) &#123;</div><div class="line"><span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</div><div class="line">list.remove(lastIndex);</div><div class="line">          &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样通过给<code>Vector</code>加锁就确保了这些方法的操作是线程安全的。下面还有个很类似的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</div><div class="line">    doSomething(vector.get(i));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里也是非线程安全的，因为不能保证在执行<code>vector.size()</code>和<code>vector.get(i)</code>之间不会有另外一个线程对<code>vector</code>做其它的操作。这个问题的解决思路和上面是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(vector) &#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</div><div class="line">doSomething(vector.get(i));</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加锁之后，就可以保证<code>vector.size()</code>和<code>vector.get(i)</code>的操作是原子的，中间不会有其它的线程会对<code>Vector</code>做响应的操作。</p>
<h2 id="某个方法加了同步锁就一定是线程安全的吗？"><a href="#某个方法加了同步锁就一定是线程安全的吗？" class="headerlink" title="某个方法加了同步锁就一定是线程安全的吗？"></a>某个方法加了同步锁就一定是线程安全的吗？</h2><p>答案是否定的。因为<strong>加锁实现的互斥是基于锁的，多个线程必须使用同一把锁才可以实现互斥。</strong>，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NotThreadSafe</span>   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"><span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</div><div class="line">...  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</div><div class="line"><span class="keyword">boolean</span> absent = !list.contains(x); <span class="keyword">if</span>(absent)</div><div class="line">    list.add(x);</div><div class="line">    <span class="keyword">return</span> absent;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>putIfAbsent</code>中的加锁并不能保证<code>ListHelper</code>的线程安全，因为这个锁是对象锁，锁住的是<code>ListHelper</code>，而并没有锁住真正需要锁的<code>list</code>上。客户端如果有多个线程同时对list做其它的操作，那么就不能保证线程的安全性。这时争取的做法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ThreadSafe</span> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"><span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(newArrayList&lt;E&gt;()); </div><div class="line">...<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (list) &#123;</div><div class="line">    <span class="keyword">boolean</span> absent = !list.contains(x);</div><div class="line">       <span class="keyword">if</span> (absent) &#123;</div><div class="line">          list.add(x);</div><div class="line">         &#125;</div><div class="line">      <span class="keyword">return</span> absent;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就保证了putIfAbsent的线程安全性。但是这种通过客户端加锁的方法不是很可靠，因为你不能确定客户端做怎样的操作，有时候会造成死锁。</p>
<h2 id="最理想的并发是什么样的？"><a href="#最理想的并发是什么样的？" class="headerlink" title="最理想的并发是什么样的？"></a>最理想的并发是什么样的？</h2><p>   The best way to implement concurrency is to reduce the interactions and inter-dependencies between your concurrent tasks。实现并发最好的方式就是避免并发任务之间的交互和相互之间的依赖。</p>
<h2 id="容易被忽略的线程安全问题"><a href="#容易被忽略的线程安全问题" class="headerlink" title="容易被忽略的线程安全问题"></a>容易被忽略的线程安全问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenIterator</span> </span>&#123;</div><div class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer i)</span> </span>&#123;</div><div class="line">    set.add(i);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Integer i)</span> </span>&#123;</div><div class="line">    set.remove(i);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTenThings</span><span class="params">()</span> </span>&#123;</div><div class="line">    Random r = <span class="keyword">new</span> Random()</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div><div class="line">    add(r.nextInt());</div><div class="line">    System.out.println(<span class="string">"DEBUG: added ten elements to "</span> + set);</div><div class="line">&#125; &#125;</div></pre></td></tr></table></figure>
<p>这里同样是非线程安全的，因为在执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"DEBUG: added ten elements to "</span> + set);</div></pre></td></tr></table></figure>
<p>的时候，系统会默认调用<code>StringBuilder.append(Object)</code>方法，在这个方法里面会再次调用Object的<code>toString</code>方法，在这个<code>toString</code>方法内部将会调用迭代器方法并且生成相应的字符串（容器的hashCode和equals方法也有相似的问题）。所以这里是非线程安全的，可能会抛出<code>ConcurrentModificationException</code>方法。也就是说如果一个状态和保护这个状态的同步代码之间相隔越远，那么开发人员就越容易忘记在访问这个状态时使用正确的同步。这时如果将HashSet用<code>synchronizedSet</code>来封装一下，那么就不会忘记了。</p>
<blockquote>
<p>封装对象的状态有助于维持不变形条件；封装对象的同步机制有助于确保实施同步策略。</p>
</blockquote>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><code>ConcurrentHashMap</code>的出现就是为了解决同步容器性能差的问题。在一些操作中，比如HashMap.get或者List.contains，可能会包含大量的工作，在执行这些大量工作的时间段内，其它的线程都是被阻塞的，这极大的影响了并发的性能。虽然<code>ConcurrentHashMap</code>和<code>HashMap</code>一样是基于散列的Map，但是它们使用不同的加锁策略来提供更高的并发性和伸缩性，从而使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制成为分段锁（Lock Striping）。</p>
<h2 id="什么是工作密取-work-stealing-方法，它有什么优点？"><a href="#什么是工作密取-work-stealing-方法，它有什么优点？" class="headerlink" title="什么是工作密取(work stealing)方法，它有什么优点？"></a>什么是工作密取(work stealing)方法，它有什么优点？</h2><p>在生产者-消费者模型中所有的消费者有一个共享的工作队列。工作密取的每个消费者都含有一个双端队列。如果一个消费者完成了自己工作队列中的所有问题，那么其它就可以从其它的队列<strong>末尾</strong>秘密的获取工作。密取的工作模式比传统的消费者-生产者模式具有更好的可伸缩性，因为工作者线程不会在单个共享的任务队列上发生竞争。在大多数情况下他们都只访问自己的双端队列，从而极大地减少了竞争。当工作者线程要访问另外一个工作者线程的队列时它将从队列的末尾获取工作，因此进一步降低了队列的竞争程度。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/10/17/java-generic-details/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/17/java-generic-details/" itemprop="url">Java泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-17T21:18:59+08:00">2017-10-17</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么需要泛型？"><a href="#为什么需要泛型？" class="headerlink" title="为什么需要泛型？"></a>为什么需要泛型？</h2><p>在Java1.5版本之前是没有泛型的。这时如果我们要实现一个Array类，它里面可以存储任何的对象，我们该怎样做呢？显然，我们可以通过多态来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object e)</span></span>;</div><div class="line"><span class="comment">// ....</span></div><div class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为Java中的对象都继承自Object，所以就可以往这个Array中添加任何的对象，并且取出任何的对象了。但是这样做会有很大的风险：</p>
<ul>
<li>我们取出的对象都是Object类型的，所以如果要使用这个对象就必须做一次强制转换，因为我们使用Collection框架的频率是很高的，所以这种转换就显得比较麻烦</li>
<li>不安全，因为是Object，所以我们可以往里面放任何的对象，比如Animal对象，Plant对象，Plane对象，这样如果我们在调用Array中对象的方法时就可能Crash</li>
</ul>
<p>第二点对于Java这种追求安全性的语言来说，显然是不可以接受的，所以就出现了泛型。</p>
<h2 id="泛型的基本用法"><a href="#泛型的基本用法" class="headerlink" title="泛型的基本用法"></a>泛型的基本用法</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>我们可以定义一个泛型的类，具体的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">   T first;</div><div class="line">   T second;</div><div class="line">   <span class="comment">// ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在我们创建对象的时候就可以使用<code>Pair&lt;Integer&gt; pair = new Pair&lt;Integer&gt;()</code>，这样我们就可以明确的指出这里的<code>Pair</code>中存放的就是<code>Integer</code>类型的对象，其它对象如果要放到Pair中编译器就会报错，这样就在很大程度上增加了安全性。并且在取出的时候也不必再进行一次强制转换了。<br>如果某个类中有多个泛型，那么这些泛型用<code>,</code>好分割开就好了。<code>public class Pair&lt;T, U&gt; { . . . }</code>。<em>一般我们会用大写字母来表示泛型的元素，在Java框架中<code>E</code>用来表示一个元素，<code>K</code>和<code>V</code>用来表示一个table的key value值。</em></p>
<p>同样，我们可以定义一个泛型的方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> a[a.length / <span class="number">2</span>]; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用的时候不需要进行强制转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String middle = ArrayAlg.getMiddle(<span class="string">"John"</span>, <span class="string">"Q."</span>, <span class="string">"Public"</span>);</div><div class="line"><span class="keyword">double</span> middle = ArrayAlg.getMiddle(<span class="number">3.14</span>, <span class="number">1729</span>, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>在第二个例子中我们传入的参数是原始数据类型，这时编译器会给我们自动打包，在从类中取出的时候编译器会给我们自动的拆包。</p>
<h2 id="泛型的界"><a href="#泛型的界" class="headerlink" title="泛型的界"></a>泛型的界</h2><p>有时候我们需要对输入的参数做一些限制，比如说要好处两个数值中较小的一个，那么我们就要求进入方法的参数是实现了<code>Comparable</code>接口的，或者是某个类的子类，这样我们就可以做如下的限制，来让泛型有界：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span> . . .</span></div></pre></td></tr></table></figure>
<p>如果某个类型没有实现<code>Comparable</code>接口的话，让它作为参数会产生一个编译期的警告，在运行时就会Crash。如果一个泛型需要限制很多个接口的话，那么很多个接口之间用<code>,</code>隔开（但是这其中只能有一个是对类的限制，并且如果有对类的限制，那么这个限制一定要写在第一个的位置）。</p>
<h2 id="泛型和JVM"><a href="#泛型和JVM" class="headerlink" title="泛型和JVM"></a>泛型和JVM</h2><p>在Java虚拟机中是没有任何泛型类的，所有的对象都是普通的Java类。其实编译器会对泛型实行一次擦除的过程。也就是说，当你定义一个泛型的时候，系统会自动给你创建一个原始类型给你。原始类型变量的名字和泛型时候取的名字是一样的，但是泛型类型的参数类型被移除了。这些类型被移除之后，取而代之的是它们的边界类型（如果没有边界，那么它的边界就是Object，这也是为了和Java之前的版本做兼容。这也就是上文提到的，为什么对于原始数据类型有一个装包和拆包的过程）。比如，如果你创建上文中的<code>Pair&lt;T&gt;</code>，在编译之后Pair类就成了下面的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> Object first; <span class="keyword">private</span> Object second;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object second)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.first = first;</div><div class="line"><span class="keyword">this</span>.second = second; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> first; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> second; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span> </span>&#123; first = newValue; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object newValue)</span> </span>&#123; second = newValue; &#125; &#125;</div></pre></td></tr></table></figure>
<p>这其实和没有泛型时候创建的类是一样的了。</p>
<p>这里有一个特殊情况，如果有两个限制，那么会以第一个限制为准：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> T lower;</div><div class="line"><span class="keyword">private</span> T upper;</div><div class="line">...</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(T first, T second)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (first.compareTo(second) &lt;= <span class="number">0</span>) &#123; lower = first; upper = second; &#125;</div><div class="line"><span class="keyword">else</span> &#123; lower = second; upper = first; &#125; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时<code>Interval</code>的基本类型就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> Comparable lower;</div><div class="line"><span class="keyword">private</span> Comparable upper;</div><div class="line">...</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(Comparable first, Comparable second)</span> </span>&#123; . . . &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种情况下，如果第一种类型要转化为第二种类型的时候编译器会自动的加上强制转换。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pair&lt;Employee&gt; buddies = . . .;</div><div class="line">Employee buddy = buddies.getFirst();</div></pre></td></tr></table></figure>
<p>因为在编译期进行了类型擦除，所以在调用<code>buddies.getFirst()</code>的时候返回的是一个Object，所以编译器就自动添加了一层强制转换。</p>
<h2 id="泛型方法的翻译"><a href="#泛型方法的翻译" class="headerlink" title="泛型方法的翻译"></a>泛型方法的翻译</h2><p>上文提到过泛型会被编译器在编译的阶段进行擦除，并且将边界替换为泛型的类型。这种泛型的擦除同时也带来了复杂性，比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">LocalDate</span>&gt; </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (second.compareTo(getFirst()) &gt;= <span class="number">0</span>) <span class="keyword">super</span>.setSecond(second);</div><div class="line">&#125;</div><div class="line"><span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为我们要保证<code>Pair</code>中的第二个元素要始终不小于第一个元素，所以我们就继承了<code>Pair</code>，并且重写了其<code>setSecond</code>方法，这样经过泛型的擦除，最后将会变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span> // <span class="title">after</span> <span class="title">erasure</span> </span></div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span> </span>&#123; . . . &#125;</div><div class="line"><span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而原来的<code>Pair</code>类中的<code>setSecond</code>方法是这样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span></div></pre></td></tr></table></figure>
<p>很显然，这是两个不同的方法，然而我们不想让它们是不同的方法，我们想让它走我们新写的方法，因为我们在这里面新增加了我们自己的业务逻辑，比如下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DateInterval interval = <span class="keyword">new</span> DateInterval(. . .); Pair&lt;LocalDate&gt; pair = interval; <span class="comment">// OK--assignment to superclass</span></div><div class="line">pair.setSecond(aDate);</div></pre></td></tr></table></figure>
<p>在这里很显然，我们想走我们新的方法，这时编译器其实会在我们的参数为<code>Object</code>的方法里面重新调用我们新写的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span> </span>&#123;</div><div class="line">    setSecond((Date) second);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>也就是这种转换让系统调用到了我们新写的方法。这样就可以始终调用到我们自己的方法里面了。</p>
<h2 id="Java泛型中需要注意的问题"><a href="#Java泛型中需要注意的问题" class="headerlink" title="Java泛型中需要注意的问题"></a>Java泛型中需要注意的问题</h2><h3 id="不能使用基本数据类型初始化泛型参数"><a href="#不能使用基本数据类型初始化泛型参数" class="headerlink" title="不能使用基本数据类型初始化泛型参数"></a>不能使用基本数据类型初始化泛型参数</h3><h3 id="Runtime类型检查不起作用"><a href="#Runtime类型检查不起作用" class="headerlink" title="Runtime类型检查不起作用"></a>Runtime类型检查不起作用</h3><h3 id="不能使用参数类型来创建Array"><a href="#不能使用参数类型来创建Array" class="headerlink" title="不能使用参数类型来创建Array"></a>不能使用参数类型来创建Array</h3><h3 id="可变参数警告"><a href="#可变参数警告" class="headerlink" title="可变参数警告"></a>可变参数警告</h3><h3 id="不能初始化类型变量"><a href="#不能初始化类型变量" class="headerlink" title="不能初始化类型变量"></a>不能初始化类型变量</h3><h3 id="泛型类中的静态环境中不允许使用类型变量"><a href="#泛型类中的静态环境中不允许使用类型变量" class="headerlink" title="泛型类中的静态环境中不允许使用类型变量"></a>泛型类中的静态环境中不允许使用类型变量</h3><h3 id="不能抛出或者捕获泛型类对象"><a href="#不能抛出或者捕获泛型类对象" class="headerlink" title="不能抛出或者捕获泛型类对象"></a>不能抛出或者捕获泛型类对象</h3><h3 id="注意泛型擦除之后的冲突"><a href="#注意泛型擦除之后的冲突" class="headerlink" title="注意泛型擦除之后的冲突"></a>注意泛型擦除之后的冲突</h3><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>在遗留代码中往往有非泛型的类，这时，如果用一个泛型类去接，那么往往会产生一个警告，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dictionary&lt;Integer, Components&gt; labelTable = slider.getLabelTable(); <span class="comment">// Warning</span></div></pre></td></tr></table></figure>
<p>这时如果你检查了<code>labelTable</code>中数据的类型，并且确定了其中的key value为<code>Integer</code>和<code>Components</code>，那么就可以使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>来忽略这个警告。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">Dictionary&lt;Integer, Components&gt; labelTable = slider.getLabelTable(); <span class="comment">// No warning</span></div></pre></td></tr></table></figure>
<p>当然也可以在外层的方法上添加。</p>
<p>Array有特殊的保护，不能对存有父类的Array中添加子类元素，否则在运行时虚拟机会抛出ArrayStoreException的异常。</p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://www.zhihu.com/question/20400700" target="_blank" rel="external">https://www.zhihu.com/question/20400700</a><br><a href="http://blog.csdn.net/claram/article/details/51943742" target="_blank" rel="external">http://blog.csdn.net/claram/article/details/51943742</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/10/12/data-structure-linear-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/12/data-structure-linear-list/" itemprop="url">数据结构--线性表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-12T09:36:56+08:00">2017-10-12</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1513759-17638d16cc8b3161.png" alt="LinearList"><br><strong>线性表的定义：零个或者多个具有相同的特性的数据元素的有限序列。</strong>注意这里的连续不是指存储地址上的连续而是指存取逻辑上的连续。从线性表的存储结构上可以将线性表分为顺序存储和链式存储两种形式。在实际中常以<em>栈，队列，字符串</em>等特殊的形式来使用。</p>
<h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>线性表的顺序存储结构是指用一段连续的存储单元依次存储线性表中的元素。它的存储形式如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-c333242edadd24c3.png" alt="线性表的顺序存储"></p>
<blockquote>
<p>这种顺序的存储结构必须有要有一个长度，并且这个长度是不能改变的。</p>
</blockquote>
<p>为什么会这样？因为计算机内存中的存储空间是连续的，要分配一段连续的存储空间，如果没有限制大小，那么很可能其后面的空间被其它对象占用了。举个例子，会议室有100个连续的位置，这时来了A组人来了5个人（一共20个人），做到了0，1，2，3，4这五个位置。过了一段时间之后B组来了20人，他们坐到了10…19这10个位置。然后A组的其它15个人来了，这15个人不能被放到5…9这五个位置上，这样就不满足顺序存储结构的定义了。</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>这种存储结构的存储位置很容易被计算出来，比如要计算下标为i元素的位置，这时候只需要利用下面的公式即可：<br>LOC(a<sub>i</sub>) = LOC(a<sub>1</sub>) + (i - 1) * c</p>
<p>其中c是每个元素所占存储单元的个数。所以根据大O阶记法，这个时间复杂度是O(1)(这种时间复杂度为1的存储结构称为随机存取结构或者直接存取结构)。</p>
<h3 id="插入删除"><a href="#插入删除" class="headerlink" title="插入删除"></a>插入删除</h3><p>这种顺序存储结构的插入需要将插入点之后的所有元素都向后移（如果插入点在最后一个元素之后则不需要后移）。所以比较消耗性能，其时间复杂度是O(n)，如果在某个位置同时插入1000个元素，那么它需要循环移动1000次。这种性能消耗是比较大的，Java中的ArrayList在插入大量数据的时候就会有较大的性能消耗。</p>
<h3 id="顺序存储结构的优缺点"><a href="#顺序存储结构的优缺点" class="headerlink" title="顺序存储结构的优缺点"></a>顺序存储结构的优缺点</h3><p>从上面的讨论中我们就可以看出来顺序存储结构的优点和缺点。</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>无需为表示表中元素之间的逻辑关系而增加额外的存储空间</td>
<td>插入插入和删除元素需要移动大量元素</td>
</tr>
<tr>
<td>可以快速地存取表中任一位置的元素</td>
<td>当线性表的长度变化较大时，难以确定存储空间的容量</td>
</tr>
<tr>
<td></td>
<td>造成存储空间的“碎片”</td>
</tr>
</tbody>
</table>
<h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p>为了解决线性存储结构不容易扩展，难以插入和删除的缺点。出现了链式存储的线性表，这种表的每一个元素中都有一个标识用来记录下一个元素地址。这样就不需要在内存中开辟连续的空间。它的存储形式是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-5076d727f47a9f05.png" alt="LinkedList"><br>它需要两个存储空间，一个数据域用来存储数据元素的信息，一个指针域用来存贮下个元素的地址，其中的每个元素又叫做结点（Node）。每个线性表都有一个指针指向它，这个指针叫做头指针（<em>这个指针是每个链表所必须的，即使这个链表为空</em>），这个指针指向头结点（如果存在的话），头结点的数据域是空或者可以存储表的长度等附加信息。最后一个结点是的指针域是NULL或者”^”符号。那么为啥要有这个头结点呢?不要头结点可以吗？那为啥链表的结尾不需要特殊处理呢？因为链表结尾的指针域为NULL或者”^”所以其插入操作是相同的。<br>答案是可以的，但是这会让链表对第一个结点之前的插入操作变得和其它元素不统一，为了解决这种不便，人为地加入了头结点。</p>
<h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>单链表的查询需要一个个遍历，因为它的存储空间不连续所以不能根据第一个元素的地址推断出第i个元素的地址，必须一个个查找，直到查找到第i个元素。因此它的时间复杂度是O(n)。</p>
<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>单链表的插入操作就比较简单，只需要改变插入点的前结点以及插入结点的指针即可。如下图所示<br><img src="http://upload-images.jianshu.io/upload_images/1513759-f5a638c6e223b1b7.png" alt="Insert Linked List"><br>关键的步骤为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s-&gt;next = p-&gt;next; </div><div class="line">p-&gt;next = s;</div></pre></td></tr></table></figure>
<p>这样就可以插入结点了，注意这里的。<br>单链表删除元素的操作也是比较简单，只要将要删除结点之前的结点跳过删除结点，然后指向删除结点之后的结点即可。如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-ad3a75e5ce4399f9.png" alt="Delete Node"><br>关键的步骤为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p-&gt;next = p-&gt;next-&gt;next</div></pre></td></tr></table></figure>
<h3 id="单链表和顺序存储结构的优缺点"><a href="#单链表和顺序存储结构的优缺点" class="headerlink" title="单链表和顺序存储结构的优缺点"></a>单链表和顺序存储结构的优缺点</h3><p>一、时间性能</p>
<ul>
<li>查找<ul>
<li>顺序存储结构为O(1)</li>
<li>单链表O(n)</li>
</ul>
</li>
<li>插入和删除<ul>
<li>顺序存储结构需要平均移动表长一半的元素，时间复杂度为O(n)</li>
<li>单链表在找出插入点的位置之后（这个过程的时间复杂度为O(n)），插入和删除的时间复杂度为O(1)</li>
</ul>
</li>
</ul>
<p>二、空间性能</p>
<ul>
<li>顺序存储结构需要预先分配存储空间的大小，分大了，浪费，分小了容易发生上溢。</li>
<li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。</li>
</ul>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>上文中提到的链表的实现是基于内存地址的，这是C语言或者其它可以操作内存的语言所容易实现。然而，对于不能操作内存的语言可以实现链表的存储结构吗？答案是可以的。实现的原理是：利用数组来代替指针，以此来描述单链表。这时数组的元素由两部分内容组成，data和cur。也就是说数组的每个元素对应一个data和cur。其中data用来存储数据，cur用来存储指针(相当于单链表中的next指针，它用来存放其后继元素在数组中的下标，我们把cur叫做游标)。<strong>这种用数组来描述的链表称为静态链表</strong>，为啥叫静态呢？因为其存储空间是顺序的，所以这也是一种顺序的存储结构，它的存储空间还是需要提前分配好的。它的结构如下所示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-90418e892596cf08.png" alt="static liner"><br>静态链表的第一个和最后一个元素做了特殊处理里面不存储数据，只存储cur值。链表中申请了但是没有被利用的空间是空闲空间。第一个元素中的cur存放的是第一个空闲空间元素的下标；最后一个元素的cur值为第一个元素的下表。</p>
<h3 id="静态链表的插入操作和删除操作"><a href="#静态链表的插入操作和删除操作" class="headerlink" title="静态链表的插入操作和删除操作"></a>静态链表的插入操作和删除操作</h3><p>动态链表在插入和删除的时候需要调用malloc()和free()这两个函数来实现。但是在静态链表中操作的是存储空间已经提前申请好的数组，所以只需要利用相关的策略就可以实现。比如我们要在上述的“乙”和“丁”之间插入“丙”元素，那我们该怎么做呢？我们只需要把“丙”放到下标为7的位置，然后“乙”的cur值改为7，丙的cur值改为3即可。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-32dceff8441401f0.png" alt="insert into static liner"><br>静态链表的删除操作和动态链表的删除有些不太一样，被删除之后相当于并入到了空闲链表，那么我们就把第一个元素的cur值标为要删除元素的下标（表明它是第一个空闲元素），然后让被删除元素的cur值指向之前第一个空闲元素的下标。这样之后该被删除的元素就并入了空闲元素之中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-cfb09c3fcb5f4c73.png" alt="delete from static liner"></p>
<p>静态链表的查询操作和动态链表的几乎相同，就不赘述了。</p>
<h3 id="静态链表的优缺点"><a href="#静态链表的优缺点" class="headerlink" title="静态链表的优缺点"></a>静态链表的优缺点</h3><table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入和删除操作，只需修改游标，不用移动元素，<br>从而改进了顺序存储结构中的插入和删除<br>需要移动大量元素的缺点</td>
<td>没有解决连续存储带来的长度难以确定的问题</td>
</tr>
<tr>
<td></td>
<td>失去了顺序存储结构随机存取的特性</td>
</tr>
</tbody>
</table>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>单链表有一个非常严重的问题：从链表中的一个结点出发，访问到链表中的所有结点，比如当从尾结点出发，要访问到所有的结点，必须先把指针移动头结点，然后从头开始遍历。为了解决这个问题，又引入了一种新的数据结构：循环链表。循环链表也就是说把原来单链表中终端结点的指针端由空改为指向头结点，这就使整个链表形成一个环，这种头尾相接的单链表成为单循环链表，简称循环链表（circular linked list）。这样虽然可以解决遍历其中任何一个结点的目的，但是还有一个问题：从头结点查找尾结点的时间复杂度为O(n)。我们可以通过将头指针移动位置来解决这个问题：<em>不用头指针，而是用指向终端结点的尾指针来表示循环链表，此时查找开始结点和终端结点都很方便了（时间复杂度都是O(1)）。</em><br><img src="http://upload-images.jianshu.io/upload_images/1513759-144be4c25748578e.png" alt="rear point circular linked list"><br>关于循环链表的其它操作和单链表的几乎是一样的，不再赘述。</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>循环链表是解决了单链表中查找所有结点的难题，但是它还存在一个问题：如果要查找某个结点的前驱结点，那么需要的时间复杂度是O(n)，因为我们要按照单向的指针遍历一遍。为了解决这个问题提出了双向链表的概念：双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。它的结构如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-48340e06fb86b26b.png" alt="structure of double linked list"></p>
<h3 id="双向链表的插入和删除"><a href="#双向链表的插入和删除" class="headerlink" title="双向链表的插入和删除"></a>双向链表的插入和删除</h3><p>双向链表的插入相对于单链表的插入要复杂一些，因为它涉及到两个指针的操作。如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-d028f13fa949a3e7.png" alt="insert into double linked list"><br>其中的关键步骤为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s-&gt;prior = p;  // 把p赋值给s的前驱，如①</div><div class="line">s-&gt;next = p-&gt;next; // 把p的后继赋值给s的后继，如②</div><div class="line">p-&gt;next-&gt;prior = s; // 把s赋值给p的后继的前驱，如③</div><div class="line">p-&gt;next = s; // 把s赋值给p的后继，如④</div></pre></td></tr></table></figure>
<p>相对于插入操作，删除操作相对比较简单，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-c899193e34b4442d.png" alt="delete from double linked list"><br>其中的关键步骤为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p-&gt;prior-&gt;next = p-&gt;next; // 将p的后继赋值给其前驱的后继，如①</div><div class="line">p-&gt;next-&gt;prior = p-&gt;prior; // 将p的前驱赋值给p的后继的前驱，如②</div><div class="line">free(p); // 释放p</div></pre></td></tr></table></figure>
<p>相对于单链表其查找速度更快了，但是它多出了一位来存储指向其前继结点的指针，因此是典型的用空间换取时间的做法。另外循环链表的插入相对来说比较复杂，需要把握好每一步的顺序，否则会出错。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">击水湘江</p>
              <p class="site-description motion-element" itemprop="description">努力让明天的自己爱上今天的自己！</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">38</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">击水湘江</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
