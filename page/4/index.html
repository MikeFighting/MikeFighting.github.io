<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/mike_apple-touch-icon.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/mike32x32.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/mike16x16.png?v=6.0.3">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT">


<meta name="description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:type" content="website">
<meta property="og:title" content="击水湘江">
<meta property="og:url" content="https://mikefighting.github.io/page/4/index.html">
<meta property="og:site_name" content="击水湘江">
<meta property="og:description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="击水湘江">
<meta name="twitter:description" content="努力让明天的自己爱上今天的自己！">






  <link rel="canonical" href="https://mikefighting.github.io/page/4/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>击水湘江</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">击水湘江</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Born To Fight!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/11/vapor-prepare-data-base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/11/vapor-prepare-data-base/" itemprop="url">Swift后端Vapor安装数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-11T09:52:02+08:00">2017-08-11</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1513759-b14c0ae08140a1d3.png" alt="MySQL"></p>
<p>Vapor中使用<code>Fluent</code>作为数据库的驱动，它现在可支持的数据库类型有：MySQL，SQL lite，MongoDB，PostgreSQL。因为MySQL用得较多，我们先来学习它。</p>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="安装MySQL-Provider"><a href="#安装MySQL-Provider" class="headerlink" title="安装MySQL-Provider"></a>安装<code>MySQL-Provider</code></h3><p>在<code>Package.swift</code>文件中加入</p>
<pre><code>.Package(url: &quot;https://github.com/vapor/mysql-provider.git&quot;, majorVersion: 2)</code></pre><p>然后执行执行<code>vapor clean</code>和<code>rm -rf .build Package.pins</code>，最后执行<code>vapor update</code>和<code>vapor build</code>。<br>安装完MySql之后报错<code>mysql/mysql.h file not found</code>以及<code>Could not build Objective-C module CMySQL</code>，这时因为MySql数据库需要更新，执行下面的指令</p>
<pre><code>brew update &amp;&amp; brew install mysql vapor/tap/cmysql pkg-config</code></pre><p>然后再执行<code>vapor xcode</code>就可以运行成功了。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="在Droplet中添加驱动"><a href="#在Droplet中添加驱动" class="headerlink" title="在Droplet中添加驱动"></a>在Droplet中添加驱动</h3><p>我们要往<code>Config</code>对象中添加相应的<code>Provider</code>，如下所示</p>
<pre><code class="Swift"><span class="keyword">import</span> MySQLProvider
<span class="keyword">let</span> config = <span class="keyword">try</span> <span class="type">Config</span>()
<span class="keyword">try</span> config.addProvider(<span class="type">MySQLProvider</span>.<span class="type">Provider</span>.<span class="keyword">self</span>)
<span class="keyword">let</span> drop = <span class="keyword">try</span> <span class="type">Droplet</span>(config)</code></pre>
<h3 id="配置Fluent"><a href="#配置Fluent" class="headerlink" title="配置Fluent"></a>配置Fluent</h3><p>在<code>fluent.json</code>文件中加入如下的配置</p>
<pre><code>{
    &quot;//&quot;: &quot;The underlying database technology to use.&quot;,
    &quot;//&quot;: &quot;memory: SQLite in-memory DB.&quot;,
    &quot;//&quot;: &quot;sqlite: Persisted SQLite DB (configure with sqlite.json)&quot;,
    &quot;//&quot;: &quot;Other drivers are available through Vapor providers&quot;,
    &quot;//&quot;: &quot;https://github.com/search?q=topic:vapor-provider+topic:database&quot;,
    &quot;driver&quot;: &quot;mysql&quot;,
}</code></pre><h3 id="配置MySQL"><a href="#配置MySQL" class="headerlink" title="配置MySQL"></a>配置MySQL</h3><p>在Config文件夹下面新建文件<code>mysql.json</code>，并添加如下内容</p>
<pre><code>{
    &quot;hostname&quot;: &quot;localhost&quot;,
    &quot;user&quot;: &quot;root&quot;,
    &quot;password&quot;: &quot;yourPassword&quot;,
    &quot;database&quot;: &quot;yourDatabase&quot;
    &quot;poort&quot;: &quot;3306&quot;
}      </code></pre><p>也可以将证书作为url传入MySQL。</p>
<pre><code>{
&quot;url&quot;: &quot;http://root:password@172.0.0.1/hello&quot;
}</code></pre><h3 id="多份读取（Read-Replicas）"><a href="#多份读取（Read-Replicas）" class="headerlink" title="多份读取（Read Replicas）"></a>多份读取（Read Replicas）</h3><p>多份读取可以通过配置hostname或者是<code>readReplicas</code>接口数组来进行配置。在mysql.josn中加入：</p>
<pre><code>{
   {
    &quot;master&quot;: &quot;master.mysql.foo.com&quot;,
    &quot;readReplicas&quot;: [&quot;read01.mysql.foo.com&quot;, &quot;read02.mysql.foo.com&quot;],
    &quot;user&quot;: &quot;root&quot;,
    &quot;password&quot;: &quot;password&quot;,
    &quot;database&quot;: &quot;hello&quot;
   }
}</code></pre><p><em>Tip:也可以将readReplicas用字符串表示，多个字符串用逗号分隔开。</em></p>
<h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><p>你可以在Routes中得到<code>MySQL Driver</code>（前提是在你自己的MySQL数据库中创建了<code>your_table</code>)表。</p>
<pre><code class="Swift"><span class="keyword">import</span> MySQLProvider
<span class="keyword">get</span>(<span class="string">"mysql"</span>) { req <span class="keyword">in</span>

           <span class="keyword">let</span> mysqlDriver = <span class="keyword">try</span> <span class="keyword">self</span>.mysql()
           <span class="keyword">let</span> user = <span class="keyword">try</span> mysqlDriver.raw(<span class="string">"SELECT * FROM your_table"</span>)
           <span class="keyword">let</span> reusltJon = <span class="keyword">try</span> <span class="type">JSON</span>(node: user)
           <span class="keyword">return</span> reusltJon

       }</code></pre>
<p>然后在浏览器中输入<code>http://localhost:8080/mysql</code>，如果看到输出了相应的JSON传就证明安装成功了。</p>
<h3 id="配置缓存"><a href="#配置缓存" class="headerlink" title="配置缓存"></a>配置缓存</h3><p>在<code>Config/droplet.json</code>里面可以配置<code>fluent</code>缓存，这里<code>fluent</code>缓存走的是<code>mysql</code>：</p>
<pre><code class="Swift">{
 <span class="string">"driver"</span>: <span class="string">"fluent"</span>
}</code></pre>
<p>下次，当启动Droplet的时候，如果出现：</p>
<pre><code class="bash">Database prepared</code></pre>
<p>就说明安装成功了。</p>
<h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><ol>
<li>如果运行出现 </li>
</ol>
<pre><code class="bash">The current <span class="built_in">hash</span> key <span class="string">"0000000000000000"</span> is not secure.
Update hash.key <span class="keyword">in</span> Config/crypto.json before using <span class="keyword">in</span> production.
Use `openssl rand -base64 &lt;length&gt;` to generate a random string.
The current cipher key <span class="string">"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="</span> is not secure.
Update cipher.key <span class="keyword">in</span> Config/crypto.json before using <span class="keyword">in</span> production.
Use `openssl rand -base64 32` to generate a random string.</code></pre>
<p>这说明我们需要运行<code>openssl rand -base64 &lt;length&gt;</code>，以及<code>openssl rand -base64 32</code>来产生新的hash key和cipher key，并且将原来的数值替换掉。</p>
<ol start="2">
<li>MySql更改密码：</li>
</ol>
<p>请参考：</p>
<ol>
<li><a href="https://stackoverflow.com/questions/2101694/mysql-how-to-set-root-password-to-null" target="_blank" rel="noopener">https://stackoverflow.com/questions/2101694/mysql-how-to-set-root-password-to-null</a> </li>
<li><a href="https://stackoverflow.com/questions/30692812/mysql-user-db-does-not-have-password-columns-installing-mysql-on-osx" target="_blank" rel="noopener">https://stackoverflow.com/questions/30692812/mysql-user-db-does-not-have-password-columns-installing-mysql-on-osx</a></li>
<li><a href="https://sraji.wordpress.com/2011/08/10/how-to-reset-mysql-root-password/" target="_blank" rel="noopener">https://sraji.wordpress.com/2011/08/10/how-to-reset-mysql-root-password/</a></li>
<li><a href="https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating" target="_blank" rel="noopener">https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating</a></li>
<li><a href="https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating/9704993#comment16367803_9704993" target="_blank" rel="noopener">https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating/9704993#comment16367803_9704993</a></li>
</ol>
<p>需要注意的是：<em><code>sudo mysqld_safe --skip-grant-tables</code>执行完之后，要重新打开一个终端执行</em>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/10/swift-server-vapor-validation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/10/swift-server-vapor-validation/" itemprop="url">Vapor中的数据校验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-10T07:10:13+08:00">2017-08-10</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>   <img src="http://upload-images.jianshu.io/upload_images/1513759-267da7a2929f0562.jpg" alt="Validation"><br>服务端在有数据请求时需要对数据进行校验然后返回响应的校验结果，比如要求必须输入邮箱，必须输入电话等，Validation工具给我们提供了非常方便的常用操作，接下来就对其使用过程做以总结（<em>本文用到的是Validation 1.2.0版本</em>）。</p>
<h2 id="Vapor中添加Validation依赖包"><a href="#Vapor中添加Validation依赖包" class="headerlink" title="Vapor中添加Validation依赖包"></a>Vapor中添加Validation依赖包</h2><p>在<code>Package.swift</code>文件中添加如下的依赖，比如：</p>
<pre><code>.Package(url: &quot;https://github.com/vapor/vapor.git&quot;, majorVersion: 2),
.Package(url: &quot;https://github.com/vapor/validation-provider.git&quot;, majorVersion: 1)</code></pre><blockquote>
<p>之后要执行<code>vapor clean</code>或者<code>rm -rf .build Package.pins</code>，然后执行<code>vapor update</code>或者<code>swift package update</code>，<code>vapor xcode</code>，这样才可以安装好依赖。</p>
</blockquote>
<h2 id="校验实例"><a href="#校验实例" class="headerlink" title="校验实例"></a>校验实例</h2><h3 id="Alphanumeric校验"><a href="#Alphanumeric校验" class="headerlink" title="Alphanumeric校验"></a>Alphanumeric校验</h3><p> 接下来我们来做一个简单的校验，校验输入的字符串是否是a-z或者0-9在请求中加入如下代码：</p>
<pre><code class="Swift"><span class="keyword">get</span>(<span class="string">"alpha"</span>) { request <span class="keyword">in</span>
            <span class="keyword">guard</span> <span class="keyword">let</span> input = request.data[<span class="string">"input"</span>]?.string <span class="keyword">else</span> {
                <span class="keyword">throw</span> <span class="type">Abort</span>.badRequest
            }
            <span class="keyword">let</span> validInput = <span class="keyword">try</span> input.tested(by: <span class="type">OnlyAlphanumeric</span>())
            <span class="keyword">return</span> <span class="string">"validated:\(validInput)"</span>
}</code></pre>
<p>我们运行程序，然后在PostMan中输入<a href="http://localhost:8080/alpha?input=example@github.com，这时会得到下面的返回值：" target="_blank" rel="noopener">http://localhost:8080/alpha?input=example@github.com，这时会得到下面的返回值：</a></p>
<pre><code class="Swift">{<span class="string">"identifier"</span>:<span class="string">"Validation.ValidatorError.failure"</span>,<span class="string">"reason"</span>:<span class="string">"Internal Server Error"</span>,<span class="string">"debugReason"</span>:<span class="string">"OnlyAlphanumeric failed validation: example@github.com is not alphanumeric"</span>,<span class="string">"error"</span>:<span class="literal">true</span>}</code></pre>
<p>这也就说明了，我们传输的问本内容不符合<code>alphanumeric</code>。<br>然后我们将URL改为<code>http://localhost:8080/alpha?input=example123</code>，然后就会看到我们的返回值</p>
<pre><code>validated:example</code></pre><h3 id="邮箱校验"><a href="#邮箱校验" class="headerlink" title="邮箱校验"></a>邮箱校验</h3><p>我们可以利用<code>EmailValidator</code>来做邮箱的校验，方法同上面一样：</p>
<pre><code class="Swift"><span class="keyword">get</span>(<span class="string">"email"</span>) { request <span class="keyword">in</span>
            <span class="keyword">guard</span> <span class="keyword">let</span> input = request.data[<span class="string">"input"</span>]?.string <span class="keyword">else</span> {
                <span class="keyword">throw</span> <span class="type">Abort</span>.badRequest
            }
            <span class="keyword">let</span> validaInput = <span class="keyword">try</span> input.tested(by: <span class="type">EmailValidator</span>())
            <span class="keyword">return</span> <span class="string">"validated:\(validaInput)"</span>
    }     </code></pre>
<p>然后我们输入URL：<a href="http://localhost:8080/email?input=wallaceicdi@outlook.com，然后就会的到：" target="_blank" rel="noopener">http://localhost:8080/email?input=wallaceicdi@outlook.com，然后就会的到：</a></p>
<pre><code>Validated: wallaceicdi@outlook.com</code></pre><h3 id="其余自带校验工具"><a href="#其余自带校验工具" class="headerlink" title="其余自带校验工具"></a>其余自带校验工具</h3><table>
<thead>
<tr>
<th>校验类</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>Unique</td>
<td>输入内容是否唯一</td>
<td>someCharacter.tested(by: Unique())</td>
</tr>
<tr>
<td>Compare</td>
<td>输入内容的数值比较</td>
<td>int.tested(by:Compare.greaterThan(1))</td>
</tr>
<tr>
<td>Contains</td>
<td>输入的内容是否包含某个</td>
<td>someArray.tested(by: Contains(“1”))</td>
</tr>
<tr>
<td>Count</td>
<td>输入的内容个数</td>
<td>someArray.tested(by: Count.max(2))</td>
</tr>
<tr>
<td>Equals</td>
<td>输入的内容是否相同</td>
<td>someConent.tested(by: Equals.init(“equal”))</td>
</tr>
<tr>
<td>In</td>
<td>输入内容是否被包含</td>
<td>input.tested(by: In.init([“1”,”2”,”3”]))</td>
</tr>
</tbody></table>
<h2 id="创建自己的校验工具"><a href="#创建自己的校验工具" class="headerlink" title="创建自己的校验工具"></a>创建自己的校验工具</h2><p>通过参考工具自带的<code>Equals.Swift</code>：</p>
<pre><code class="Swift"><span class="comment">/// Validates that matches a given input</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Equals</span>&lt;<span class="title">T</span>&gt;: <span class="title">Validator</span> <span class="title">where</span> <span class="title">T</span>: <span class="title">Validatable</span>, <span class="title">T</span>: <span class="title">Equatable</span> </span>{
    <span class="comment">/// The value expected to be in sequence</span>
    <span class="keyword">public</span> <span class="keyword">let</span> expectation: <span class="type">T</span>

    <span class="comment">/// Initialize a validator with the expected value</span>
    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> expectation: <span class="type">T</span>) {
        <span class="keyword">self</span>.expectation = expectation
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">validate</span><span class="params">(<span class="number">_</span> input: T)</span></span> <span class="keyword">throws</span> {
        <span class="keyword">guard</span> input == expectation <span class="keyword">else</span> {
            <span class="keyword">throw</span> error(<span class="string">"\(input) does not equal expectation \(expectation)"</span>)
        }
    }
}</code></pre>
<p>从这里面我们可以看出，只要遵守<code>Validator</code>协议，并且实现其<code>validate</code>方法即可。</p>
<p>参考文件：<br><a href="https://github.com/vapor/validation/blob/master/Tests/ValidationTests/ValidationConvenienceTests.swift" target="_blank" rel="noopener">https://github.com/vapor/validation/blob/master/Tests/ValidationTests/ValidationConvenienceTests.swift</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/07/wwdc-advanced-swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/wwdc-advanced-swift/" itemprop="url">Swift进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-07T22:29:53+08:00">2017-08-07</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文是对<a href="https://developer.apple.com/videos/play/wwdc2014/404/" target="_blank" rel="noopener">WWDC2014–AdvancedSwift的总结</a></p>
<h2 id="改变参数名"><a href="#改变参数名" class="headerlink" title="改变参数名"></a>改变参数名</h2><p>比如我们要改变Thing对象的参数名：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>{
<span class="keyword">init</span>(location: <span class="type">Thing?</span>, name:<span class="type">String</span>,
     longDescription: <span class="type">String</span>){ ... }
}</code></pre>
<p>如果我们不想用默认的<code>Thing.init(location:Beijing, name:&quot;wall&quot;,longDescription:&quot;An amazing city&quot;)</code>这种方式进行初始化，我们可以在参数前面添加<code>label</code>的形式：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>{
  <span class="keyword">init</span>(newLocation location: <span class="type">Thing?</span>, newName name: <span class="type">String</span>,
newLongDescription longDescription: <span class="type">String</span>) { ... }
}</code></pre>
<p>这样我们就可以使用<code>Thing.init(newLocation:Beijing, newName:&quot;wall&quot;,newLongDescription:&quot;An amazing city&quot;)</code>这种参数来进行初始化。</p>
<h2 id="匿名参数"><a href="#匿名参数" class="headerlink" title="匿名参数"></a>匿名参数</h2><p>比如下面的例子，我们不需要字典中的value，那么我们就只需要遍历其<code>key</code>即可。</p>
<pre><code class="Swift"><span class="keyword">for</span> (key,<span class="number">_</span>) <span class="keyword">in</span> dictionary {
 <span class="built_in">print</span>(\(key))
}</code></pre>
<p>在这个例子中，我们使用下划线<code>_</code>来进行你匿名操作，略过了我们不关心的value值，而只输出了<code>key</code>的值。</p>
<p>在上面<code>Thing</code>的例子中，如果我们要移除其参数名称，那么我们可以将<code>label</code>变为下划线，这样我们在调用的时候就不必写参数名了。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>{
  <span class="keyword">init</span>(<span class="number">_</span> location: <span class="type">Thing?</span>, <span class="number">_</span> name: <span class="type">String</span>,

   <span class="number">_</span> longDescription: <span class="type">String</span>) { ... }
}</code></pre>
<p>这样我们就可以使用<code>Thing.init(Beijing, &quot;wall&quot;,&quot;An amazing city&quot;)</code>来初始化了。</p>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>如果我们要给上面的<code>Thing</code>对象添加一个方法<code>performPull</code>来执行其是否可以被拉动的方法。</p>
<pre><code class="Swift">        <span class="comment">// The parser will call this. func performPull(object: Thing) </span>
{ <span class="keyword">if</span> <span class="comment">/* object is   pullable */</span> {      <span class="comment">/* pull it */</span> }<span class="keyword">else</span>{      <span class="comment">/* complain */</span>   } } </code></pre>
<p>这时我们可以添加一个Protocol：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Pullable</span> </span>{
  <span class="function"><span class="keyword">func</span> <span class="title">pull</span><span class="params">()</span></span>
} 
<span class="class"><span class="keyword">class</span> <span class="title">Boards</span>: <span class="title">Thing</span>, <span class="title">Pullable</span> </span>{
<span class="function"><span class="keyword">func</span> <span class="title">pull</span><span class="params">()</span></span> {
....
}
}</code></pre>
<p>这样我们的<code>Boards</code>类就遵守了<code>Pullable</code>协议，当我们来检查某个对象是否遵守了某个协议时，我们可以这样做：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">performPull</span><span class="params">(object: Thing)</span></span> { <span class="keyword">if</span> <span class="keyword">let</span> pullableObject = object <span class="keyword">as</span> <span class="type">Pullable</span> { pullableObject.pull()    }<span class="keyword">else</span>{ 
     <span class="built_in">print</span>(<span class="string">"You are not sure how to print a \(object.name)."</span>)
   } 
} </code></pre>
<h3 id="对象转String"><a href="#对象转String" class="headerlink" title="对象转String"></a>对象转String</h3><p>如果我们要打印某个对象，并且需要打印出其中的有效信息，那么我们要像OC中实现<code>description</code>方法一样，来遵守<code>CustomStringConvertible</code>协议并且实现其中的<code>description</code>方法。<br>还有很多类似的方法</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ExpressibleByStringLiteral</td>
<td>“abc”</td>
</tr>
<tr>
<td>ExpressibleByArrayLiteral</td>
<td>[ a, b, c ]</td>
</tr>
<tr>
<td>ExpressibleByDictionaryLiteral</td>
<td>[a: x, b: y]</td>
</tr>
<tr>
<td>Sequence</td>
<td>for x in sequence</td>
</tr>
<tr>
<td>CustomStringConvertible</td>
<td>“(convertible)”</td>
</tr>
</tbody></table>
<p>同样，如果我们要对某个对象使用下表，那么我们要<code>subscript</code>。怎样对某个类使用下表呢？</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p> 比如以下三个方法，其参数的形式是一样的，但是其参数类型不同，我们想把它变成一个函数，这时候我们最常想到的做法就是使用<code>Any</code>来表示任何类型的参数和任何类型的返回值。</p>
<pre><code class="Swift"><span class="comment">// 之前的三个函数</span>
<span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">(interestingValue: String)</span></span> {
  <span class="built_in">println</span>(<span class="string">"[peek] \(interestingValue)"</span>)
}
<span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">(interestingValue: Int)</span></span> {
  <span class="built_in">println</span>(<span class="string">"[peek] \(interestingValue)"</span>)
}
<span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">(interestingValue: Float)</span></span> {
  <span class="built_in">println</span>(<span class="string">"[peek] \(interestingValue)"</span>)
} 
<span class="comment">// 变为一个函数</span>
<span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">(interestingValue: <span class="keyword">Any</span>)</span></span> {
  <span class="built_in">println</span>(<span class="string">"[peek] \(interestingValue)"</span>)
} </code></pre>
<p>但是这有个问题，在我们要调用返回值的某个方法时候编译器会报错，因为我们的返回值<code>Any</code>并没有所调用的方法，也就是说我们需要一次强转，强转在代码层面是很难看的，也很麻烦，这时候我们就可以使用泛型来解决这个问题，如果我们使用了泛型，那么编译器会将输入的参数和输出的参数给我们推断出来，这样就不必强转了。并且当编译器可以推断出来是那种type的时候它会给我们做各种优化。</p>
<p>泛型在Swift中很常见，比如：<br>Array<t>以及Dictionary&lt;K,V&gt;：是范型的结构体<br>Optional<t>：范型枚举<br>我们也可以创建自己的泛型类</t></t></p>
<h3 id="Type间的关系"><a href="#Type间的关系" class="headerlink" title="Type间的关系"></a>Type间的关系</h3><p>比如我们要转换两个变量的值，我们可以调用下面的方法：</p>
<pre><code class="Swift"> <span class="comment">// Exchange the values of x and y</span>
<span class="function"><span class="keyword">func</span> <span class="title">swap</span>&lt;T&gt;<span class="params">(<span class="keyword">inout</span> x: T, <span class="keyword">inout</span> y: T)</span></span> { 
<span class="keyword">let</span> tmp = x     x = y     y = tmp 
} 
<span class="keyword">var</span> studentCount = <span class="number">42</span>
<span class="keyword">var</span> teacherCount = <span class="number">7</span>
<span class="built_in">swap</span>(&amp;studentCount, &amp;teacherCount) <span class="comment">// OK</span>
<span class="keyword">var</span> schoolName = “<span class="type">Homestead</span> <span class="type">High</span> <span class="type">School</span><span class="string">"</span>
<span class="string">swap(&amp;studentCount, &amp;schoolName) // error: 'Int' is not identical to 'String'</span></code></pre>
<p>有了这样的编译器提示，这样我们就可以保证了输入的两种类型是相同的，这样就会更加<strong>安全</strong>，代码也会少很多bug。</p>
<h3 id="对泛型进行Protocol限制"><a href="#对泛型进行Protocol限制" class="headerlink" title="对泛型进行Protocol限制"></a>对泛型进行Protocol限制</h3><p>我们可以给泛型加上限制，让它遵守某些协议，比如：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">indexOf</span>&lt;T&gt;<span class="params">(sought: T, inArray array: T[])</span></span> -&gt; <span class="type">Int?</span> {
  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..array.<span class="built_in">count</span> {
    <span class="keyword">if</span> array[i] == sought { <span class="comment">// error: could not find an overload for '==' that accepts the supplied arguments </span>
      <span class="keyword">return</span> i
} } 
<span class="keyword">return</span> <span class="literal">nil</span> } </code></pre>
<p>这是编译不通过的，因为编译器不知道我们的<code>T</code>是否遵守了<code>Equatable</code>协议，如果我们将其变为<code>func indexOf&lt;T:Equatable&gt;(Sought: T, inArray array: T[]) -&gt; Int?</code>就可以编译通过了。</p>
<h3 id="实现Equatable协议"><a href="#实现Equatable协议" class="headerlink" title="实现Equatable协议"></a>实现Equatable协议</h3><p>Enum，Class以及Struct都可以实现协议，比如我们有如下的Struct，实现Equatable协议如下：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">Temperature</span> : <span class="title">Equatable</span> </span>{ 
  <span class="keyword">let</span> value: <span class="type">Int</span> = <span class="number">0</span>
}

<span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Temperature, rhs: Temperature)</span></span> -&gt; <span class="type">Bool</span> {
  <span class="keyword">return</span> lhs.value == rhs.value
} </code></pre>
<p>当我们实现了<code>Equatable</code>，那么对于<code>!=</code>这种操作，Swift在底层就会自动帮我们实现。</p>
<h2 id="斐波那契数列的例子"><a href="#斐波那契数列的例子" class="headerlink" title="斐波那契数列的例子"></a>斐波那契数列的例子</h2><p>什么是菲波那切数列？数列的前两个数相加等于后面的一个数。 <code>0, 1, 1, 2, 3, 5, 8, 13, 21, ...</code><br>我们创建一个菲波那切数列的函数：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">Double</span> {
  <span class="keyword">return</span> n &lt; <span class="number">2</span> ? <span class="type">Double</span>(n) : fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)
} </code></pre>
<p>这个函数的返回值仍然是一个函数，它是一个递归调用的函数，这个函数的效率极低。当你在Playground中实验的时候就会卡的不行。如果调用<code>fibonacci(44)</code>估计要十几秒的时间。原因就是它需要一个调用一个树状结构，我们用<code>fibonacci(5)</code>做个图示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-1d9abd75b75e42ea.png" alt="fibonacci(n:5)"></p>
<p>在图中我们发现fib(1)，fib(2)等函数被持续的调用，我们如果可以把这个已经计算过的数值存下来，那么以后不是就就可以直接计算了呢？这样不就可以极大的提高计算的速度。这样我们就只计算下面带星号的函数即可：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-12e6e8ab9ae865d9.png" alt="valuable func"></p>
<p>这时最先想到的就是用一个全局的字典手动来存储这个数值，实现方法如下：</p>
<pre><code class="Swift"><span class="keyword">var</span> fibonacciMemo = <span class="type">Dictionary</span>&lt;<span class="type">Int</span>, <span class="type">Double</span>&gt;() <span class="comment">// implementation detail </span> <span class="comment">// Return the nth fibonacci number: 0, 1, 1, 2, 3, 5, 8, 13, 21, ...</span> <span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">Double</span> { 
  <span class="keyword">if</span> <span class="keyword">let</span> result = fibonacciMemo[n] {
    <span class="keyword">return</span> result
  }
  <span class="keyword">let</span> result = n &lt; <span class="number">2</span> ? <span class="type">Double</span>(n) : fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)
  fibonacciMemo[n] = result
  <span class="keyword">return</span> result
} 

<span class="comment">// 1.61803399...</span>
<span class="keyword">let</span> phi = fibonacci(<span class="number">45</span>) / fibonacci(<span class="number">44</span>) <span class="comment">//0.1 seconds = 100x speedup </span></code></pre>
<p>这样一来，我们之前计算<code>fibonacci(44)</code>中十几秒的计算时间一下子缩短到了0.1秒，缩减了100倍。<br>如果这样做的话，我们以后每次用到这个方法就都需要写一个字典，每次把这个计算过程过一遍，并且更重要的是它不具备通用型，如果我要放进去字符串，那就不起作用了。下面我们写一个通用的函数来解决这种需要保留中间数值，并且不需要额外的全局变量<code>fibonacciMemo</code>就可以解决问题的方法。先看一个不递归时候的函数：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">memoize</span>&lt;T: Hashable, U&gt;<span class="params">(work: @escaping <span class="params">(T)</span></span></span>-&gt;<span class="type">U</span>) -&gt; (<span class="type">T</span>)-&gt;<span class="type">U</span> {

    <span class="keyword">var</span> memo = <span class="type">Dictionary</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt;()
    <span class="keyword">return</span> { x <span class="keyword">in</span>
        <span class="keyword">if</span> <span class="keyword">let</span> q = memo[x] { <span class="keyword">return</span> q }
        <span class="keyword">let</span> r = work(x)
        memo[x] = r
        <span class="keyword">return</span> r
    }
}</code></pre>
<p>然后再来一个可以递归的方法：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">memoize</span>&lt;T: Hashable, U&gt;<span class="params">(work: @escaping <span class="params">(<span class="params">(T)</span></span></span></span>-&gt;<span class="type">U</span>, <span class="type">T</span>) -&gt; <span class="type">U</span>) -&gt; (<span class="type">T</span>)-&gt;<span class="type">U</span> {
    <span class="keyword">var</span> memo = <span class="type">Dictionary</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt;()
    <span class="function"><span class="keyword">func</span> <span class="title">wrap</span><span class="params">(x: T)</span></span>-&gt;<span class="type">U</span> {
        <span class="keyword">if</span> <span class="keyword">let</span> q = memo[x] { <span class="keyword">return</span> q }
        <span class="keyword">let</span> r = work(wrap, x)
        memo[x] = r
        <span class="keyword">return</span> r
    }
    <span class="keyword">return</span> wrap
}</code></pre>
<p>这两个函数包含了swift中的很多高级语法：</p>
<ul>
<li>强大的编译器推断匹配,比如你调用：</li>
</ul>
<pre><code class="Swift">     <span class="keyword">let</span> fibonacci = memoize {
    (n: <span class="type">Int</span>) <span class="keyword">in</span>
    <span class="type">String</span>(n)
}</code></pre>
<p>那么上面泛型中的<code>T</code>就会被推断成<code>Int</code>，而<code>U</code>怎会被推断成<code>String</code>。</p>
<ul>
<li>尾随闭包，比如调用<code>let fibonacci = memoize {...}</code>的时候。</li>
<li>更通用，更安全，性能更高的泛型函数。</li>
</ul>
<p>关于这个函数，有人专门写了一篇博客来说明:<a href="https://medium.com/@mvxlr/swift-memoize-walk-through-c5224a558194" target="_blank" rel="noopener">https://medium.com/@mvxlr/swift-memoize-walk-through-c5224a558194</a></p>
<h2 id="泛型结构体的一个例子"><a href="#泛型结构体的一个例子" class="headerlink" title="泛型结构体的一个例子"></a>泛型结构体的一个例子</h2><pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">StringStack</span> </span>{
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(x: String)</span></span> {
items += x } 
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">String</span> {
    <span class="keyword">return</span> items.removeLast()
} 
  <span class="keyword">var</span> items: <span class="type">String</span>[]
}</code></pre>
<p>这里我们创建了一个字符串的栈，如果我们要变为泛型，则需要：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>{
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(x: T)</span></span> {
items += x } 
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">T</span> {
    <span class="keyword">return</span> items.removeLast()
} 
  <span class="keyword">var</span> items: <span class="type">T</span>[]
}</code></pre>
<p>这样我们就可以往里面放任何数据类型了：</p>
<pre><code class="Swift"><span class="keyword">var</span> intStack = <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()
intStack.push(<span class="number">42</span>)</code></pre>
<p>但是当我们需要对这个Stack做<code>for in</code>操作时候，却得到了下面的错误提示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-9d39a23bddecaefd.png" alt="for_in_error"><br>这时候我们需要理解下，什么是<code>Sequence</code>，当Swift给我们做<code>for in</code>操作的时候在底层给我们做了什么？</p>
<pre><code class="Swift"><span class="comment">// 我们代码</span>
 <span class="keyword">for</span> x <span class="keyword">in</span> someSequence {
  ...
 }
<span class="comment">// Swift翻译后的代码</span>
<span class="keyword">var</span> __g = someSequence.generate()
<span class="keyword">while</span> <span class="keyword">let</span> x = __g.next(){
...
}</code></pre>
<p>从上面可以看到，首先我们的<code>someSequence</code>需要关联一个<code>generate</code>，并且这个<code>generate</code>需要实现一个<code>next</code>方法，这样我们就可以对这个结构体做<code>for in</code>操作了。<br>我们先看这个<code>generate()</code>，它是一个结构体，其遵守<code>Generator</code>（<code>protocol</code>)。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Generator</span> </span>{
 <span class="keyword">typealias</span> <span class="type">Element</span>
 <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> ?
}</code></pre>
<p>然后我们创建一个遵守<code>Generator</code>的结构体：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">StackGenerator</span>&lt;<span class="title">T</span>&gt; : <span class="title">Generator</span> </span>{
  <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">T</span>
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">T?</span> {
    <span class="keyword">if</span> items.isEmpty { <span class="keyword">return</span> <span class="literal">nil</span> }
    <span class="keyword">let</span> ret = items[<span class="number">0</span>]
    items = items[<span class="number">1</span>..items.<span class="built_in">count</span>]
    <span class="keyword">return</span> ret
} 
  <span class="keyword">var</span> items: <span class="type">Slice</span>&lt;<span class="type">T</span>&gt;
} </code></pre>
<p>那么什么是<code>Sequence</code>呢？它也是一个<code>protocol</code></p>
<pre><code class="Swift"> <span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>{
  <span class="keyword">typealias</span> <span class="type">GeneratorType</span> : <span class="type">Generator</span>
  <span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">GeneratorType</span>
} </code></pre>
<p>它关联了一个<code>Generator</code>，然后我们让新建的<code>Stack</code>遵守这个<code>Sequence</code>协议：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> : <span class="title">Sequence</span> </span>{
  <span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">StackGenerator</span>&lt;<span class="type">T</span>&gt; {
    <span class="keyword">return</span> <span class="type">StackGenerator</span>( items[<span class="number">0</span>..itemCount] )
  }
} </code></pre>
<p>这样就可以对<code>Stack</code>做<code>for in</code>操作了。</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">peekStack</span><span class="params">(s: Stack&lt;T&gt;)</span></span> {
  <span class="keyword">for</span> x <span class="keyword">in</span> s { <span class="built_in">println</span>(x) }
} </code></pre>
<p>关于<code>Sequence</code>和<code>Generator</code>的详细说明，请看我的另外一篇博客<a href="https://mikefighting.github.io/2017/07/28/note-advance-swift-collection-protocols/">Swift中Collection的Protocol</a></p>
<h3 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h3><p>Swift是静态编译，很小的runtime。写好的代码传到设备上之后不需要再重新编译，只需要等着运行即可。Swift中的编译器，相比于C，C++，Objective-C的Clang，做了一步优化：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-3cb2500863892632.png" alt="SwiftComplier"><br>除此之外，Swift会在编译时候做以下几点</p>
<ul>
<li>全局分析App</li>
<li>使用Struct不会对Runtime的性能造成影响</li>
<li>Int，Float等很多标准库都是Struct的</li>
</ul>
<p>Swift还有去虚拟化的特点，它可以让再运行期确定的事情放到了编译期，这样就会更快了，详细内容可以参考我的另外一篇博客<a href="https://mikefighting.github.io/2017/08/01/Why-Swift-IS-swift/">为什么Swift比OC快</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/05/avfoundation-play/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/05/avfoundation-play/" itemprop="url">AVFoundation--视频播放</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-05T12:23:18+08:00">2017-08-05</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用<code>AVPlayer</code>对象可以用来控制asset的播放。在播放期间，你可以使用AVPlayerItem实例来asset的presentation state。并且一个<code>AVPlayerItemTrack</code>对象可以管理某个独立track的展示状态。展示一个视频，你可以使用<code>AVPlayerLayer</code>对象。</p>
<h2 id="播放Assets"><a href="#播放Assets" class="headerlink" title="播放Assets"></a>播放Assets</h2><p>一个player是一个控制器对象，你可以使用它来管理一个asset的播放，比如，开始和停止播放以及寻找特殊的时间点。使用<code>AVPlayer</code>实例来播放一个asset。你可以使用<code>AVQueuePlayer</code>对象来按序播放一系列的item（AVQueuePlayer是AVPlayer的一个子类）。</p>
<p>一个player给你提供了播放状态的信息，如果有需要，你可以让你的UI和player的状态相同步。通常情况下，你可以直接指出player的输出到一个特定的Core Animation的layer上(<code>AVPlayerLayer</code>或者<code>AVSynchronizedLayer</code>)对象。</p>
<blockquote>
<p>多个player layer:你可以对一个AVPlayer实例创建很多的AVPlayerLayer对象，但是只有最近创建layer才可以在屏幕上展示在视频内容。</p>
</blockquote>
<p>你不用给AVPlayer对象直接提供assets，尽管你最终想要播放的是asset。相反，你需要提供一个AVPlayerItem的实例。以个item用来管理其相关联的asset的presentation state。一个item包含一个AVPlayerItemTrack的实例，这个实例和asset中的track相对应。结构如下：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-f0dabcb6010b69ad.png" alt="PlaeyItem关系图"><br>下面的图说明了你可以用不同的player同时播放一个指定的asset，但是每个player都可以用不同的方式进行渲染。例如，使用item track，你可以在播放期间让一个特定的track失效（比如，你可能不想播放一个音频部分）。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-2a0e8b3648efb92a.png" alt="AVPlayerItem"></p>
<p>你可以使用一个已经存在的asset来初始化一个player，或者你可以用一个URL来初始化一个player，以便于你可以再一个特定的点来播放这个资源(<code>AVPlayerItem</code>将会对这个资源的创建和配置这个asset)。和<code>AVAsset</code>一样，仅仅初始化一个player item并不意味着它可以直接用来播放。你可以使用KVO来观察这个item的<code>status</code>属性来决定播放的时机及播放的逻辑。</p>
<h2 id="处理不同类型的Asset"><a href="#处理不同类型的Asset" class="headerlink" title="处理不同类型的Asset"></a>处理不同类型的Asset</h2><p>你可以根据将要播放的不同的Asset类型来决定怎样配置asset。一般说来，有两种不同的类型：文件类型的assets，有几种可以选择，比如：本地文件，相机胶卷，或者媒体库；另外就是基于流的assets（HTTP直播流形式）。</p>
<p><strong>基于文件的视频加载</strong>，为了播放基于文件的视频，有以下步骤：</p>
<ul>
<li>创建一个<code>AVURLAsset</code>对象。</li>
<li>使用asset创建一个<code>AVPlayerItem</code>对象</li>
<li>将一个<code>AVPlayer</code>和这个item对象相关联</li>
<li>等待，一直到这个item的<code>status</code>属性指明可以播放了（利用KVO）</li>
</ul>
<p><strong>基于HTTP直播视频流来播放</strong>，利用该URL创建一个AVPlayerItem。（你不可以直接创建一个<code>AVAsset</code>对象来代表<code>HTTP Live Stream</code>的媒体）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line">	<span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"&lt;#Live stream URL#&gt;];</span></span><br><span class="line"><span class="string">	// You may find a test stream at</span></span><br><span class="line"><span class="string">	&lt;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8&gt;.</span></span><br><span class="line"><span class="string">	self.playerItem = [AVPlayerItem playerItemWithURL:url];</span></span><br><span class="line"><span class="string">	[playerItem addObserver:self forKeyPath:@"</span>status<span class="string">" options:0</span></span><br><span class="line"><span class="string">	context:&amp;ItemStatusContext];</span></span><br><span class="line"><span class="string">	self.player = [AVPlayer playerWithPlayerItem:playerItem];</span></span><br><span class="line"><span class="string">```   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当你将这个player item和以个player相结合的时候，它就变为待播放状态了。当它准备好播放的时候，这个player item创建`AVAsset`以及`AVAssetTrack`实例，你可以利用它来检测直播流的内容。想要得到这个item的播放时长，你可以观察其`duration`属性。当这个item状态变为可以播放时，这个属性就会更新到这个视频流的准确数值。</span></span><br><span class="line"><span class="string">*注：当这个状态变为AVPlayerItemStatusReadyToPlay的时候，这个播放时长可以使用下面的代码来获取时长*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc </span></span><br><span class="line"><span class="string">    [[[[[playerItem tracks] objectAtIndex:0] assetTrack] asset] duration];</span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果你仅仅想要播放一个直播流，那么你可以走个捷径，直接使用这个`URL`创建一个player：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc</span></span><br><span class="line"><span class="string">	self.player = [AVPlayer playerWithURL:&lt;#Live stream URL#&gt;];</span></span><br><span class="line"><span class="string">	[player addObserver:self forKeyPath:@"</span>status<span class="string">" options:0</span></span><br><span class="line"><span class="string">	context:&amp;PlayerStatusContext];</span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">和asset和item一样，初始化完player之后并不意味着你可以立即使用播放了。你需要观察其`status`属性，该属性变为`AVPlayerStatusReadyToPlay`的时候就表明它可以播放了。你也可以观察`currentItem`来获取已经创建的item。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**如果你不知道你要播放的URL的类型**，那么你需要这样做：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 尝试使用这个URL来初始化一个`AVURLAsset`对象，然后加载其`tracks`key。如果tracks加载成功，那么你可以为这个asset创建一个player item。</span></span><br><span class="line"><span class="string">2. 如果1失败了，那么利用这个URL直接创建一个`AVPlayerItem`对象。观察这个player的`status`属性，来决定是否可以播放了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">只要其中一个成功，你就可以得到一个player item，然后将其和一个player对象相关联。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 播放一个Item</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">为了开始播放，你需要调用player的`play`方法即可：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc</span></span><br><span class="line"><span class="string">	- (IBAction)play:sender &#123;</span></span><br><span class="line"><span class="string">	      [player play];</span></span><br><span class="line"><span class="string">	      </span></span><br><span class="line"><span class="string">	   &#125;</span></span><br><span class="line"><span class="string">```   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">除了紧紧播放以外，你可以管理播放过程中各种方面，比如，playhead的位置和速度。你也可以观察player的stata。比如，你如果想将UI和asset的presention state相同步，你就要这样做。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 改变播放速度</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">你可以通过设定player的`rate`属性来改变其播放的速度。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc</span></span><br><span class="line"><span class="string">	aPlayer.rate = 0.5;</span></span><br><span class="line"><span class="string">	aPlayer.rate = 2.0;</span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1.0的数值表示利用当前`item`的正常速度播放，0.0速度和暂停是一样的效果。</span></span><br><span class="line"><span class="string">支持回播的player，可以使用一个负值来设置这这个播放速度。你可以使用`canPlayReverse`(是否支持数值-1.0的播放速度)属性来检测其是否可以支持回播，使用`canPlaySlowReverse`(支持0.0到1.0的播放速度)，以及`canPlayFastReverse`(支持小于-1.0的播放速度)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 寻找-重置Playhead</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">为了将playhead移动到一个特定的时间点，你通常需要使用`seekToTime`：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc</span></span><br><span class="line"><span class="string">	CMTime fiveSecondsIn = CMTimeMake(5,1);</span></span><br><span class="line"><span class="string">	[player seekToTime: fiveSecondsIn];</span></span><br><span class="line"><span class="string">```    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">然而，这个`seekToTime:`方法不是很精确，尽管其性能较高。如果你要精确得移动这个`playhead`，你可以使用下面的`seekToTime:toleranceBefore:toleranceAfter:`方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc</span></span><br><span class="line"><span class="string">	CMTime fiveSecondsIn = CMTimeMake(5,1);</span></span><br><span class="line"><span class="string">	[player seekToTime: fiveSecondsIn toleranceBefore: kCMTimeZero toleranceAfter: kCMTimeZero];</span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上面的例子中将`tolerance`设置为零需要框架解码大量的数据。因此，仅仅在必要的时候再使用零，比如：你需要写一个精确的媒体编辑应用，它需要精确的控制。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在视频播放之后，player的head被设定在了item的尾部，因此接下来调用`play`操作是不起作用的。为了将playhead放到item的起始位置，你需要注册一个item的`AVPlayerItemDidPlayToEndTimeNotification`通知，在该通知的回调方法中，你调用`seekToTime:`方法，并且传入`kCMTimeZero`参数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc</span></span><br><span class="line"><span class="string">	    // Register with the notification center after creating the player item.</span></span><br><span class="line"><span class="string">	    [[NSNotificationCenter defaultCenter]</span></span><br><span class="line"><span class="string">	        addObserver:self</span></span><br><span class="line"><span class="string">	        selector:@selector(playerItemDidReachEnd:)</span></span><br><span class="line"><span class="string">	        name:AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line"><span class="string">	        object:&lt;#The player item#&gt;];</span></span><br><span class="line"><span class="string">	        </span></span><br><span class="line"><span class="string">	    - (void)playerItemDidReachEnd:(NSNotification *)notification &#123;</span></span><br><span class="line"><span class="string">	    [player seekToTime:kCMTimeZero];</span></span><br><span class="line"><span class="string">	 &#125; </span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 很多Item的播放</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">你可以使用`AVQueuePlayer`对象来播放一系列的`item`。这个`AVQueuePlayer`类是`AVPlayer`类的子类。通过一个`item`的数组，你可以初始化一个`queue player`。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc</span></span><br><span class="line"><span class="string">	NSArray *items = &lt;#An array of player items#&gt;;</span></span><br><span class="line"><span class="string">	AVQueuePlayer *queuePlayer = [[AVQueuePlayer alloc] initWithItems:items];</span></span><br><span class="line"><span class="string">```   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">然后调用其`play`方法即可。这个player会按序播放这些`item`。如果不想播放某个`item`可以调用它的`advanceToNextItem`方法。</span></span><br><span class="line"><span class="string">可以使用`insertTtem:afterItem:`，`removeItem:`，以及`removeAllItems`方法，如果要插入一个item，你需要首先调用`canInsertItem：afterItem:`方法来确定它是否可以插入到这个`queue`中。你可以传给第二个参数`nil`，来检测是否新的`item`可以被加到`queue`的后面。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc</span></span><br><span class="line"><span class="string">	AVPlayerItem *anItem = &lt;#Get a player item#&gt;;</span></span><br><span class="line"><span class="string">	if ([queuePlayer canInsertItem:anItem afterItem:nil]) &#123;</span></span><br><span class="line"><span class="string">	    [queuePlayer insertItem:anItem afterItem:nil];</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">```   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 监控视频播放</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">你可以监控正在player的显示状态以及其正在播放的item的各个方面。这对你所不能控制的状态改变来说是极其有益的，比如：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 比如如果用户使用多任务操作来切换应用，那么一个player的`rate`属性就会掉到0.0;</span></span><br><span class="line"><span class="string">* 如果你正在播放一个远程的媒体，一个player item的`loadedTimeRangs`和`seekableTimeRanges`属性就会在更多的数据变得可用的时候改变。这些属性告诉你这些player item的那些部分是可用的。</span></span><br><span class="line"><span class="string">* 在HTTP直播流被创建的时候，player item的`tracks`属性就会改变。如果这个视频流对内容提供了不同的编码格式，那么这就会发生；在player切换不同的编码的时候，这个`tracks`就改变了。</span></span><br><span class="line"><span class="string">* 如果一个视频播放失败，那么这个player或者player item的`status`属性可能会改变。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">你可以使用KVO来监控这些属性值的改变。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;你应该将注册KVO以及取消注册KVO都放到主线程中。这样，如果另外一个线程发生了改变，这将会避免收到部分通知的可能。尽管这些属性的变化会在其它线程上，但是AV Foundation触发`observeValueForKeyPath:ofObject:change:context:`是在主线程上。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 响应某个状态的改变</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当一个player或者一个player item的状态改变的时候，它发出一个KVO的变化通知。如果一个对象由于某种原因不能够被播放（比如，媒体服务被重置），其状态将会变为`AVPlayerStatusFailed`或者`AVPlayerItemStatusFailed`。在这种情况下，这个对象的`error`属性将会变为一个error 对象，这个对象中包含了其不能够播放的原因描述。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">AVFoundation不会指明这个通知发送的线程。如果你想改变UI，你必须要确保任何相关的代码会在主线程中执行。比如，你可以使用`dispatch_async`来在主线程中执行代码。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc</span></span><br><span class="line"><span class="string">	- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object</span></span><br><span class="line"><span class="string">	                          change:(NSDictionary *)change context:(void *)context &#123;</span></span><br><span class="line"><span class="string">	      if (context == &lt;#Player status context#&gt;) &#123;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	          AVPlayer *thePlayer = (AVPlayer *)object;</span></span><br><span class="line"><span class="string">	          if ([thePlayer status] == AVPlayerStatusFailed) &#123;</span></span><br><span class="line"><span class="string">	              NSError *error = [&lt;#The AVPlayer object#&gt; error];</span></span><br><span class="line"><span class="string">	              // Respond to error: for example, display an alert sheet.</span></span><br><span class="line"><span class="string">	              return;</span></span><br><span class="line"><span class="string">	&#125; </span></span><br><span class="line"><span class="string">	          // Deal with other status change if appropriate.</span></span><br><span class="line"><span class="string">	      &#125;</span></span><br><span class="line"><span class="string">	      // Deal with other change notifications if appropriate.</span></span><br><span class="line"><span class="string">	      [super observeValueForKeyPath:keyPath ofObject:object</span></span><br><span class="line"><span class="string">	             change:change context:context];</span></span><br><span class="line"><span class="string">	      return;</span></span><br><span class="line"><span class="string">	&#125; </span></span><br><span class="line"><span class="string">```   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 追踪可视化播放的准备状态</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">你可以观察`AVPlayerLayer`对象的`readyForDisplay`属性来获取当`layer`的用户可视内容改变时发出的通知。尤其重要的是，只有在用户可以看到一些东西的时候，你才可以将一个player layer插入到layer tree中，然后执行转化操作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 追踪时间</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">为了追踪一个`AVPlayer`对象中`playhead`的位置，你可以使用addPeriodicTimeObserverForInterval: queue: usingBlock:或者addBoundaryTimeObserverForTimes: queue: usingBlock:比如，你可以用过去的时间以及剩余的时间来更新用于界面，或者执行其它的UI同步操作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 如果时间超过了你所指定的周期点，以及视频播放开始或者停止，这个时候`addPeriodicTimeObserverForInterval:queue:usingBlock:`将会被触发。</span></span><br><span class="line"><span class="string">* 你也可以指定在某些时间触发`addBoundaryTimeObserverForTimes:queue:usingBlock:`，这里你需要传递一个包含被`NSValue`封装的`CMTime`数组。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果你要想这个基于时间的`observation block`被触发，那么你必须要对这两个方法返回的对象做强引用。同时你必须在每次触发这些方法时调`removeTimeObserver:`。使用这些方法，AV Foundation不会保证在每次的时间间隔或者时间范围达到的时候都触发这些操作。如果之前的block没有执行完毕，那么AV Foundation不会执行接下来的block。因此，你必须保证在block中执行的任务不能消耗太多的CPU资源。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc</span></span><br><span class="line"><span class="string">	/ Assume a property: @property (strong) id playerObserver;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	Float64 durationSeconds = CMTimeGetSeconds([&lt;#An asset#&gt; duration]);</span></span><br><span class="line"><span class="string">	CMTime firstThird = CMTimeMakeWithSeconds(durationSeconds/3.0, 1);</span></span><br><span class="line"><span class="string">	CMTime secondThird = CMTimeMakeWithSeconds(durationSeconds*2.0/3.0, 1);</span></span><br><span class="line"><span class="string">	NSArray *times = @[[NSValue valueWithCMTime:firstThird], [NSValue</span></span><br><span class="line"><span class="string">	valueWithCMTime:secondThird]];</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	self.playerObserver = [&lt;#A player#&gt; addBoundaryTimeObserverForTimes:times queue:NULL usingBlock:^&#123; </span></span><br><span class="line"><span class="string">	NSString *timeDescription = (NSString *) CFBridgingRelease(CMTimeCopyDescription(NULL, [self.player currentTime])); </span></span><br><span class="line"><span class="string">	    NSLog(@"</span>Passed a boundary at %<span class="string">@", timeDescription);</span></span><br><span class="line"><span class="string">	&#125;];</span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 某个Item结束了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当一个Item播放结束的时候，你可以收到一个`AVPlayerItemDidPlayToEndTimeNotification`通知。你可以注册这个通知。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc</span></span><br><span class="line"><span class="string">	[[NSNotificationCenter defaultCenter] addObserver:&lt;#The observer, typically self#&gt; selector:@selector(&lt;#The selector name#&gt;) </span></span><br><span class="line"><span class="string">	name: AVPlayerItemDidPlayToEndTimeNotification  object:&lt;#A player item#&gt;];</span></span><br><span class="line"><span class="string">```  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 综合：使用AVPlayerLayer播放一个视频文件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">接下来会用简单的代码实例来演示怎样使用`AVPlyer`对象来播放一个视频文件。它包含以下几部分内容：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 使用`AVPlayerLayer`来配置View</span></span><br><span class="line"><span class="string">* 创建一个`AVPlayer`对象</span></span><br><span class="line"><span class="string">* 基于视频文件创建一个`AVPlayerItem`，并且使用KVO来观察其状态</span></span><br><span class="line"><span class="string">* 通过使能按钮来让该Item准备播放</span></span><br><span class="line"><span class="string">* 播放该`Item`并且将这个播放完的Item的head重置到开始</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*注：为了展示最关键的代码，该实例略去了一个完整的应用所需要的功能点，比如：内存管理，注销观察者（对KVO的观察或者对某个通知的监听）。为了能够很好的使用AV Foundation，你需要对Cocoa有丰富的经验，以便处理可能遗漏的功能点。*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### Player View</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">为了播放一个Asset的可视部分，你需要一个包含了AVPlayerLayer的View以便这个AVPlayer对象的输出可以被获取。创建一个UIView的子类就可以完成这些内容：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc   </span></span><br><span class="line"><span class="string">#import &lt;UIKit/UIKit.h&gt;</span></span><br><span class="line"><span class="string">#import &lt;AVFoundation/AVFoundation.h&gt;</span></span><br><span class="line"><span class="string">@interface PlayerView : UIView</span></span><br><span class="line"><span class="string">@property (nonatomic) AVPlayer *player;</span></span><br><span class="line"><span class="string">@end</span></span><br><span class="line"><span class="string">@implementation PlayerView</span></span><br><span class="line"><span class="string">+ (Class)layerClass &#123;</span></span><br><span class="line"><span class="string">    return [AVPlayerLayer class];</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">- (AVPlayer*)player &#123;</span></span><br><span class="line"><span class="string">    return [(AVPlayerLayer *)[self layer] player];</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">- (void)setPlayer:(AVPlayer *)player &#123;</span></span><br><span class="line"><span class="string">    [(AVPlayerLayer *)[self layer] setPlayer:player];</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@end </span></span><br><span class="line"><span class="string">```    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 一个简单的ViewController</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">假如你有一个类似下面的ViewController：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```objc</span></span><br><span class="line"><span class="string">@class PlayerView;</span></span><br><span class="line"><span class="string">@interface PlayerViewController : UIViewController</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@property (nonatomic) AVPlayer *player;</span></span><br><span class="line"><span class="string">@property (nonatomic) AVPlayerItem *playerItem;</span></span><br><span class="line"><span class="string">@property (nonatomic, weak) IBOutlet PlayerView *playerView;</span></span><br><span class="line"><span class="string">@property (nonatomic, weak) IBOutlet UIButton *playButton;</span></span><br><span class="line"><span class="string">- (IBAction)loadAssetFromFile:sender;</span></span><br><span class="line"><span class="string">- (IBAction)play:sender;</span></span><br><span class="line"><span class="string">- (void)syncUI;</span></span><br><span class="line"><span class="string">@end</span></span><br></pre></td></tr></table></figure>


<p>这个<code>syncUI</code>的方法可以将button和player的状态相同步。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)syncUI &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.player.currentItem != <span class="literal">nil</span>) &amp;&amp;</span><br><span class="line">        ([<span class="keyword">self</span>.player.currentItem status] == <span class="built_in">AVPlayerItemStatusReadyToPlay</span>)) &#123;</span><br><span class="line">        <span class="keyword">self</span>.playButton.enabled = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.playButton.enabled = <span class="literal">NO</span>;</span><br><span class="line">&#125; &#125; </span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">在ViewController的`viewDidLoad`方法中你可以触发这个`syncUI`来确保View在首次展示时候的用户界面是统一的。</span><br><span class="line"></span><br><span class="line">```objc </span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> syncUI];</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">其余的属性和方法将会在接下来的部分中给以描述。</span><br><span class="line"></span><br><span class="line"><span class="meta">### 创建Asset</span></span><br><span class="line"></span><br><span class="line">使用`<span class="built_in">AVURLAsset</span>`来将一个URL创建为一个Asset（接下来的例子假如你的项目包含了一个可用的Video资源）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">- (<span class="keyword">IBAction</span>)loadAssetFromFile:sender &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [[<span class="built_in">NSBundle</span> mainBundle]</span><br><span class="line">        URLForResource:&lt;<span class="meta">#@<span class="meta-string">"VideoFileName"</span>#&gt; withExtension:<span class="meta-string">&lt;#@"extension"#&gt;</span>];</span></span><br><span class="line">    <span class="built_in">AVURLAsset</span> *asset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:fileURL options:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *tracksKey = <span class="string">@"tracks"</span>;</span><br><span class="line">    [asset loadValuesAsynchronouslyForKeys:@[tracksKey] completionHandler:</span><br><span class="line">     ^&#123;</span><br><span class="line">         <span class="comment">// The completion block goes here.</span></span><br><span class="line">     &#125;];</span><br><span class="line">&#125; </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">在完成的Block回调中，你可以给这个asset创建一个`<span class="built_in">AVPlayerItem</span>`对象，并且将其设置为`player view`的`player`。和创建`asset`一样，仅仅创建一个`player item`并不意味着就可以立即使用了。为了确定什么时候可以播放，你需要观察`item`的`status`属性。你需要将该player item对象和player关联之前来配置这种KVO的监听。</span><br><span class="line"></span><br><span class="line">当你将player item和player关联的时候，你需要触发player item的准备。</span><br><span class="line"></span><br><span class="line">```objc  </span><br><span class="line"><span class="comment">// Define this constant for the key-value observation context.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *ItemStatusContext;</span><br><span class="line">  <span class="comment">// Completion handler block.</span></span><br><span class="line">           <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),</span><br><span class="line">              ^&#123;</span><br><span class="line">                  <span class="built_in">NSError</span> *error;</span><br><span class="line">  </span><br><span class="line">error:&amp;error];</span><br><span class="line"><span class="built_in">AVKeyValueStatus</span> status = [asset statusOfValueForKey:tracksKey</span><br><span class="line"><span class="keyword">if</span> (status == <span class="built_in">AVKeyValueStatusLoaded</span>) &#123;</span><br><span class="line">                      <span class="keyword">self</span>.playerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:asset];</span><br><span class="line">                      </span><br><span class="line"> <span class="comment">// ensure that this is done before the playerItem is associated with the player</span></span><br><span class="line"> [<span class="keyword">self</span>.playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"status"</span></span><br><span class="line">             options:<span class="built_in">NSKeyValueObservingOptionInitial</span></span><br><span class="line">  context:&amp;ItemStatusContext];</span><br><span class="line">                      [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">  selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)</span><br><span class="line">  name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">  object:<span class="keyword">self</span>.playerItem];</span><br><span class="line"><span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:<span class="keyword">self</span>.playerItem]; [<span class="keyword">self</span>.playerView setPlayer:<span class="keyword">self</span>.player]; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// You should deal with the error appropriately.</span></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"The asset's tracks were not loaded:\n%@"</span>, [error</span><br><span class="line">  localizedDescription]);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"><span class="meta">### 响应Player Item的状态变更</span></span><br><span class="line">  </span><br><span class="line">当一个player item的状态变更的时候，这个View Controller收到一个KVO的变更通知。AV Foundation不会去指明这个通知发送到哪个线程上。如果你需要变更UI,那么你必须确保相关代码要在主线程中执行。改代码使用`diapatch_async`来将将同步UI的操作放到主线程中去。</span><br><span class="line"></span><br><span class="line">```objc   </span><br><span class="line"> - (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                          change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">      <span class="keyword">if</span> (context == &amp;ItemStatusContext) &#123;</span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),</span><br><span class="line">          ^&#123; </span><br><span class="line">                 [<span class="keyword">self</span> syncUI];</span><br><span class="line">           &#125;);</span><br><span class="line">     </span><br><span class="line">           <span class="keyword">return</span>; </span><br><span class="line">      &#125; </span><br><span class="line">      [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object</span><br><span class="line">             change:change context:context];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line"><span class="meta">### 播放该Item</span></span><br><span class="line"></span><br><span class="line">播放视频需要给player对象发送一个`play`的消息：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">- (<span class="keyword">IBAction</span>)play:sender &#123;</span><br><span class="line">    [player play];</span><br><span class="line">&#125; </span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">这个Item被播放了一次。在播放完成之后，playhead被放置在item的尾部，所以如果进一步触发其`play`方法是不起作用的。为了playhead放置在item的起始位置，你可以对该item注册并收到一个`<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span>`的通知。然后在通知的会调中触发`seekToTime:`方法，传入`kCMTimeZero`参数即可：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="comment">// Register with the notification center after creating the player item.</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">        addObserver:<span class="keyword">self</span></span><br><span class="line">        selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)</span><br><span class="line">        name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">        object:[<span class="keyword">self</span>.player currentItem]];</span><br><span class="line">- (<span class="keyword">void</span>)playerItemDidReachEnd:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    [<span class="keyword">self</span>.player seekToTime:kCMTimeZero];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/04/avfoundation-asset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/04/avfoundation-asset/" itemprop="url">AVFoundation--使用Asset</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-04T23:38:03+08:00">2017-08-04</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Asset可能来自于文件，或者用户的library或者Photo。创建完Asset对象之后，你所需要的所有信息不回立马就可用。一旦你有一个movie asset，你可以从它里面抽取静态图片，转码成其它格式，或者将其内容剪切。</p>
<h2 id="新建一个Asset对象"><a href="#新建一个Asset对象" class="headerlink" title="新建一个Asset对象"></a>新建一个Asset对象</h2><p>使用一个URL，就可创建出一个Asset，使用AVURLAsset。最简单的就是从一个文件中创建一个Asset：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = &lt;<span class="meta">#A URL that identifies an audiovisual asset such as a movie file#&gt;;</span></span><br><span class="line"><span class="built_in">AVURLAsset</span> *anAsset = [[<span class="built_in">AVURLAsset</span> alloc] initWithURL:url options:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<p>最后的<code>options</code>参数是一个字典。唯一的key是<code>AVURLAssetPreferPreciseDurationAndTimingKey</code>它相应的Value是一个布尔值(包含在NSValue对象里)，它表明了是否这个Asset应该用来指明一个精确的持续时间提供一个精确地随机获取(provide precise random access)。<br>但是获取精确的持续时间需要提前处理很多东西。使用粗略的持续时间通常是更快捷的操作，并且这对回播来说已经足够了。因此</p>
<ul>
<li>如果你只需要播放这个Asset，那么要么传nil，要么传一个子字典，其key为<code>AVURLAssetPreferPreciseDurationAndTimingKey</code>，它相应的值为NO（NSValue对象）。</li>
<li>如果你要将该Asset进行视频合成(<code>AVMutableComposition</code>)，那么通常你需要一个精确的<code>random access</code>。将这个字典的Value值传YES(用NSValue对象)。</li>
</ul>
<p>创建方式如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = &lt;<span class="meta">#A URL that identifies an audiovisual asset such as a movie file#&gt;; </span></span><br><span class="line"><span class="built_in">NSDictionary</span> *options = @&#123; <span class="built_in">AVURLAssetPreferPreciseDurationAndTimingKey</span> :</span><br><span class="line">   @YES &#125;;</span><br><span class="line"><span class="built_in">AVURLAsset</span> *anAssetToUseInAComposition = [[<span class="built_in">AVURLAsset</span> alloc]</span><br><span class="line">  initWithURL:url options:options];</span><br></pre></td></tr></table></figure>

<h2 id="获取用户的Asset"><a href="#获取用户的Asset" class="headerlink" title="获取用户的Asset"></a>获取用户的Asset</h2><p>为了获取iPod library或者相册，你首先需要得到这个Asset的URL。</p>
<ul>
<li>为了获取iPod Library，你需要创建一个MPMediaQuery对象来找到你需要的item，然后用<code>MPMediaItemPropertyAssetURL</code>来获取其URL。</li>
<li>为了获取相册的Asset，你需要使用<code>ALAssetsLibrary</code>。</li>
</ul>
<p>下面这个例子说明了怎样获取展示在相册中的第一个视频：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ALAssetsLibrary *library = [[ALAssetsLibrary alloc]init];</span><br><span class="line"> <span class="comment">// Enumerate just the photos and videos group by using ALAssetsGroupSavedPhotos.</span></span><br><span class="line"> [library enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// Within the group enumeration block, filter to enumerate just videos.</span></span><br><span class="line">     [group setAssetsFilter:[ALAssetsFilter allVideos]];</span><br><span class="line">     [group enumerateAssetsAtIndexes:[<span class="built_in">NSIndexSet</span> indexSetWithIndex:<span class="number">0</span>] options:<span class="number">0</span> usingBlock:^(ALAsset *result, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span> (result) &#123;</span><br><span class="line">             </span><br><span class="line">             ALAssetRepresentation *represention = [result defaultRepresentation];</span><br><span class="line">             <span class="built_in">NSURL</span> *url = [represention url];</span><br><span class="line">             <span class="comment">// Do something interesting with the AV asset.</span></span><br><span class="line">             <span class="built_in">AVAsset</span> *avAsset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:url options:<span class="literal">nil</span>];</span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">     &#125;];</span><br><span class="line">     </span><br><span class="line"> &#125; failureBlock:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// Typically you should handle an error more gracefully than this.</span></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"No groups"</span>);</span><br><span class="line">     </span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>

<p>这里需要引入<code>#import &lt;AssetsLibrary/AssetsLibrary.h&gt;</code>。</p>
<h2 id="准备Asset来用"><a href="#准备Asset来用" class="headerlink" title="准备Asset来用"></a>准备Asset来用</h2><p>初始化一个Asset(或者Track)并不意味着你立即就可以使用所有的信息。它还需要时间来计算这个Asset的时长(比如：一个MP3文件可能会包含一些总结信息)。你可以遵守<code>AVAsynchronousKeyValueLoading</code>协议来异步获取其结果，这样可以不用阻塞主线程（AVSeet和AVAssetTrack都遵守<code>AVAsynchronousKeyValueLoading</code>协议）。可以使用<code>statusOfValueForKey:error:</code>来测试是否某个某个属性的值被正常加载了。首次加载的时候，它所有属性的值是<code>AVKeyValueStatusUnknown</code>。使用<code>loadValuesAsynchronouslyForKeys:completionHandler:</code>，可以加载一个或者多个属性的值。由于网络原因或者加载被取消，所以需要一直准备加载。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ALAssetRepresentation *represention = [result defaultRepresentation];</span><br><span class="line">   <span class="built_in">NSURL</span> *url = [represention url];</span><br><span class="line">   <span class="comment">// Do something interesting with the AV asset.</span></span><br><span class="line">   <span class="built_in">AVAsset</span> *avAsset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:url options:<span class="literal">nil</span>];</span><br><span class="line">   <span class="built_in">NSArray</span> *keys = @[<span class="string">@"duration"</span>];</span><br><span class="line">   [avAsset loadValuesAsynchronouslyForKeys:keys completionHandler:^&#123;</span><br><span class="line">      </span><br><span class="line">       <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">       <span class="built_in">AVKeyValueStatus</span> tracksStatus = [avAsset statusOfValueForKey:<span class="string">@"duration"</span> error:&amp;error];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">switch</span> (tracksStatus) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusLoaded</span>:</span><br><span class="line">               </span><br><span class="line">               [<span class="keyword">self</span> updateUserInterfaceForDuration];</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusFailed</span>:</span><br><span class="line">               </span><br><span class="line">               [<span class="keyword">self</span> reportError:error forAsset:asset];</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusCancelled</span>:</span><br><span class="line">               <span class="comment">// Do whatever is appropriate for cancelation.</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>

<p>如果想准备一个asset来回播，那么还需要加载它的<code>tracks</code>属性。</p>
<h2 id="从视频中获取静态图片"><a href="#从视频中获取静态图片" class="headerlink" title="从视频中获取静态图片"></a>从视频中获取静态图片</h2><p>如果想要从asset中得到了一静态的图片，例如缩略图，你需要使用<code>AVAssetImageGenerator</code>对象。使用asset初始化一个generator。尽管在初始化的时候asset不会处理不可视的track，但是初始化还是可能会失败的，这就需要在必要的时候检查是否asset有track中包含有可视化的，使用<code>tracksWithMediaCharacteristic</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> anAsset = &lt;<span class="meta">#Get an asset#&gt;;</span></span><br><span class="line"><span class="keyword">if</span> ([[anAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">AVAssetImageGenerator</span> *imageGenerator =</span><br><span class="line">        [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:anAsset];</span><br><span class="line">    <span class="comment">// Implementation continues...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以对图片生成器的不同方面做不同的配置，例如可以使用maximumSize来指明其最大的尺度，使用<code>apertureMode</code>来指明孔径的模式。然后你就可以在给定的时间点来产生一张或者多张图片。<code>必须要强引用这个图片生成器否则，其会被释放掉。</code></p>
<h2 id="产生单独的一张图片"><a href="#产生单独的一张图片" class="headerlink" title="产生单独的一张图片"></a>产生单独的一张图片</h2><p>使用<code>copyCGImageAtTime:actualTime:error:</code>来产生在特定时间点的图片。AVFoundation框架可能不会在你请求的时候立即产生出一张图片，因此你可以给第二个参数传递一个指针，指向一个CMTime，该指针包含了图片实际产生的时间。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *myAsset = &lt;<span class="meta">#An asset#&gt;];</span></span><br><span class="line"><span class="built_in">AVAssetImageGenerator</span> *imageGenerator = [[<span class="built_in">AVAssetImageGenerator</span> alloc]</span><br><span class="line">initWithAsset:myAsset];</span><br><span class="line">Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([myAsset duration]);</span><br><span class="line"><span class="built_in">CMTime</span> midpoint = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">2.0</span>, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">CMTime</span> actualTime;</span><br><span class="line"><span class="built_in">CGImageRef</span> halfWayImage = [imageGenerator copyCGImageAtTime:midpoint</span><br><span class="line">actualTime:&amp;actualTime error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (halfWayImage != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">NSString</span> *actualTimeString = (<span class="built_in">NSString</span> *)<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, actualTime); </span><br><span class="line">    <span class="built_in">NSString</span> *requestedTimeString = (<span class="built_in">NSString</span> *)<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>,</span><br><span class="line">midpoint);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Got halfWayImage: Asked for %@, got %@"</span>, requestedTimeString,</span><br><span class="line">actualTimeString);</span><br><span class="line">    <span class="comment">// Do something interesting with the image.</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(halfWayImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="产生一系列的图片"><a href="#产生一系列的图片" class="headerlink" title="产生一系列的图片"></a>产生一系列的图片</h3><p>为了产生一系列的图片，你应该调用图片生成器的<code>generateCGImagesAsynchronouslyForTimes:completionHandler:</code>方法，第一个参数是一个包含NSValue对象的数组，NSValue对象是由<code>CMTime</code>生成的，它指明了你需要生成的图片所在的时间点。第二个参数是每个图片生成之后的回调。其中包含的字段包括</p>
<ul>
<li>图片</li>
<li>请求图片的时间和图片生成的真实时间</li>
<li>失败时候错误信息的error对象</li>
</ul>
<p>在实现block的过程中，需要检测结果来决定图片是否生成了。除此之外：<strong>在生成图片之前要一直强引用这个图片生成器</strong>。</p>
<pre><code class="objc"><span class="built_in">AVAsset</span> *myAsset = <span class="literal">nil</span>;
<span class="keyword">self</span>.imageGenerator = [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:myAsset]; 
Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([myAsset duration]);
<span class="built_in">CMTime</span> firstThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">3.0</span>, <span class="number">600</span>);
<span class="built_in">CMTime</span> secondThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds*<span class="number">2.0</span>/<span class="number">3.0</span>, <span class="number">600</span>);
<span class="built_in">CMTime</span> end = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds, <span class="number">600</span>);
<span class="built_in">NSArray</span> *times = @[ <span class="built_in">NSValue</span> valueWithCMTime:kCMTimeZero],
                    [<span class="built_in">NSValue</span> valueWithCMTime:firstThird], 
                    [<span class="built_in">NSValue</span> valueWithCMTime:secondThird],
                    [<span class="built_in">NSValue</span> valueWithCMTime:end]];
[imageGenerator generateCGImagesAsynchronouslyForTimes:times completionHandler:^(<span class="built_in">CMTime</span> requestedTime, <span class="built_in">CGImageRef</span> image, <span class="built_in">CMTime</span> actualTime,
<span class="built_in">AVAssetImageGeneratorResult</span> result, <span class="built_in">NSError</span> *error) {
<span class="built_in">NSString</span> *requestedTimeString = (<span class="built_in">NSString</span> *) <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, requestedTime));
<span class="built_in">NSString</span> *actualTimeString = (<span class="built_in">NSString</span> *)
                      <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, actualTime));
 <span class="built_in">NSLog</span>(<span class="string">@"Requested: %@; actual %@"</span>, requestedTimeString, actualTimeString);

<span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorSucceeded</span>) {
    <span class="comment">// Do something interesting with the image.</span>
} 
<span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorFailed</span>) { <span class="built_in">NSLog</span>(<span class="string">@"Failed with error: %@"</span>, [error localizedDescription]); 
}
<span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorCancelled</span>) {
    <span class="built_in">NSLog</span>(<span class="string">@"Canceled"</span>);
}
}];</code></pre>
<p>如果想要在中途终止图片序列的生成，可以调用<code>cancelAllCGImageGeneration</code>方法。</p>
<h3 id="视频的裁剪和转码"><a href="#视频的裁剪和转码" class="headerlink" title="视频的裁剪和转码"></a>视频的裁剪和转码</h3><p>使用<code>AVAssetExportSession</code>对象，可以将视频从一种格式到另一种格式进行转码，并且可以裁剪视频。一个export session是一个控制器对象，它管理着一个asset的异步输出。你可以将想要输出的asset以及输出的用来表明输出选项的<code>preset</code>来初始化一个<code>session</code>。然后你可以配置这个输出的session来指明输入的URL，以及文件格式，以及其它设置的一些可选配置，如metadata，以及是否输出需要被优化。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-7454ffe396927bff.png" alt="视频转码"><br>可以使用<code>exportPresetsCompatibleWithAsset:</code>来检测你是否可以输出一种给定的<code>asset</code>，如下所示</p>
<pre><code class="objc"><span class="built_in">AVAsset</span> *anAsset = &lt;<span class="meta">#Get an asset#&gt;;</span>
<span class="built_in">NSArray</span> *compatiblePresets = [<span class="built_in">AVAssetExportSession</span>
exportPresetsCompatibleWithAsset:anAsset];
<span class="keyword">if</span> ([compatiblePresets containsObject:<span class="built_in">AVAssetExportPresetLowQuality</span>]) {
    <span class="built_in">AVAssetExportSession</span> *exportSession = [[<span class="built_in">AVAssetExportSession</span> alloc]
        initWithAsset:anAsset presetName:<span class="built_in">AVAssetExportPresetLowQuality</span>];
    <span class="comment">// Implementation continues.</span>
}</code></pre>
<p>你可以通过提供输出的URL(该URL必须是一个文件的URL)来配置这个session，<code>AVAssetExportSession</code>可以根据输出的<code>URL</code>的路径扩展，来推断需要输出的文件类型；然而也可以通过使用<code>outputFileType</code>直接进行配置。你也可以指明一些其它的属性，比如时间范围，输出长度的限制，是否输出的文件需要被优化来作为网络使用，以及一个视频的合成。下面的例子说明了如何使用<code>timeRange</code>属性来裁剪视频：</p>
<pre><code class="objc">exportSession.outputURL = &lt;<span class="meta">#A file URL#&gt;;</span>
exportSession.outputFileType = <span class="built_in">AVFileTypeQuickTimeMovie</span>;
<span class="built_in">CMTime</span> start = <span class="built_in">CMTimeMakeWithSeconds</span>(<span class="number">1.0</span>, <span class="number">600</span>);
<span class="built_in">CMTime</span> duration = <span class="built_in">CMTimeMakeWithSeconds</span>(<span class="number">3.0</span>, <span class="number">600</span>);
<span class="built_in">CMTimeRange</span> range = <span class="built_in">CMTimeRangeMake</span>(start, duration);
exportSession.timeRange = range;</code></pre>
<p>调用<code>exportAsynchronouslyWithCompletionHandler:</code>方法可以用来创建一个新的文件。当输出操作结束的时候这个文成的block将会被回调。如果你要处理这个回调，那么你需要检测这个seesion的<code>status</code>值来确定是否这次输出是成功的，失败的，或者是被取消的。</p>
<pre><code class="objc">[exportSession exportAsynchronouslyWithCompletionHandler:^{
          <span class="keyword">switch</span> ([exportSession status]) {
              <span class="keyword">case</span> <span class="built_in">AVAssetExportSessionStatusFailed</span>:
                  <span class="built_in">NSLog</span>(<span class="string">@"Export failed: %@"</span>, [[exportSession error]
  localizedDescription]);
                  <span class="keyword">break</span>;
              <span class="keyword">case</span> <span class="built_in">AVAssetExportSessionStatusCancelled</span>:
                  <span class="built_in">NSLog</span>(<span class="string">@"Export canceled"</span>);
                  <span class="keyword">break</span>;
              <span class="keyword">default</span>:
<span class="keyword">break</span>; } 
}];</code></pre>
<p>通过调用session的<code>cancelExport</code>方法，可以取消某次输出。<br>如果你试图往一个已经存在的文件中重复写入，或者往应用的沙盒之外的其它地方写文件，那么将会造成输出文件失败。下面的情况也会造成输出失败：</p>
<ul>
<li>电话呼入</li>
<li>你的应用推到了后台，同时另一个应用也开始执行回播</li>
</ul>
<p>这种情况下，你需要提醒用户输出失败，以便其可以重新输出。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/04/avfoundation-introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/04/avfoundation-introduction/" itemprop="url">AVFoundation--简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-04T23:37:34+08:00">2017-08-04</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AVFoundation是很多处理基于时间的音视频文件的框架之一。你可以用它来检查，创建，编辑或者对媒体文件重编码。可以从设备中得到输入流，以及在实时捕捉和播放的时候对视频进行处理。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-d41cc62c5bec457a.png" alt="AVFoundation"></p>
<ul>
<li>如果你仅仅需要播放视频，在IOS上你可以使用Media Player框架中的<code>MPMoviePlayerController</code>或者<code>MPMoviePlayerViewController</code>，如果是基于Web的视频，那么你可以使用<code>UIWebView</code>。</li>
<li>为了录制视频，并且几乎不需要关注其格式，那么你可以使用UIKit框架中的<code>UIImagePickerController</code>。</li>
</ul>
<p>然而请注意：在AVFoundation中使用的一些原始数据（包括基于时间的数据结构以及携带及包含媒体信息的封装对象）都是在<code>Core Media</code>框架中声明的。</p>
<h1 id="AVFoundation框架简介"><a href="#AVFoundation框架简介" class="headerlink" title="AVFoundation框架简介"></a>AVFoundation框架简介</h1><p>AV Foundation中有两个方面的API(处理视频的和处理音频的)。</p>
<ul>
<li>使用<code>AVAudioPlayer</code>来播放音频文件</li>
<li>使用<code>AVAudioRecorder</code>来录制音频文件</li>
</ul>
<p>你可以通过<code>AVAudioSessin</code>对象来对配置音频的播放行为，相关配置可以参考：<code>Audio Session Programming Guide</code>。</p>
<p>AVFoundation中用来代表媒体信息的关键类是AVAsset。该框架的大部分功能都是有AVAsset来表现的。理解AVAsset将有助于理解整个框架是如何工作的。AVAsset是一片或者多片媒体数据的集合。它统一提供这个集合的信息，包括其标题，时长，自然表现大小（natural presentation size）等。一个AVAsset不合具体的数据格式相绑定。AVAsset是其它用URL来创建asset实例的父类。<br>asset中的每一个独立媒体片是一个统一的类型并且其成为<code>track</code>。</p>
<h2 id="使用Assets"><a href="#使用Assets" class="headerlink" title="使用Assets"></a>使用Assets</h2><p>AVAsset是AVFoundation的基础类。AVFoundation框架的设计很大程度上都是通过这个类来表现的。它提供了视频的名称，时间，正常展示的大小(natural presentation size)。AVAsset没有和具体的数据形式相绑定。AVAsset是从一个<code>URL</code>来创建出Asset实例的父类，并且可以创建出新的组合。每个asset中独立的视频片段都是统一的类型叫做<code>track</code>。一般情况下：一个track代表音频成分，一个track代表视频成分。很重要的一点是：初始化一个asset并不意味着立即就可以用。它还需要一些时间来计算。但是这种计算不会阻塞主线程，他会异步的执行。</p>
<h2 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h2><p><code>presentation state</code>是由<code>player item</code>对象管理的，某个track的<code>presentation state</code>是由<code>player item track</code>对象管理的。你可以使用<code>player</code>对象来播放，并且直接将其输出到<code>Core Animation</code>上。可以使用一个<code>player queue</code>有续地来管理一系列的<code>player items</code>。</p>
<h2 id="读，写以及重新编码Asset"><a href="#读，写以及重新编码Asset" class="headerlink" title="读，写以及重新编码Asset"></a>读，写以及重新编码<code>Asset</code></h2><p>AV Foundation让你给一个Asset用不同的方式创建出新的展示。你可以仅仅对一个已经存在的asset进行重编码（ios4.1之后），你可以在一个asset的内容上执行不同的操作，然后将结果用新的asset来存储。将一种表现转化成其他类型的表现，可以使用<code>asset reader</code>和<code>asset writer</code>来串联两个视频动画。</p>
<h2 id="缩略图"><a href="#缩略图" class="headerlink" title="缩略图"></a>缩略图</h2><p>使用<code>AVAssetImageGenerator</code>对象可以来创建缩略图。编辑，AV Foundation使用<code>compositions</code>来从现有的媒体片段中新建assets。可以设置相对volume，音频<code>track ramp</code>，设置透明度。</p>
<h2 id="Media捕捉和使用Camera"><a href="#Media捕捉和使用Camera" class="headerlink" title="Media捕捉和使用Camera"></a>Media捕捉和使用Camera</h2><p>可以使用<code>preview player</code>来展示camera录制的内容。</p>
<h2 id="AV-Foundation和多线程并发"><a href="#AV-Foundation和多线程并发" class="headerlink" title="AV Foundation和多线程并发"></a>AV Foundation和多线程并发</h2><p>有两点需要注意的：</p>
<ul>
<li>UI相关的通知应该在主线程中触发。</li>
<li>需要自己明确指定类和方法所在线程的话会在响应的线程中年触发通知</li>
</ul>
<p>如果要开发多线程的应用，那么你应该使用<code>isMainThread</code>或者<code>[[NSThread currentThread] isEqual:&lt;#A stored thread reference#&gt;]</code>来提前测试是否该线程是你期望的要执行的线程。如果要跨线程，你可能需要如下方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performSelectorOnMainThread:withObject:waitUntilDone: </span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:modes:</span><br><span class="line"><span class="built_in">dispatch_async</span></span><br></pre></td></tr></table></figure>

<p>为了更好的开发AVFoundation，你需要具备如下前提知识：</p>
<ul>
<li>全面理解基础的Cocoa开发工具及技术</li>
<li>基本理解Block</li>
<li>基本理解KVC和KVO</li>
<li>对于视频回播，需要理解合理动画，对于基本的回播，需要理解AV Kit框架参考手册</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/04/intermedia-swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/04/intermedia-swift/" itemprop="url">Swift中级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-04T08:28:26+08:00">2017-08-04</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文源于对：<a href="https://developer.apple.com/videos/play/wwdc2014/403/" target="_blank" rel="noopener">WWDC2014–Intermediate Swift</a>的总结。</p>
<h2 id="为什么需要Optional"><a href="#为什么需要Optional" class="headerlink" title="为什么需要Optional?"></a>为什么需要Optional?</h2><p>我们队某个对象的操作可能会返回错误的结果：比如我们将某个字符串转为Int型，执行下面的指令：</p>
<pre><code class="Swift"><span class="keyword">let</span> age = response.toInt()</code></pre>
<p>这response可能是用户输入的,可能会输入不确定的数值<code>Do you konw?</code>那么肯定会得到错误的结果，在OC中遇到这种情况我们怎么处理呢？我们有如下的值可以表示错误：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-65ce6dec3ca6cade.png" alt="Wrong!"><br>但是你必须从不同的接口中去选择相应的错误类型，并且要记住这些错误类型。为了解决这个问题，Swift中引入了Optional的概念，将这种可能是nil的值进行打包。它可以表示上述所有错误的类型，同时，<strong>如果我们使用Optional，就一定要对它进行拆包，使用<code>!</code>号，如果不拆包会造成编译器错误</strong>，如下所示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-03cea3691052ac9b.png" alt="Need Unwrap"><br><strong>也可以使用Optional Binding将判断是否有值和拆包结合在一起使用：<code>if let</code></strong>。</p>
<pre><code class="Swift"><span class="keyword">var</span> neighbors = [<span class="string">"Alex"</span>, <span class="string">"Anna"</span>, <span class="string">"Madison"</span>, <span class="string">"Dave"</span>] <span class="keyword">let</span> index = findIndexOfString(<span class="string">"Anna"</span>, neighbors)  <span class="keyword">if</span> <span class="keyword">let</span> indexValue = index { 
    <span class="built_in">println</span>(<span class="string">"Hello, \(neighbors[indexValue])"</span>)
} <span class="keyword">else</span> {
    <span class="built_in">println</span>(<span class="string">"Must've moved away"</span>)
}</code></pre>
<p>当然我们还可以进一步使用Optional Binding–Optional Chain：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-040ccbafce764e18.png" alt="Optional Chain Binding"></p>
<p>在Optional Chain中，只要其中一个Optional的值是nil，那么整个Optional Chain都将是nil，并且不会再执行接下来的取值，如果不是nil则继续执行。这样让我们的代码更加简洁更加安全。<br>Swift中的Optional其实是个枚举：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>{
   <span class="keyword">case</span> <span class="type">None</span>
   <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">T</span>)
}</code></pre>
<h2 id="Swift中的内存管理"><a href="#Swift中的内存管理" class="headerlink" title="Swift中的内存管理"></a>Swift中的内存管理</h2><p>在Swift中也用的是ARC，也容易出现循环引用，这时需要使用<code>weak</code>属性。需要注意的是</p>
<blockquote>
<p><code>weak</code>引用的类型是Optional的。<br>Binding该Optional Type将会产生一个强引用。<br>如果仅仅是判断即用<code>if</code>判断，则不会产生强引用。</p>
</blockquote>
<p>例如：</p>
<pre><code class="Swift"><span class="keyword">if</span> <span class="keyword">let</span> tenant = apt.tenant {
  tenant.buzzIn()
 } </code></pre>
<p>但是有些时候我们同时需要weak，又同时需要非Optional的。那么该怎么办？我们需要<code>unowned</code>属性，他也是weak的。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{
    <span class="keyword">var</span> card: <span class="type">CreditCard?</span>
} <span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> </span>{ <span class="keyword">unowned</span> <span class="keyword">let</span> holder: <span class="type">Person</span> 
    <span class="keyword">init</span>(holder: <span class="type">Person</span>) {
        <span class="keyword">self</span>.holder = holder
  } 
} </code></pre>
<p>这说明<code>holder</code>没持指向Person，但是holder离开了Person它就不存在了。<code>unowned</code>很像<code>unsafe unretain</code></p>
<h2 id="Swift中的初始化"><a href="#Swift中的初始化" class="headerlink" title="Swift中的初始化"></a>Swift中的初始化</h2><p>在Swift的初始化中需要谨记：</p>
<blockquote>
<p>所有的变量在使用前必须初始化<br>设定完自己所有的变量之后再调用Super的初始化方法</p>
</blockquote>
<p>在下面这个初始化的例子中：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-71bbd45dcf36f0a3.png" alt="init wrong"><br>这样在init方法中没有初始化完自己的<code>hasTurbo</code>变量就直接调用super方法是会在编译的时候报错的，Swift为什么要这么做呢？因为可能会出现如下的情况：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-bd1edb7b7a89a7bc.png" alt="why init wrong"><br>也就是说在父类的<code>init</code>方法中可能会调用<code>filGasTank()</code>这个方法，而这个方法被子类所覆盖了，所以这时候就可能发生意向不到的bug。<br>初始化方法的覆盖也可能会产生问题：<br>比如我们有这样一个Car的类：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>{
    <span class="keyword">var</span> paintColor: <span class="type">Color</span>
    <span class="function"><span class="keyword">func</span> <span class="title">fillGasTank</span><span class="params">()</span></span> {...}
    <span class="keyword">init</span>(color: <span class="type">Color</span>) {
        paintColor = color
        fillGasTank()
    }
} 
<span class="class"><span class="keyword">class</span> <span class="title">RaceCar</span>: <span class="title">Car</span> </span>{
    <span class="keyword">var</span> hasTurbo: <span class="type">Bool</span>
    <span class="keyword">init</span>(color: <span class="type">Color</span>, turbo: <span class="type">Bool</span>) {
        hasTurbo = turbo
        <span class="keyword">super</span>.<span class="keyword">init</span>(color: color)
} 
    <span class="keyword">convenience</span> <span class="keyword">init</span>(color: <span class="type">Color</span>) {
        <span class="keyword">self</span>.<span class="keyword">init</span>(color: color, turbo: <span class="literal">true</span>)
} 
    <span class="keyword">convenience</span> <span class="keyword">init</span>() {
        <span class="keyword">self</span>.<span class="keyword">init</span>(color: <span class="type">Color</span>(gray: <span class="number">0.4</span>))
} } 

<span class="class"><span class="keyword">class</span> <span class="title">FormulaOne</span>: <span class="title">RaceCar</span> </span>{
    <span class="keyword">let</span> minimumWeight = <span class="number">642</span>

    <span class="comment">// inherited from RaceCar</span>
    <span class="comment">/*init(color: Color, turbo: Bool) {</span>
<span class="comment">        hasTurbo = turbo</span>
<span class="comment">        super.init(color: color)</span>
<span class="comment">    }</span>
<span class="comment">    convenience init(color: Color) {</span>
<span class="comment">        self.init(color: color, turbo: true)</span>
<span class="comment">    }</span>
<span class="comment">    convenience init() {</span>
<span class="comment">        self.init(color: Color(gray: 0.4))</span>
<span class="comment">    }</span>
<span class="comment">    */</span>
} </code></pre>
<p>上面注释的内容是从父类中继承过来的，如果我们在子类中调用<code>convenience init(color: Color)</code>这个方法的时候，想让<code>turbo</code>这个参数的默认值为<code>false</code>，这时候我们就需要覆盖掉父类的<code>convenience init</code>方法了。这时我们需要实现自己的<code>designed initializer</code>  </p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">FormulaOne</span>: <span class="title">RaceCar</span> </span>{
    <span class="keyword">let</span> minimumWeight = <span class="number">642</span>
    <span class="keyword">init</span>(color: <span class="type">Color</span>) {
        <span class="keyword">super</span>.<span class="keyword">init</span>(color: color, turbo: <span class="literal">false</span>)
} 
    <span class="comment">// not inherited from RaceCar</span>
    <span class="comment">/*init(color: Color, turbo: Bool)</span>
<span class="comment">    convenience init()</span>
<span class="comment">    */</span>
} </code></pre>
<p>这样以后被注释的内容就不会再被继承了。就会直接掉用子类的<code>designed init</code>方法了。</p>
<h2 id="懒加载属性"><a href="#懒加载属性" class="headerlink" title="懒加载属性"></a>懒加载属性</h2><p>如果我们的某个属性需要很大的性能消耗，那么我们希望在使用的时候再创建该类，那么我们不必像在OC中那样重写其<code>get</code>方法，我们只需要在变量声明的前面加上<code>lazy</code>关键字即可。</p>
<pre><code class="Swift"><span class="built_in">lazy</span> <span class="keyword">var</span> color:<span class="type">UIColor</span> = <span class="type">UIColor</span>.red</code></pre>
<p>这样就可以声明了一个懒加载的属性了。</p>
<h2 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Swift中Array的sort方法实现了Closure，我们来看下：</p>
<pre><code class="Swift"><span class="keyword">var</span> clients = [<span class="string">"Pestov"</span>, <span class="string">"Buenaventura"</span>, <span class="string">"Sreeram"</span>, <span class="string">"Babbage"</span>]

clients.<span class="built_in">sort</span>({(a: <span class="type">String</span>, b: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> 
<span class="keyword">return</span> a &lt; b }) 

<span class="built_in">println</span>(clients)
<span class="comment">// [Babbage, Buenaventura, Pestov, Sreeram]</span></code></pre>
<p>这样就实现了数组中的元素排序。<br>但是基于<code>Swift</code>强大的类型推断功能，我们可以将其简化为：</p>
<pre><code class="Swift">clients.<span class="built_in">sort</span>({ a, b <span class="keyword">in</span>
<span class="keyword">return</span> a &lt; b
})</code></pre>
<p>因为这个<code>Closure</code>是有返回值的，所以编译器可以再次推断，所以我们可以这样写</p>
<pre><code class="Swift">clients.<span class="built_in">sort</span>({ a, b <span class="keyword">in</span> a &lt; b })</code></pre>
<p>编译器还可以推断出其参数值，所以，我们这里可以写成</p>
<pre><code class="Swift">clients.<span class="built_in">sort</span>({$<span class="number">0</span> &lt; $<span class="number">1</span>})</code></pre>
<p>因为我们还有尾随闭包，所以我们可以进一步简化</p>
<pre><code class="Swift">clients.<span class="built_in">sort</span>{$<span class="number">0</span> &lt; $<span class="number">1</span>}</code></pre>
<h3 id="Functional-Programming"><a href="#Functional-Programming" class="headerlink" title="Functional Programming"></a>Functional Programming</h3><p>我们有很多函数式编程的高阶函数可以供调用：</p>
<pre><code class="Swift"><span class="keyword">let</span> result = words.<span class="built_in">filter</span>{ $<span class="number">0</span>.hasSuffix(<span class="string">"gry"</span>)}.<span class="built_in">map</span>{$<span class="number">0</span>.uppercaseString}</code></pre>
<p>这样我们就可以找到所有以<code>gry</code>结尾的单词，并且将其转化为大写字母。如果这时结果是</p>
<pre><code class="Swift"><span class="type">ANGRY</span>
<span class="type">HUNGRY</span></code></pre>
<p>我们还可以调用<code>reduce</code>方法将其和成一个字符串</p>
<pre><code class="Swift"><span class="keyword">let</span> reducedResult = result.<span class="built_in">reduce</span>(<span class="string">"HULK"</span>){<span class="string">"\($0) \($1)"</span>}</code></pre>
<p>这时结果如下：</p>
<pre><code class="Swift"><span class="type">HULK</span> <span class="type">ANGRY</span> <span class="type">HUNGRY</span></code></pre>
<h3 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h3><p>比高可以传递一个函数，例如：</p>
<pre><code class="Swift"> numbers.<span class="built_in">map</span> {
        <span class="built_in">println</span>($<span class="number">0</span>)
} 
numbers.<span class="built_in">map</span>(<span class="built_in">println</span>)    <span class="comment">// 可以将一个函数传递过去</span>


<span class="keyword">var</span> indexes = <span class="type">NSMutableIndexSet</span>()
numbers.<span class="built_in">map</span> {
    indexes.addIndex($<span class="number">0</span>)
} 

numbers.<span class="built_in">map</span> (indexes.addIndex) <span class="comment">// 可以将一个Method传过去</span></code></pre>
<h3 id="闭包是一个ARC对象"><a href="#闭包是一个ARC对象" class="headerlink" title="闭包是一个ARC对象"></a>闭包是一个ARC对象</h3><p>我们可以声明一个Closure属性：</p>
<pre><code class="Swift"><span class="keyword">var</span> onTempratureChange: (<span class="type">Int</span>) -&gt; <span class="type">Void</span> = {}
<span class="function"><span class="keyword">func</span> <span class="title">logTemperatureDifferences</span><span class="params">(initial: Int)</span></span> {
    <span class="keyword">var</span> prev = initial
    onTemperatureChange = { next <span class="keyword">in</span>
        <span class="built_in">println</span>(<span class="string">"Changed \(next - prev)°F"</span>)
prev = next 
} </code></pre>
<p>因为function也是closure，那么我们可以这样写：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">logTemperatureDifferences</span><span class="params">(initial: Int)</span></span> {
    <span class="keyword">var</span> prev = initial
    <span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(next: Int)</span></span> {
        <span class="built_in">println</span>(<span class="string">"Changed \(next - prev)°F"</span>)
prev = next } 
    onTemperatureChange = log</code></pre>
<h3 id="闭包的循环引用问题"><a href="#闭包的循环引用问题" class="headerlink" title="闭包的循环引用问题"></a>闭包的循环引用问题</h3><p>和OC中的Block一样，Swift中也会出现循环引用的问题，我们来看看怎样解决：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureNotifier</span> </span>{
    <span class="keyword">var</span> onChange: (<span class="type">Int</span>) -&gt; <span class="type">Void</span> = {}
    <span class="keyword">var</span> currentTemp = <span class="number">72</span>
    <span class="keyword">init</span>() {
        onChange = { temp <span class="keyword">in</span>
currentTemp = temp    } <span class="comment">// error: requires explicit 'self' </span>
  } 
} </code></pre>
<p>如果出现上面的循环引用问题，编译器会直接报错的，所以我们可以用上文提到的<code>unowned</code>来解决。我们可以将init()方法用下面的来取代：</p>
<pre><code class="Swift"><span class="keyword">init</span>() { 
    <span class="keyword">unowned</span> <span class="keyword">let</span> uSelf = <span class="keyword">self</span>
    onChange = { temp <span class="keyword">in</span>
      uSelf.currentTemp = temp
    }</code></pre>
<p>但是这样写还会出现一个问题，就是如果别处有一份逻辑一样的代码，某个人不注意拷贝过来了忘记将<code>self</code>改成uSelf，或者这个方法很长，写到下面的是忘记了将<code>self</code>改成uSelf，那么就会出现内存泄漏的问题。为了解决这个问题Swift中提出了下面的优雅做法：</p>
<pre><code class="Swift"><span class="keyword">init</span>() { onChange = {[<span class="keyword">unowned</span> <span class="keyword">self</span>] temp <span class="keyword">in</span> 
<span class="keyword">self</span>.currentTemp = temp 
} } </code></pre>
<h2 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h2><p><code>switch</code>中可以有范围，字符串和数字，并且Enum中可以关联属性，比如：</p>
<pre><code class="Swift"><span class="comment">// case中含有范围</span>
<span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(value: Int)</span></span> { <span class="keyword">switch</span> value { 
<span class="keyword">case</span> <span class="number">0</span>...<span class="number">4</span>: <span class="built_in">println</span>(<span class="string">"a few"</span>) 
<span class="keyword">case</span> <span class="number">5</span>...<span class="number">12</span>: <span class="built_in">println</span>(<span class="string">"a lot"</span>) 
      <span class="keyword">default</span>:
        <span class="built_in">println</span>(<span class="string">"a ton"</span>)
} } 
<span class="comment">// case中</span>

<span class="class"><span class="keyword">enum</span> <span class="title">TrainStatus</span> </span>{
    <span class="keyword">case</span> <span class="type">OnTime</span>
    <span class="keyword">case</span> <span class="type">Delayed</span>(<span class="type">Int</span>)
}</code></pre>
<p>使用的时候如下：</p>
<pre><code class="Swift"><span class="keyword">switch</span> trainStatus {
  <span class="keyword">case</span> .<span class="type">OnTime</span>:
} 
  <span class="built_in">println</span>(<span class="string">"on time"</span>)
<span class="keyword">case</span> .<span class="type">Delayed</span>(<span class="keyword">let</span> minutes)
                        :
<span class="built_in">println</span>(<span class="string">"delayed by \(minutes) minutes"</span>)</code></pre>
<p>我们可以对这个<code>delay</code>做各种各样的匹配：</p>
<pre><code class="Swift"><span class="keyword">switch</span> trainStatus {
  <span class="keyword">case</span> .<span class="type">OnTime</span>:
    <span class="built_in">println</span>(<span class="string">"on time"</span>)
  <span class="keyword">case</span> .<span class="type">Delayed</span>(<span class="number">1</span>):
    <span class="built_in">println</span>(<span class="string">"nearly on time"</span>)
  <span class="keyword">case</span> .<span class="type">Delayed</span>(<span class="number">2</span>...<span class="number">10</span>):
    <span class="built_in">println</span>(<span class="string">"almost on time, I swear"</span>)
  <span class="keyword">case</span> .<span class="type">Delayed</span>(<span class="number">_</span>):
    <span class="built_in">println</span>(<span class="string">"it'll get here when it's ready"</span>)</code></pre>
<h3 id="Pattern-Compose"><a href="#Pattern-Compose" class="headerlink" title="Pattern Compose"></a>Pattern Compose</h3><p>也就是说Pattern可以组合出现，一个Pattern中可以包含其它的Pattern，比如对上文的<code>TrainStatus</code>再做以Pattern Compose：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">enum</span> <span class="title">VacationStatus</span> </span>{
    <span class="keyword">case</span> <span class="type">Traveling</span>(<span class="type">TrainStatus</span>)
    <span class="keyword">case</span> <span class="type">Relaxing</span>(daysLeft: <span class="type">Int</span>)
} 

<span class="keyword">switch</span> vacationStatus {
  <span class="keyword">case</span> .<span class="type">Traveling</span>(.<span class="type">OnTime</span>):
    tweet(<span class="string">"Train's on time! Can't wait to get there!"</span>)
  <span class="keyword">case</span> .<span class="type">Traveling</span>(.<span class="type">Delayed</span>(<span class="number">1</span>...<span class="number">15</span>)):
    tweet(<span class="string">"Train is delayed."</span>)
  <span class="keyword">case</span> .<span class="type">Traveling</span>(.<span class="type">Delayed</span>(<span class="number">_</span>)):
    tweet(<span class="string">"OMG when will this train ride end #railfail"</span>)
  <span class="keyword">default</span>:
  <span class="built_in">print</span>(<span class="string">"relaxing"</span>)</code></pre>
<h3 id="Type-Pattern"><a href="#Type-Pattern" class="headerlink" title="Type Pattern"></a>Type Pattern</h3><p><code>Pattern</code>不仅仅可以作用于<code>Enum</code>，还可以作用于动态的类型，如：<code>Class</code></p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">tuneUp</span><span class="params">(car: Car)</span></span> {
    <span class="keyword">switch</span> car {
      <span class="keyword">case</span> <span class="keyword">let</span> formulaOne <span class="keyword">as</span> <span class="type">FormulaOne</span>:
        formulaOne.enterPit()
      <span class="keyword">case</span> <span class="keyword">let</span> raceCar <span class="keyword">as</span> <span class="type">RaceCar</span>:
        <span class="keyword">if</span> raceCar.hasTurbo { raceCar.tuneTurbo() }
        <span class="keyword">fallthrough</span>
      <span class="keyword">default</span>:
        car.checkOil()
        car.pumpTires()
} } </code></pre>
<p>这样在多态中就会变得非常有用了。</p>
<h3 id="Tuple-Patterns"><a href="#Tuple-Patterns" class="headerlink" title="Tuple Patterns"></a>Tuple Patterns</h3><p>Tuple pattern有其极其强大的功能，其可以对tuple的各个数值做以类型匹配。</p>
<pre><code class="Swift"><span class="keyword">let</span> color = (<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>)
<span class="keyword">switch</span> color {
  <span class="keyword">case</span> (<span class="number">0.0</span>, <span class="number">0.5</span>...<span class="number">1.0</span>, <span class="keyword">let</span> blue, <span class="number">_</span>):
    <span class="built_in">println</span>(<span class="string">"Green and \(blue * 100)% blue"</span>)
  <span class="keyword">case</span> <span class="keyword">let</span> (r, g, b, <span class="number">1.0</span>) <span class="keyword">where</span> r == g &amp;&amp; g == b:
    <span class="built_in">println</span>(<span class="string">"Opaque grey \(r * 100)%"</span>)</code></pre>
<p>我们甚至可以对其中的各个数值做以相应的模式匹配。</p>
<h3 id="Pattern-Matching的应用PList校验"><a href="#Pattern-Matching的应用PList校验" class="headerlink" title="Pattern Matching的应用PList校验"></a>Pattern Matching的应用PList校验</h3><p>比如我们有下面的方法来校验Plist中的内容是否有效</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">stateFromPlist</span><span class="params">(list: Dictionary&lt;String, AnyObject&gt;)</span></span>
  -&gt; <span class="type">State?</span>
stateFromPlist([<span class="string">"name"</span>: <span class="string">"California"</span>,
                <span class="string">"population"</span>: <span class="number">38_040_000</span>,
                <span class="string">"abbr"</span>: <span class="string">"CA"</span>])</code></pre>
<p>这时我们要对<code>population</code>的值做以限制，如果是字符串返回<code>nil</code>，如果是超过某个范围的时候返回<code>nil</code>，如果是<code>abbr</code>中字母的个数大于2时候我们也返回<code>nil</code>，利用tuple pattern matching的强大特性，我们可以这样去做：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">stateFromPlist</span><span class="params">(list: Dictionary&lt;String, AnyObject&gt;)</span></span>
  -&gt; <span class="type">State?</span> {

<span class="keyword">switch</span> (list[<span class="string">"name"</span>], list[<span class="string">"population"</span>], list[<span class="string">"abbr"</span>]) { 
<span class="keyword">case</span> ( 
        .<span class="type">Some</span>(<span class="keyword">let</span> listName <span class="keyword">as</span> <span class="type">NSString</span>), 
        .<span class="type">Some</span>(<span class="keyword">let</span> pop <span class="keyword">as</span> <span class="type">NSNumber</span>),
        .<span class="type">Some</span>(<span class="keyword">let</span> abbr <span class="keyword">as</span> <span class="type">NSString</span>)
      ) <span class="keyword">where</span> abbr.length == <span class="number">2</span>:
    <span class="keyword">return</span> <span class="type">State</span>(name: listName, population: pop, abbr: abbr)
  <span class="keyword">default</span>:
<span class="keyword">return</span> <span class="literal">nil</span> 
   } 
} </code></pre>
<p>这就利用了tuple和限制想结合的方式优雅的解决了这个问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/02/wwdc-better-app-with-value-type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/02/wwdc-better-app-with-value-type/" itemprop="url">怎样用好Value Type?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-02T16:37:56+08:00">2017-08-02</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Swift–怎样用好Value-Type"><a href="#Swift–怎样用好Value-Type" class="headerlink" title="Swift–怎样用好Value Type?"></a>Swift–怎样用好Value Type?</h1><p><img src="http://upload-images.jianshu.io/upload_images/1513759-6b88775e60bbef0f.png" alt="Value Type"></p>
<h2 id="为什么要用Value-Type"><a href="#为什么要用Value-Type" class="headerlink" title="为什么要用Value Type?"></a>为什么要用Value Type?</h2><p>首先我们要说明为什么我们需要<code>Value Type</code>。因为我们通常使用的<code>Reference Type</code>不能满足我们的需求，并且容易出Bug，什么是<code>Reference Type</code>?<br>Reference Type就是我们常说的Class，我们不是用的很好吗？我们举两个例子来看看<br>例一：但是现在又一种需求：进入用于信息页面编辑页面，如果用户的信息改变了，并且没有点击保存，这时如果点击导航栏的退出，要给用户提醒”您编辑了信息，确定不保存退出吗？”，这时为了保存进入编辑页面的信息，我们一般这样做</p>
<ol>
<li>增加一个originInfo的property。</li>
<li>在ViewDidLoad的时候赋值：self.originInfo = passedInfo;（这个passedInfo从上个页面传来）</li>
<li>在点击退出的时候对比passedInfo和self.originInfo是否相等，如果不相等则提醒用户，如果相等则返回。<br>这时你会发现一个bug，这两个对象永远都是相同的，为什么？</li>
</ol>
<p>例二：我们要从商品列表中进入商品编辑页面，这时，我们点击了编辑，将<code>goodModel</code>传到第二个页面，在第二个页面操作完之后，用户没有保存信息，返回了，这时你也可能会发现，你列表中的商品信息改变了。</p>
<p>例三：Cell复用造成的布局混乱。<br>上述两种情景是<code>Reference Type</code>，也就是说他们的都指向了堆上的相同对象，这种类型对对象的公用造成了一系列的bug。并且这种bug很难被发现，并且往往也不是必现的。<br>怎样解决呢？<br>这时我们就需要Copy原来的instance，在OC中我们需要遵守NSCopying，或者NSMutableCopying协议，因为这些，然后实现相应的协议，例如：</p>
<pre><code class="Objective-C">@interface HYLocationModel : NSObject&lt;NSMutableCopying&gt;
// cityDic{@&quot;name&quot;:@&quot;&quot;,@&quot;id&quot;:@&quot;&quot;}
@property (nonatomic, strong) NSDictionary *cityDic; //City
@property (nonatomic, strong) NSDictionary *areaDic; //
@property (nonatomic, strong) NSDictionary *districtDic;

@end
@implementation HYLocationModel
- (id)mutableCopyWithZone:(NSZone *)zone {

    HYLocationModel *locationModel = [[HYLocationModel alloc]init];
    locationModel.cityDic = self.cityDic;
    locationModel.areaDic = self.areaDic;
    locationModel.districtDic = self.districtDic;
    return locationModel;
}
@end</code></pre>
<p>这样我们就可以Copy对象了，将Copy的对象赋值给self.originInfo，就可以解决上述的bug。<br>但是这会消耗性能，因为需要在堆里开辟内存空间。NSCopying协议在OC中很常见，比如NSString，NSArray，NSDictionary等都遵守NSCopying协议。其中NSDictionary的Key，默认是实现了NSCopying协议的，因为在给NSDictionary赋值的时候，系统默认是Copy了它的Key，因为如果不Copy它的Key，如果你给字典赋值之后改变了这个Key，那么它将会使整个NSDictionary混乱，出现意想不到的Bug。当然这种Copy也会消耗性能。</p>
<h2 id="不可变对象是否可以解决上述问题呢？"><a href="#不可变对象是否可以解决上述问题呢？" class="headerlink" title="不可变对象是否可以解决上述问题呢？"></a>不可变对象是否可以解决上述问题呢？</h2><p>在函数式编程中，我们会使用不可变的<code>Reference Type</code>来消除其可变所带来的问题，想象下如果你做数学题题目A中的X值被题目B改变了，那么会有怎样的结果？<br>在Swift中，我们可以使用let来使其不可变，但是这种不可变的数据结构有以下弊端：</p>
<ol>
<li>可能导致很恶心的接口（见下文）。</li>
<li>不能有效地和机器模型相匹配(因为我们的寄存器，我们的Cache，Memory，Storage都是可变状态的)。</li>
</ol>
<p>比如下面的代码</p>
<pre><code class="Swift"><span class="comment">// With mutability </span>
home.oven.temperature.fahrenheit += <span class="number">10.0</span>

<span class="comment">//Without mutability </span> <span class="keyword">let</span> temp = home.oven.temperature home.oven.temperature = <span class="type">Temperature</span>(fahrenheit: temp.fahrenheit + <span class="number">10.0</span>) </code></pre>
<p>在上面的例子中，我们把Temperature类的某个属性改成了<code>let</code>，那么如果我们要更改这个数值，我们就需要在堆上开辟内存空间然后创建一个新的Temperature，最后更换掉整个Temperature类。<br>Cocoa[Touch]中有很多的不可变类比如：NSDate，NSURL，UIImage，NSNumber等<br>这更加安全了（不需要使用Copy），也不必担心接下来的程序会改变这个数值。</p>
<pre><code class="Objective-C">NSArray&lt;NSString *&gt; *array = [NSArray arrayWithObject: NSHomeDirectory()];
NSString *component;  while ((component = getNextSubdir()) { 
     array = [array arrayByAddingObject: component]; } 
     url = [NSURL fileURLWithPathComponents: array];</code></pre>
<h2 id="Value-Type将怎样解决这种问题呢？"><a href="#Value-Type将怎样解决这种问题呢？" class="headerlink" title="Value Type将怎样解决这种问题呢？"></a>Value Type将怎样解决这种问题呢？</h2><p>Swift中的所有基础类型都是Value Type的，像：Int，Double，String …<br>Swift中所有的Collection都是Value Type的，像：Array，Set，Dictianry…<br>Swift中的<code>Tuples，Struct，Enums</code>如果只包含Value Types那么他们自身也是Value Type的。<br>Value Type要是完全可以直接比较的，可以直接使用<code>==</code>，<strong>自定义的Value Type并且其必须要遵守<code>Equable</code>协议，覆盖<code>==</code>方法才可以使用的</strong>。</p>
<pre><code class="Swift"><span class="keyword">var</span> a: [<span class="type">Int</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]
<span class="keyword">var</span> b: [<span class="type">Int</span>] = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].sorted(by:&lt;)
<span class="built_in">assert</span>(a == b) <span class="comment">// true</span></code></pre>
<p>如果是自身的定义的Struct，那么需要遵守<code>Equable</code>协议，并且覆盖<code>==</code>方法来实现。比如：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">Temperature</span>: <span class="title">Equatable</span> </span>{
  <span class="keyword">var</span> celsius: <span class="type">Double</span> = <span class="number">0</span>
  <span class="keyword">var</span> fahrenheit: <span class="type">Double</span> {
    <span class="keyword">get</span> { <span class="keyword">return</span> celsius * <span class="number">9</span> / <span class="number">5</span> + <span class="number">32</span> }
    <span class="keyword">set</span> { celsius = (newValue - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span> }
 }
}
<span class="function"><span class="keyword">func</span> ==<span class="params">(lhs: Temperature, rhs: Temperature)</span></span> -&gt; <span class="type">Bool</span> {
  <span class="keyword">return</span> lhs.celsius == rhs.celsius
} </code></pre>
<p>使用Value Type不用担心竞争条件。也就是不用担心资源抢夺，加锁等。看下面的代码：</p>
<pre><code class="Swift"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]
scheduler.processNumbersAsynchronously(numbers) <span class="comment">//异步处理numbers</span>
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;numbers.<span class="built_in">count</span> { numbers[i] = numbers[i] * i }
scheduler.processNumbersAsynchronously(numbers) <span class="comment">//异步处理numbers</span></code></pre>
<p>在Reference Type中这个<code>numbers</code>将会发生资源抢夺，但在Swift中是Value Type的，在执行<code>for i in 0..&lt;numbers.count { numbers[i] = numbers[i] * i }</code>的时候会发生Copy操作，所以不会发生资源抢夺。也就是说每次将Value Type赋值给其它的Value Type的时候会发生拷贝（逻辑拷贝）操作，但是这种Copy消耗的时间很微小，并且系统会将Copy推迟到写操作执行的时候，这就是Copy on Write。<em>在Swift中可以利用Protocol将Struct等ValueType封装，类似于OOP中的多态</em></p>
<h2 id="Swift中的Value-Type和Reference-Type混用会怎样呢？"><a href="#Swift中的Value-Type和Reference-Type混用会怎样呢？" class="headerlink" title="Swift中的Value Type和Reference Type混用会怎样呢？"></a>Swift中的Value Type和Reference Type混用会怎样呢？</h2><p>我们来看Structh中含有结构体的情况：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">ButtonWrapper</span> </span>{
   <span class="keyword">var</span> button: <span class="type">Button</span>
}</code></pre>
<p>在这种情况下，复制ButtonWrapper的时候将会共享button这个Reference Type。这就违背了我们上文所说的Value Type在重新赋值的时候拷贝（深拷贝，和原来的Struct没有关系）。怎样才可以做到这一点呢？比如下面的</p>
<h3 id="Value-Type-中含有不可变的Reference-Type"><a href="#Value-Type-中含有不可变的Reference-Type" class="headerlink" title="Value Type 中含有不可变的Reference Type"></a>Value Type 中含有不可变的Reference Type</h3><pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">Image</span>: <span class="title">Drawable</span> </span>{
  <span class="keyword">var</span> topLeft:<span class="type">CGPoint</span>
  <span class="keyword">var</span> image: <span class="type">UIImage</span>
}
<span class="keyword">var</span> image = <span class="type">Image</span>(topLeft:<span class="type">CGPoint</span>(x:<span class="number">0</span>,y:<span class="number">0</span>),image:<span class="type">UIImage</span>.<span class="keyword">init</span>(named: <span class="string">"someImage.png"</span>))
<span class="keyword">var</span> image2 = image</code></pre>
<p>这时image和image2将会公用一个UIImage：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-fb29f1978b1a0b66.png" alt="ValueType Contains Reference Type"><br>在实现<code>Equatable</code>协议的时候，我们这么做：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">extension</span> <span class="title">Image</span>: <span class="title">Equatable</span> </span>{   }
<span class="function"><span class="keyword">func</span> == <span class="params">(<span class="keyword">left</span>:Iamge, <span class="keyword">right</span>:Image)</span></span> -&gt; <span class="type">Bool</span> {
 <span class="keyword">return</span> <span class="keyword">left</span>.topLeft == <span class="keyword">right</span>.topLeft &amp;&amp; <span class="keyword">left</span>.image === <span class="keyword">right</span>.image
}</code></pre>
<p>但是由于UIImage是不可变的，所以我们不必担心image2的image对象的改变会影响到image的image对象。<br><em>注：上面<code>===</code>表示引用相同，但是不表示其指向<code>Image</code>是相同的，如果要表示其相同，需要使用<code>==</code>操作。</em></p>
<h3 id="Value-Type-中含有可变的Reference-Type"><a href="#Value-Type-中含有可变的Reference-Type" class="headerlink" title="Value Type 中含有可变的Reference Type"></a>Value Type 中含有可变的Reference Type</h3><p>下面我们来看一个可变的Reference Type。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">BezierPath</span>: <span class="title">Drawable</span> </span>{
  <span class="keyword">var</span> path = <span class="type">UIBezierPath</span>()
  <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> {
    <span class="keyword">return</span> path.empty
} 
  <span class="comment">// **注意这种写法是错误的**</span>
  <span class="function"><span class="keyword">func</span> <span class="title">addLineToPoint</span><span class="params">(point: CGPoint)</span></span> {
    path.addLineToPoint(point)
} } </code></pre>
<p>其内存结构是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-f574f73819356261.png" alt="Value Contains Reference Type"></p>
<p>这时如果我们如果执行下面的代码</p>
<pre><code class="Swift"><span class="keyword">var</span> bezierPath1 = bezierPath0</code></pre>
<p>就会发现意想不到的Bug，因为你对bezierPath1的任何改动都将会显示到bezierPath0上。<br>怎样解决这样的问题呢？这时我们需要使用<strong>Copy On Write</strong></p>
<blockquote>
<p>对Value Type中的Reference Type做改动将会破坏Value Type的”完全独立”特性。<br>所以我们必须将可变的Reference Type和不可变的操作分开<br>不可变操作总是安全的<br>可变操作必须首先Copy</p>
</blockquote>
<p>怎样做到Copy On Write呢？我们需要给BezierPath中加入如下代码：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">BezierPath</span>: <span class="title">Drawable</span> </span>{ 
<span class="keyword">private</span> <span class="keyword">var</span> _path = <span class="type">UIBezierPath</span>()  <span class="keyword">var</span> pathForReading: <span class="type">UIBezierPath</span> { 
<span class="keyword">return</span> _path 
}  <span class="keyword">var</span> pathForWriting: <span class="type">UIBezierPath</span> {
    <span class="keyword">mutating</span> <span class="keyword">get</span> {      _path = _path.copy() <span class="keyword">as</span>! <span class="type">UIBezierPath</span> 
    <span class="keyword">return</span> _path 
} } 
}</code></pre>
<p>这样我们就可以将上述的错误代码改为：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">extension</span> <span class="title">BezierPath</span> </span>{ 
<span class="keyword">var</span> isEmpty: <span class="type">Bool</span> {
<span class="keyword">return</span> pathForReading.empty 
} 
 <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addLineToPoint</span><span class="params">(point: CGPoint)</span></span> {
    pathForWriting.addLineToPoint(point)
  }
}</code></pre>
<p>这样，我们在执行：</p>
<pre><code class="Swift"><span class="keyword">var</span> path = <span class="type">BezierPath</span>()
<span class="keyword">var</span> path2 = path
<span class="keyword">if</span> path.empty { <span class="built_in">print</span>(<span class="string">"Path is empty"</span>) }
<span class="keyword">var</span> path2 = path
path.addLineToPoint(<span class="type">CGPoint</span>(x: <span class="number">10</span>, y: <span class="number">20</span>))
path.addLineToPoint(<span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">125</span>))</code></pre>
<p>这段代码的时候就会在addLineToPoint的时候执行Copy，这就不会出现改动path而影响path2的现象了。<br>但是还有一个问题，每次执行addLineToPoint的时候都需要执行Copy操作，有时候如果这个对象只有一个引用那么就不需要这种操作，所以我们可以利用<code>isUniquelyReferencedNonObjC()</code>方法来判断时候需要Copy,如果返回true，说明只有一个对象在用，就不必Copy，如果返回false，说明很多对象在用，这个时候就需要执行Copy操作了。<br>用法如下：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">MyWrapper</span> </span>{
  <span class="keyword">var</span> _object: <span class="type">SomeSwiftObject</span>
  <span class="keyword">var</span> objectForWriting: <span class="type">SomeSwiftObject</span> {
    <span class="keyword">mutating</span> <span class="keyword">get</span> {
     <span class="keyword">if</span> !<span class="built_in">isUniquelyReferencedNonObjC</span>(&amp;_object)) {
        _object = _object.copy()
     }
     <span class="keyword">return</span> _object
    }
} }</code></pre>
<blockquote>
<p>注：</p>
<ol>
<li>需要标示记忆过程的时候，比如实现撤销操作，需要恢复之前数值的时候。（备忘录模式）</li>
<li>比如需要对新的变化做特殊处理的时候，因为我们已经记忆了之前的过程，只需要对最新的Value Type改变，比如：本博客中的第一张图片，如果衣服颜色改变了，那么就只改变衣服颜色的那几个方格的值即可。</li>
</ol>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://developer.apple.com/videos/play/wwdc2015/414/" target="_blank" rel="noopener">https://developer.apple.com/videos/play/wwdc2015/414/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/01/Why-Swift-IS-swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/01/Why-Swift-IS-swift/" itemprop="url">为什么Swift比OC快？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-01T19:34:23+08:00">2017-08-01</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Swift相比OC以及其它语言，有很多的优化点，这篇文章将从方法调度的角度去说明为什么Swift要比OC更快。OC是一门动态的语言，很多实际执行需要在运行时才可以确定，Swift不一样，<strong>Swift将很多在运行时才可以确定的信息，在编译期就决定了</strong>。这就让Swift更加快速。<br>方法调度就是程序在触发方法时选择需要执行指令的过程，它在每次方法执行时都会发生。如果这种调度发生在编译期，我们称它为静态调度（Static Dispatch），如果调度发生在运行时，那么我们称它为动态调度（Dynamic Dispatch）。静态调度往往要比动态调度要快。那么问题来了，为什么我们需要动态调度呢？全部用静态调度不就得了？<br>问题就在于我们很多时候我们需要用到多态，看看下面这段非常简单的代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"animal eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sleep</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"animal sleep"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">sleep</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"dog sleep"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"rabbit sleep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">sleep</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"rabbit sleep"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animal:<span class="type">Animal?</span></span><br><span class="line"><span class="keyword">var</span> somThingTrue = <span class="literal">false</span></span><br><span class="line"><span class="comment">//执行很多业务逻辑</span></span><br><span class="line"><span class="keyword">if</span> somThingTrue &#123;</span><br><span class="line">    animal = <span class="type">Rabbit</span>()</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    animal = <span class="type">Dog</span>()</span><br><span class="line">&#125;</span><br><span class="line">animal?.eat()</span><br></pre></td></tr></table></figure>

<p>上面的代码中<code>animal?.eat()</code>就不能够在编译期确定，因为其中需要很多的业务逻辑(比如根据用户的不同，或者网络请求结果的不同)来确定就究竟创建出来的对象是Rabbit还是Dog，也就无法最终确定要调用那个对象的eat()方法。相似的代码在OC中是怎样执行的呢？在OC中编译器会将这个方法翻译成<code>objc_msgSend(target,@selector(eat),nil)</code>这个方法，然后到了运行时，会分为以下几步进行调用：</p>
<ol>
<li>找到方法target中isa对应的Class（如果是类方法要到其metaClass中找）。</li>
<li>从其中的<code>struct objc_method_list **methodLists</code>找到对应的方法实现。</li>
<li>如果没有找到就到superClass的<code>methodLists</code>中找。</li>
</ol>
<p>如果在Swift中，它是怎样做方法调度的呢？</p>
<ol>
<li><p>找到target对应的class</p>
</li>
<li><p>从class的V-Table中的那得到函数的实现<br>Swift中的类会创建一个V-Table，这个Table是一个数组，其中存放的是函数指针。子类会按照父类V-Table中函数的存放，如果子类没有覆盖某个方法，那么就会拷贝父类方法的地址，如上面的例子会得到下面的V-Table。</p>
<h2 id="Animal"><a href="#Animal" class="headerlink" title=" Animal"></a> Animal</h2><p> Index0 eat 0x0001<br> Index1 sleep 0x0004</p>
<h2 id="Dog"><a href="#Dog" class="headerlink" title=" Dog"></a> Dog</h2><p> Index0 eat 0x0001 (copied)<br> Index1 sleep 0x0008 (overrideen)</p>
<h2 id="Rabbit"><a href="#Rabbit" class="headerlink" title=" Rabbit"></a> Rabbit</h2><p> Index0 eat 0x0002 (overrideen)<br> Index1 sleep 0x0003 (overrideen)</p>
<p>可以注意到Dog因为没有覆盖父类的<code>eat</code>方法，所以其copy了父类的<code>0x0010</code>指针。因为Swift是Type Safe的，所以在调用它的时候它不会变成<code>Robot</code>或者其它的类（如果不能通过编译），所以无论是调用上面结构中的Animal，Dog，还是Rabbit类，它都是调用相同的Index，得到对应的方法实现。<strong>将函数指针和Index所做的映射在编译期就确定了，这就大大减少了运行时的工作量，提高了运行速度。</strong>所以在运行时它没有必要知道是哪个类型的实例调用了这个方法，只需要找到相应的V-Table即可，至于是其中的哪个Index已经在编译期确定了，没必要再去查找Index的值。<br>然而Swift的方法调度不仅仅是动态方法调度，还有很多静态方法调度。<br><strong>如果我们将某个方法标记为final或者private，或者我们不用类，而使用结构体，枚举，这时就不需要动态调度，只需要静态调度即可，这样速度会更快。</strong></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/07/30/wwdc-understand-swift-performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/30/wwdc-understand-swift-performance/" itemprop="url">理解Swift的性能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-30T13:26:43+08:00">2017-07-30</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>草稿：</strong><br>本博客主要来源于WWDC2016-416，UnderStanding Swift Performance。<br>Swift性能指标：</p>
<ol>
<li>Stack VS Heap</li>
<li>Reference Count</li>
<li>Method Dispatch中Static多还是Dynamic多<br>栈上的操作更加高效，降低栈指针来创建，增加栈指针来释放栈。<br>堆上可以存放高级数据结构，但是堆的操作效率是更低的，因为每次开辟堆空间都需要寻找空闲的内存块。在消除的时候需要重新插入一个内存块。除此之外，Class等存在堆上的对象，需要开辟我们看不到的空间，这些空间是需要消耗内存的。<br>引用计数的不断操作会降低性能。所以要尽可能少的创建Class。<br>在Struct中包含Class是会降低性能的，我们要尽量减少这种情况的出现，比如在使用纯字符串的时候，我们可以使用Enum，或者其它的值类型来替代。<br>如果Struct中包含Class对象，那么在CopyStruct的时候也会拷贝其引用计数，包含的Class越多，就需要操作更多的retain和release方法方法。<br>Swift在调用一个函数的时候，我们需要跳到对应的方法实现。<br>Static 调度：如果在编译时期就可以确定某个方法的实现的话，就可以直接跳转到相应的方法的。并且是inline方法。既然静态调度这么好，为什么还需要Dynamic Dispatch呢？因为我们需要执行各种业务逻辑，需要根据具体的场景来决定究竟调用那个方法，我们需要使用多态。<br>对于类，那么编译器会增加一个指针来存储来指向那个类的Type信息，并且存到静态区。在执行函数调用时，编译器会到该类型对应的虚拟方法表（VTable）中找到相应的方法实现。将类标记为<code>final</code>时，其方法的调用将变为静态派发。在不需要动态派发的时候，我们应该尽量使用静态派发。</li>
</ol>
<p>怎样是用<code>Struct</code>写多态呢？Protocol类型的变量是怎样被存储，被拷贝，以及方法调度是怎样工作的呢？<br>Static Dispatches VS Dynamic Dispatch<br>Static方法：可以在编译时确定需要调用的方法实现，在运行时，可以直接调用并且可以做<code>inline</code>优化。<br>Dynamic方法：需要在运行时在表中找到对应的方法的实现。并且会妨碍inlining及其它的性能优化。当我们利用了多态之后，我们就难以确定这个方法究竟是调用那个方法，也就是说必须在运行时去确定到底要执行那个方法的实现。<br>Swift中Protocol Type的多态，由于没有继承，所以就没有了<code>V-Table</code>方式的调度。Swift使用了一种Protocol Witness Table的技术来调度Protocol Type的方法，这个表格的入口和该Type的实现先链接，因此找到这个表格就找到了方法的实现，那么我们怎样找到这个Table呢？，注意数组中的数值都有相同的offset，因此Swift使用Existential Container来封装protocol type，它的前三个字（两个字节称为一个字）是valueBuffer，小数据，例如两个word的Point可以存储，但是大于三个字时候，swift将会开辟一个堆空间，并且将这个控件的地址存储在Existential Container里面。<br>Swift让value Type，比如Strut和protocol一起获得了动态调度行为，实现了动态多态。<br>Copy on write：Swift自己提供了Copy on Write的机制，但是如果我们自己写了结构体，并且结构体比较重，还有其它的引用类型，在Copy结构体的时候，我们同时需要Copy这个对象，所以在Write的时候，我们需要判断这个引用类型的引用计数，然后做相应的改变。<br>因此Existential Container需要处理不同的数据类型，这是怎样实现的呢？这需要另外一个基于表的机制–Value Witness Table，程序中的每一个type都有一个这样的表，它包含以下几部分：<br>allocate:<br>copy:<br>destruct:<br>deallocate:<br>Whole Model优化可以让同一个模块中的不同文件都可以同时优化。<br>Type不会在运行时改变。</p>
<p>Generics-Small Value<br>如果使用泛型，那么每次函数的调用就只能产生一个call context，并且call context中的类型是一定的，这里Swift不会使用Existential container，它可以直接传递value witness table和 protocol witness table</p>
<ol>
<li>没有比必要开辟堆空间，没有在堆上进行操作，所以不需要考虑线程安全，无需对线程进行加锁。</li>
<li>没有引用计数，操作引用计数也需要是线程安全的，因为引用计数操作极其频繁，所以其性能消耗会逐渐增多，并且不是可以忽略的。</li>
<li>通过Protocol Witness Table进行动态调度以实现多态<br>Generics-Large Value</li>
<li>使用indirect storage 来开辟堆空间</li>
<li>如果包含引用类型的话会有引用计数</li>
<li>通过Protocol Witness Table进行动态调度实现多态</li>
</ol>
<p>总结：<br>尽可能少的使用dynamic runtime，选择合适的抽象。这样编译器可以做错误检查，并且可以做优化，提升代码执行速度。<br>Class类型：identity或者OOP类型的多态。<br>结构体&amp;枚举类型：值语义。<br>Protocol types：动态多态。<br>泛型和值语义相结合可以实现静态多态。<br>使用indirect Storage来处理大数值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="击水湘江">
            
              <p class="site-author-name" itemprop="name">击水湘江</p>
              <p class="site-description motion-element" itemprop="description">努力让明天的自己爱上今天的自己！</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">57</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">击水湘江</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
