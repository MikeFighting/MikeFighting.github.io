<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/mike_apple-touch-icon.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/mike32x32.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/mike16x16.png?v=6.0.3">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT">


<meta name="description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:type" content="website">
<meta property="og:title" content="击水湘江">
<meta property="og:url" content="https://mikefighting.github.io/page/5/index.html">
<meta property="og:site_name" content="击水湘江">
<meta property="og:description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="击水湘江">
<meta name="twitter:description" content="努力让明天的自己爱上今天的自己！">






  <link rel="canonical" href="https://mikefighting.github.io/page/5/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>击水湘江</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">击水湘江</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Born To Fight!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/07/28/note-advance-swift-collection-protocols/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/28/note-advance-swift-collection-protocols/" itemprop="url">Swift中Collection的Protocol</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-28T17:37:51+08:00">2017-07-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Sequences"><a href="#Sequences" class="headerlink" title="Sequences"></a>Sequences</h2><p><code>Sequence</code>协议位于系统架构的底层，其定义是<br>   <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">associatedtype</span> <span class="type">Iterator</span>: <span class="type">IteratorProtocol</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span>-&gt; <span class="type">Iterator</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h2><pre><code><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">IteratorProtocol</span></span>&#123;</span><br><span class="line"><span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span>-&gt; <span class="type">Element?</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>实现了IteratorProtocol协议就可以遍历实例中的数据了，比如：<br>    <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PrefixIterator</span>:<span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> string:<span class="type">String</span></span><br><span class="line">   <span class="keyword">var</span> offset:<span class="type">String</span>.<span class="type">Index</span></span><br><span class="line">   <span class="keyword">init</span>(string:<span class="type">String</span>) &#123;</span><br><span class="line">       <span class="keyword">self</span>.string = string</span><br><span class="line">       offset = string.startIndex</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">typealias</span> <span class="type">Element</span> =  <span class="type">String</span> <span class="comment">// 这里可以省略，因为编译器可以从返回值的类型中推断出来</span></span><br><span class="line">   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">guard</span> offset &lt; string.endIndex <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">       offset = string.index(after: offset)</span><br><span class="line">       <span class="keyword">let</span> offSetString = string[string.startIndex..&lt;offset]</span><br><span class="line">       <span class="keyword">return</span> offSetString;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> prefixIterator = <span class="type">PrefixIterator</span>.<span class="keyword">init</span>(string: <span class="string">"Hello"</span>)</span><br><span class="line"> <span class="keyword">while</span> <span class="keyword">let</span> content = prefixIterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PrefixSequence</span>:<span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> string: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">PrefixIterator</span> &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> <span class="type">PrefixIterator</span>(string:string)</span><br><span class="line">       </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">prefix</span> <span class="keyword">in</span> <span class="type">PrefixSequence</span>(string:<span class="string">"Hello"</span>)&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"for in\(prefix)"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">PrefixSequence</span>(string:<span class="string">"Hello"</span>).<span class="built_in">map</span> &#123;$<span class="number">0</span>.uppercased()&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，我么要想对一个Type实现for in 操作，需要两步：</p>
<ol>
<li>创建一个遍历器：让其遵守<code>IteratorProtocol</code>协议</li>
<li>创建一个Type：让其遵守<code>Sequence</code>协议，在实现<code>makeIterator</code>方法时将第一步中的<code>Iterator</code>返回即可<br><code>Iterator</code>有两种不同的语义，<strong>值语义</strong>(将要遍历的实例拷贝)和<strong>引用语义</strong>（不拷贝所遍历的实例），比如</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">		<span class="keyword">let</span> sequ = <span class="built_in">stride</span>(from: <span class="number">0</span>, to: <span class="number">10</span>, by: <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">var</span> i1 = sequ.makeIterator() <span class="comment">// StrideToIterator</span></span><br><span class="line">		i1.next() <span class="comment">//Optional(0)</span></span><br><span class="line">		i1.next() <span class="comment">//Optional(1)</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">var</span> i2 = i1;</span><br><span class="line">		i1.next() <span class="comment">//Optional(2)</span></span><br><span class="line">		i1.next() <span class="comment">//Optional(3)</span></span><br><span class="line">		</span><br><span class="line">		i2.next() <span class="comment">//Optional(2)</span></span><br><span class="line">		i2.next() <span class="comment">//Optional(3)</span></span><br><span class="line">		```	</span><br><span class="line">这个<span class="type">StrideToIterator</span>是值语义，所以在赋值的时候会执行拷贝操作。</span><br><span class="line"><span class="type">AnyIterator</span>会将基础<span class="type">Iterator</span>用内部box对象封装，这个box对象时引用类型的，所以其是引用语义。比如:</span><br><span class="line">      ```<span class="type">Swift</span></span><br><span class="line">      <span class="keyword">var</span> i3 = <span class="type">AnyIterator</span>(i1)</span><br><span class="line">      <span class="keyword">var</span> i4 = i3   </span><br><span class="line">      i3.next() <span class="comment">// Optional(4)</span></span><br><span class="line">      i4.next() <span class="comment">// Optional(5)</span></span><br><span class="line">      <span class="keyword">let</span> fibsSequence2 = sequence(state:(<span class="number">0</span>, <span class="number">1</span>)) &#123; (state:<span class="keyword">inout</span> (<span class="type">Int</span>, <span class="type">Int</span>)) -&gt; <span class="type">Int?</span> <span class="keyword">in</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">let</span> upcomingNumber = state.<span class="number">0</span></span><br><span class="line">    state = (state.<span class="number">1</span> , state.<span class="number">0</span> + state.<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> upcomingNumber</span><br><span class="line">    </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">Array</span>(fibsSequence2.<span class="keyword">prefix</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>  Sequence的闭包是懒执行的，只有到获取某个数值的时候才执行，比如</p>
<pre><code>Array(fibsSequence2.prefix(10))</code></pre><p>   这才让构造方法<code>fibsSequence2.prefix(10)</code>产生作用，如果<code>Sequence</code>提前计算了其数值，因为其实无穷<code>Sequence</code>，所以当越界的时候其就会崩溃。</p>
<p>  有些Sequence是不稳定的，也就是说每次的遍历，结果可能不一样，比如网络流，磁盘文件，UI事件流，以及其它类型的数据，它们都可以被建模，作为<code>Sequence</code>。这也就是为什么，<strong>取出第一个元素的属性只存在于Collection中</strong>，而不是在<code>Sequence</code>中，因为改这个<code>first</code>方法一定要是<code>nondestructive</code>的，也就是说取出第一个元素不应该对其输出结果产生影响，也就是说必须是稳定的。</p>
<p>  怎样判断一个<code>Sequence</code>是否是稳定的？<br>  如果一个<code>Sequence</code>遵守<code>Collection</code>，那么它就是稳定的。<br>  反过来，就不成立了：如果一个<code>Sequence</code>是稳定的，那么它就是遵守<code>Collection</code>协议的。这时不成立的。比如：<code>StrideTo</code>和<code>StrideThrough</code>类型，就是稳定的，然而他们没有遵守<code>Collection</code>协议。</p>
<h2 id="Sequences和Iterator之间的关系是怎样的？"><a href="#Sequences和Iterator之间的关系是怎样的？" class="headerlink" title="Sequences和Iterator之间的关系是怎样的？"></a>Sequences和Iterator之间的关系是怎样的？</h2><p>Sequences和Iterator那么相似，为什么不把他们合并成一个呢？在<code>destructively consumed sequence</code>中可以，因为他们可以共用一个Iterator，但是在<code>stable sequence</code>中是不行的，因为它们需要Iterator提供的隔离的遍历状态和遍历逻辑（这种遍历状态就是Iterator创建的）。<code>makeIterator</code>也就是为了创建这种遍历状态。</p>
<h2 id="SubSequence"><a href="#SubSequence" class="headerlink" title="SubSequence"></a>SubSequence</h2><p>Sequence有另外的一个关联属性SubSequence</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line"><span class="keyword">associatedtype</span> <span class="type">Iterator</span> : <span class="type">IteratorProtocol</span></span><br><span class="line"><span class="keyword">associatedtype</span> <span class="type">SubSequence</span> </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们可以对其<code>SubSequence</code>做以限制，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Iterator</span>.<span class="title">Element</span>: <span class="title">Equatable</span>,</span></span><br><span class="line"><span class="class"><span class="title">SubSequence</span>: <span class="title">Sequence</span>,</span></span><br><span class="line"><span class="class"><span class="title">SubSequence</span>.<span class="title">Iterator</span>.<span class="title">Element</span> == <span class="title">Iterator</span>.<span class="title">Element</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">headMirrorsTrail</span><span class="params">(<span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> head = <span class="keyword">self</span>.<span class="keyword">prefix</span>(n)</span><br><span class="line">    <span class="keyword">let</span> trail = <span class="keyword">self</span>.suffix(n).reversed()</span><br><span class="line">    <span class="keyword">return</span> head.elementsEqual(trail)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>].headMirrorsTrail(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<h2 id="Collection-Protocol"><a href="#Collection-Protocol" class="headerlink" title="Collection Protocol"></a>Collection Protocol</h2><p>   如上文所示Collection都是稳定的<code>Sequence</code>，它可以稳定的被屡次遍历，并且没有破坏。并且其元素可以使用脚标的形式被访问。Colllection的<code>Index</code>通常是<code>integer</code>，存在数组中，并且是有限的。也就是说不像<code>Sequence</code>，<code>Collection</code>必须是有限的。这也就是为啥其有<code>count</code>属性。<br>不仅仅标准库中的<code>Array</code>,<code>Set</code>,<code>Dictionary</code>,<code>CountableRange</code>以及<code>UnsafeBufferProinter</code>等等遵守<code>Collection</code>协议，Foundation库中的<code>Data</code>和<code>IndexSet</code>也遵守<code>Collection</code>协议。  </p>
<p>A Queue Implementation中对算法的解释不是很懂。</p>
<p>如果一个Type要遵守<code>Collection</code>协议，那么它需要满足以下要求：</p>
<ol>
<li>提供startIndex属性</li>
<li>提供endIndex属性</li>
<li>提供一个subscript，它至少是readonly的，用来获取Type的Element</li>
<li>index函数，来寻找Collection的Index</li>
</ol>
<p>由于Collection的协议的很多方法都有默认实现，所以我们在没有特殊处理的时候不需要再实现其他的方法，比如我们定义完Collection之后就可以使用<code>map</code>,<code>flatMap</code>,<code>filter</code>,<code>sorted</code>,<code>joined</code>等方法。<br>为了让我们定义的Collection使用字面量的形式来创建，我们需要实现<code>ExpressibleByArrayLiteral</code>协议，该协议只有一个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ExpressibleByArrayLiteral</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The type of the elements of an array literal.</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    <span class="comment">/// Creates an instance initialized with the given elements.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(arrayLiteral elements: <span class="type">Self</span>.<span class="type">Element</span>...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是在这个初始化方法里面调用自己的<code>Designated</code>初始化方法。</p>
<p>注：<br>   只要是遵守<code>ExpressibleByArrayLiteral</code>的Type都可以使用如<br> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue:<span class="type">FIFOQueue</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure></p>
<p> 这样的方式进行创建，至于创建的类型需要根据声明的类型以及上下文来推断，也就是说在利用[1,2,3,4]这样的方式进行初始化的时候，系统会自动的调用协议中规定的初始化方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/07/28/note-advance-swift-collections/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/28/note-advance-swift-collections/" itemprop="url">Swift中的Dictionary，Set，Range</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-28T09:30:32+08:00">2017-07-28</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Dictionary，Set，Range"><a href="#Dictionary，Set，Range" class="headerlink" title="Dictionary，Set，Range"></a>Dictionary，Set，Range</h1><h2 id="Dictionay的Key"><a href="#Dictionay的Key" class="headerlink" title="Dictionay的Key"></a>Dictionay的Key</h2><p>Swift中<code>Dictionary</code>的<code>Key</code>都应该是可哈希的，也就是遵守<code>Hashable</code>协议，又因为<code>Hashable</code>是<code>Equatable</code>的扩展，所以又必须遵守<code>Equatable</code>协议</p>
<p>在Swift中比较两个Type对象(<strong>引用相等用===</strong>)是否相等，需要遵守<code>Equatable</code>协议，并覆盖<code>==</code>方法，如：</p>
<pre><code>   struct Person {
   var name: String
   var zipCode: Int
   var birthday: Date
}
    extension Person: Equatable {
    static func ==(lhs: Person, rhs: Person) -&gt; Bool {
    return lhs.name == rhs.name
    &amp;&amp; lhs.zipCode == rhs.zipCode
    &amp;&amp; lhs.birthday == rhs.birthday
    }
}</code></pre><p>也就是必须明确一下两点：</p>
<ol>
<li>相等的实例必须有相同的哈希值。</li>
<li>具有相同哈希值的两个对象不一定相等。</li>
</ol>
<p>由于每次往<code>Dictionary</code>中插入数据，都会判断哈希方法，以确定是否覆盖之前<code>Key</code>的<code>Value</code>。所以这个哈希方法应该具备以下两个特点:</p>
<p>一、应该的执行效率就会影响到对<code>Dictionary</code>的操作效率。<br>二、哈希方法应该尽可能得减少碰撞。</p>
<p> 如上面的<code>Person</code>所示，如果要做为<code>Key</code>就还需要增加下面的代码：</p>
<pre><code>extension Person: Hashable {
  var hashValue:Int {
  returen name.hasValue^zipCode.hashValue^birthday.hashValue
  }
}</code></pre><p>注：</p>
<ol>
<li>标注库中的基础类型如: String,integer,float,boole，以及没有关联值的Enum。</li>
<li>在<code>Dictionary</code>中，如果使用可变的引用类型来作为<code>Key</code>并且将其改变，这个改变同时又改变了哈希值，那么这个<code>Key</code>对应的<code>Value</code>就丢失了。但是如果值类型的实例作为了<code>Key</code>，因为它执行了一次<code>Copy</code>，所以就不用担心被改变了。这也是值类型的一个优势所在。</li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><code>Set</code>是Swift标准库中唯一遵循<code>SetAlgebra</code>协议的类型（Foundation中的:IndexSet和CharacterSet也遵循该协议），<code>SetAlgebra</code>中提供了<code>subtracting</code>减法，<code>intersection</code>取交集，<code>formUnion</code>取并集，<code>isDisjoint</code>是否有交集等代数方法。<code>IndexSet</code>中存储都是正整数，它和Set<int>相比存储效率更高，因为<code>IndexSet</code>是存储范围的，比如10000中的前500个数只需要存储俩个数值：起点和终点。</int></p>
<p>在过滤某个数组中的相同元素时候我们往往可以将其放到<code>Set</code>中，这样就可以将相同元素过滤，但是会遇到一个问题，得打的<code>Set</code>和原来的不是顺序不一样，这时，我们可以给<code>Sequence</code>添加<code>Extension</code>来解决。</p>
<pre><code>extension Sequence where Iterator.Element: Hashable {
func unique() -&gt; [Iterator.Element] {
    var seen:Set&lt;Iterator.Element&gt; = []
    return filter{
        if seen.contains($0){
          return false
        }else{
            seen.insert($0)
            return true
        }
    }
}
}
let result = [1,2,3,12,1,3,4,5,6,4,6].unique()</code></pre><p>通过上面的方法就可以将元素按照原来的顺序排列下来。</p>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>Swift中管更capable的集合叫countable，countable的边界包含<code>integer</code>和指针。但是不包含浮点型，因为<code>Stride</code>对    <code>integer</code>有限制。如果要遍历浮点型数据，那么需要使用<code>stride(from:to:by)</code>，以及<code>stride(from:through:by)</code>来新建一个<code>Sequence</code>。<br>将封闭的<code>Ragne</code>转化成半封闭的<code>Range</code>是不可能的，因为在浮点数的情况下不能确定比最大值小的值是多少。    除非这个<code>Sequence</code>是<code>Strideable</code>的。如果一个函数接受一个Range座位返回值的话，不可以用<code>...</code>来创建。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/07/26/VaporBasicUse/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/VaporBasicUse/" itemprop="url">Vapor的安装和部署</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-26T20:26:22+08:00">2017-07-26</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1513759-fcef541624cb576e.png" alt="Vapor"><br>在Swift后端框架中，Vapor是比较常用的，它发展迅速，语法简洁，社区活跃，现将其在Mac上的简单的使用流程做以介绍。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="一、安装最新版的Xcode"><a href="#一、安装最新版的Xcode" class="headerlink" title="一、安装最新版的Xcode"></a>一、安装最新版的Xcode</h3><p>Xcode是免费的可以直接在App Store中直接下载。下载完之后需要打开Xcode来完成安装，这可能需要等一段时间。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-63e932cd79cf7564.png" alt="安装Xcode"></p>
<h3 id="二、验证Swif是否安装"><a href="#二、验证Swif是否安装" class="headerlink" title="二、验证Swif是否安装"></a>二、验证Swif是否安装</h3><p>通过执行<code>eval &quot;$(curl -sL check.vapor.sh)&quot;</code>来第二次确定安装是否成功。</p>
<h3 id="三、安装Vapor"><a href="#三、安装Vapor" class="headerlink" title="三、安装Vapor"></a>三、安装Vapor</h3><p>确定Swift成功安装之后我们来安装Vapor toolbox，这其中包含了Vapor的所有依赖以及创建项目时好用的CLI。</p>
<h4 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h4><p>Homebrew在安装OpenSSL，MySQL，Postgres，Redis，SQLite等依赖的时候极其有用，没有的时候执行如下命令安装：</p>
<pre><code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><h4 id="安装Homebrew-Tap"><a href="#安装Homebrew-Tap" class="headerlink" title="安装Homebrew Tap"></a>安装Homebrew Tap</h4><p>Vapor的Homebrew Tap可以让你安装Vapor的所有包。执行如下命令安装</p>
<pre><code class="bash">brew tap vapor/homebrew-tap
brew update</code></pre>
<h4 id="安装Vapor"><a href="#安装Vapor" class="headerlink" title="安装Vapor"></a>安装Vapor</h4><p>执行如下命令安装</p>
<pre><code class="bash">brew install vapor</code></pre>
<p>安装完成之后会出现如下图案：</p>
<h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>接下来我们用api模板（toolbox提供了web,api等各种模板）来创建一个Hello的项目。执行如下指令</p>
<pre><code class="bash">vapor new Hello --template=api</code></pre>
<p>然后我们执行<code>tree</code>指令就可以看到如下的目录结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-bb8633f9c5a20c04.png" alt="Vapor 目录结构"><br>如果出现<code>Command not found</code>不能执行请安装tree软件</p>
<pre><code class="bash">brew install tree</code></pre>
<p>我们打开如下的目录找到<code>Routes.swift</code>文件。在Build方法中我们看到：</p>
<pre><code class="Swift"><span class="keyword">get</span>(<span class="string">"plaintext"</span>) { req <span class="keyword">in</span>

<span class="keyword">return</span> <span class="string">"Hello, world!"</span>
}</code></pre>
<p>上述表示执行get方法，闭包返回请求结果。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>确保你所在的是项目的根目录执行如下指令来编译：</p>
<pre><code class="bash">vapor build</code></pre>
<p>执行完毕之后将会看到</p>
<pre><code>Building Project [Done]</code></pre><h3 id="发布状态编译"><a href="#发布状态编译" class="headerlink" title="发布状态编译"></a>发布状态编译</h3><p>在发布状态编译会提升其性能，执行如下指令：</p>
<pre><code class="bash">vapor build --release</code></pre>
<h2 id="启动本地服务"><a href="#启动本地服务" class="headerlink" title="启动本地服务"></a>启动本地服务</h2><p>执行如下指令来启动服务</p>
<pre><code class="bash">vapor run serve</code></pre>
<p>然后你会看到如下信息：</p>
<pre><code class="bash">Server starting....</code></pre>
<p>然后就可以在浏览器中执行<code>localhost:8080/plaintext</code>来看到刚才的<code>Hello, World</code>了。</p>
<h3 id="生成Xcode项目"><a href="#生成Xcode项目" class="headerlink" title="生成Xcode项目"></a>生成Xcode项目</h3><p>我们刚才做的启动等操作都是通过终端来的，我们也可以使用Xcode来完成，要使用Xcode来执行，我们需要首先创建一个*.xcodeproj文件，执行如下指令来创建：</p>
<pre><code class="bash">vapor xcode</code></pre>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>完成上述操作之后你就可以在本地访问自己的服务了，但怎样才能部署到远程，生成自己的链接来访问呢？我们使用Heroku，来完成，Heroku的免费版完全可以满足我们日常练习的需求，并且其简单快捷的Git操作指令一定会让你爱不释手。</p>
<h3 id="创建Heroku账户"><a href="#创建Heroku账户" class="headerlink" title="创建Heroku账户"></a>创建Heroku账户</h3><p>请在<a href="https://devcenter.heroku.com/" target="_blank" rel="noopener">Heroku官网</a>创建自己的账号。</p>
<p>注意要记住自己的邮箱和密码，因为一会儿需要在终端进行登录。</p>
<h3 id="安装Heroku-CLI"><a href="#安装Heroku-CLI" class="headerlink" title="安装Heroku CLI"></a>安装Heroku CLI</h3><p>Heroku CLI用来创建、管理Heroku上apps的命令行工具。执行如下指令来完成安装：</p>
<pre><code class="bash">brew install heroku</code></pre>
<p>安装完成之后执行如下指令来登录，输入邮箱和密码来登录：</p>
<pre><code>heroku login
Enter your Heroku credentials.
Email: adam@example.com
Password (typing will be hidden):
Authentication successful.</code></pre><h3 id="创建程序"><a href="#创建程序" class="headerlink" title="创建程序"></a>创建程序</h3><p>进入你要部署的App，比如上文的Hello项目，然后执行：</p>
<pre><code class="bash"><span class="variable">$cd</span> Hello
<span class="variable">$git</span> init
<span class="variable">$git</span> add.
<span class="variable">$git</span> commit -m <span class="string">"add hello app"</span></code></pre>
<p>然后在Heroku中创建一个app，以便其接收你的代码，执行<code>heroku apps:creat [NAME]</code>指令其中名字必须以字母开头，字呢个包含小写字母，数字和连字符，并且其在heroku的所有程序中必须是唯一的。如果出现：</p>
<pre><code class="bash">Creating app... <span class="keyword">done</span>, ⬢ young-island-91962
         https://young-island-91962.herokuapp.com/ | https://git.heroku.com/young-island-91962.git</code></pre>
<p>这说明执行成功了。<br>执行<code>git remote -v</code>，就会出现远程git的URL了</p>
<pre><code>heroku    https://git.heroku.com/young-island-91962.git (fetch)
heroku    https://git.heroku.com/young-island-91962.git (push)</code></pre><p>然后执行</p>
<pre><code class="bash">heroku create
Creating falling-wind-1624... <span class="keyword">done</span>, stack is cedar-14
http://falling-wind-1624.herokuapp.com/ | https://git.heroku.com/falling-wind-1624.git
Git remote heroku added</code></pre>
<h3 id="注意坑"><a href="#注意坑" class="headerlink" title="注意坑"></a>注意坑</h3><p>然后执行<code>git push heroku master</code><br>这时会报错：</p>
<pre><code class="bash">No default language could be detected <span class="keyword">for</span> this app.
          remote: HINT: This occurs when Heroku cannot detect the buildpack to use <span class="keyword">for</span> this application automatically.</code></pre>
<p>这说明heroku官方没有swift的<code>buildpack</code>，所以我们要自己添加</p>
<pre><code>heroku create --buildpack https://github.com/kylef/heroku-buildpack-swift.git
heroku buildpacks:set https://github.com/kylef/heroku-buildpack-swift.git</code></pre><p>最后在执行push的时候还会报错：</p>
<p><code>error at=error code=H10 desc=&quot;App crashed&quot; method=GET path=&quot;/plaintext&quot;</code>，这时需要修改<code>Procfile</code>文件，<code>Procfile</code>需要放到项目的根目录里，内容如下：</p>
<pre><code class="bash">web: Run --env=production --workdir=./ --config:servers.default.port=<span class="variable">$PORT</span></code></pre>
<p>这样就可以执行Git的push指令进行部署了：</p>
<pre><code class="bash">git push heroku master</code></pre>
<p>随后的操作就变得像平时提交项目一样简单。</p>
<pre><code class="bash">git commit -m <span class="string">"change something"</span> -a
git push heroku master</code></pre>
<p>这样一个项目就部署成功了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/06/05/understanding-must-override/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/05/understanding-must-override/" itemprop="url">RunTime应用实例：MustOverride</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-05T11:41:00+08:00">2017-06-05</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="常用做法"><a href="#常用做法" class="headerlink" title="常用做法"></a>常用做法</h2><p>在IOS开发中，我们的基类往往会写一些空方法，然后让子类去实现，基类控制主要流程(这其实就是模板方法模式)，这时我们往往这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)mustBeOverriddenMethod &#123;</span><br><span class="line">   [<span class="built_in">NSException</span> raise:<span class="string">@"Method did not be overridden"</span> format:<span class="string">@"you must override this method in the subclass"</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>  这样该方法如果直接被父类调用就会报异常，并且提示一定要被子类所覆盖。但是该方法存在如下弊端：</p>
<ol>
<li>该方法一定要被调用才可以报异常，如果子类没有调用该方法，也没有覆盖该方法，父类在某些特定的情况下才调用该方法，那么就会出错。</li>
<li>不可以在该方法内部做一个基本的实现，然后被子类继承并且调用<code>[super mustBeOverriddenMethod]</code></li>
<li>如果项目中存在一个子类，但是暂时没有用到，并且其没有覆写这个方法，那么没有提示。以后其他人用这个类，很可能就会出错。</li>
</ol>
<h2 id="优雅的做法及疑问"><a href="#优雅的做法及疑问" class="headerlink" title="优雅的做法及疑问"></a>优雅的做法及疑问</h2><p>   以上这些问题都可以通过<a href="https://github.com/nicklockwood/MustOverride" target="_blank" rel="noopener">MustOverride</a>框架来实现。<br>   先来看下其用法，然后我们逐步分析其实现方式。<br>   只要在父类需要被实现的方法内容添加一个宏：<code>SUBCLASS_MUST_OVERRIDE</code>即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line">    SUBCLASS_MUST_OVERRIDE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以了，并且更加神奇的是：</p>
<ol>
<li>没有类调用该方法也可以报异常。</li>
<li>就算子类没有被用到也会报异常。</li>
<li>父类中可以做简单的实现，子类可以调用<code>super</code>来扩展该实现。</li>
</ol>
<p>这时你可能产生如下疑问:</p>
<ol>
<li>这个类没有用到为啥可以报异常？</li>
<li>它是怎样找到这个类的被标记了<code>SUBCLASS_MUST_OVERRIDE</code>的方法的？</li>
</ol>
<h2 id="对问题的剖析"><a href="#对问题的剖析" class="headerlink" title="对问题的剖析"></a>对问题的剖析</h2><p>   一切都要从这个宏说起，进入宏的定义可以发现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#define SUBCLASS_MUST_OVERRIDE __attribute__((used, section(<span class="meta-string">"__DATA,MustOverride"</span> \</span></span><br><span class="line">))) <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *__must_override_entry__ = __func__</span><br></pre></td></tr></table></figure>

<p>  是不是感觉有些长？我们可以将该宏拆分：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     <span class="meta">#define SUBCLASS_MUST_OVERRIDE static const char *__must_override_entry__ = __func__</span></span><br><span class="line">__attribute__((used, section(<span class="string">"__DATA, MustOverride"</span> )))</span><br></pre></td></tr></table></figure>

<p> 首先定义了一个静态常量指针<code>__must_override_entry__</code>，这个指针指向<code>__func__</code>，也就是该宏所在方法的方法名。然后利用<code>__attribute__</code>(编译器指令，可以在声明时做一些错误检查，或者一些优化)，将其放入指定的<code>section</code>中（关于section的定义会在后续章节中加以说明）,我们可以在<code>loader.h</code>中看到section是这样一个结构体：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">struct</span> section &#123; <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line"><span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* name of this section */</span></span><br><span class="line"><span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment this section goes in */</span></span><br><span class="line">uint32_t	addr;		<span class="comment">/* memory address of this section */</span></span><br><span class="line">uint32_t	size;		<span class="comment">/* size in bytes of this section */</span></span><br><span class="line">uint32_t	offset;		<span class="comment">/* file offset of this section */</span></span><br><span class="line">uint32_t	align;		<span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">uint32_t	reloff;		<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">uint32_t	nreloc;		<span class="comment">/* number of relocation entries */</span></span><br><span class="line">uint32_t	flags;		<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">uint32_t	reserved1;	<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">uint32_t	reserved2;	<span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>  关于<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/BABCJJID.html" target="_blank" rel="noopener">used的用法我们要到ARM的指令说明中查询</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-4a3f19f66fd72bd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ARM中关于used的说明"></p>
<p>  从上面可以看出，used的意思是告诉编译器该<strong>静态变量</strong>要在该对象文件中被保留（尽管该变量是没有被引用的）。被标注的静态变量将会按照声明的顺序，放到指定的一个section中。使用<code>__attribute__((section(&quot;name&quot;)))</code>可以指明该section.<br>  那么放到section中的静态变量是怎样被使用的呢？<br>  我们可以看到在load方法中，其调用了<code>CheckOverrides</code>函数，也就是在该类加载到Runtime中的时候就被调用，不论其是否被使用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Dl_info info;</span><br><span class="line">dladdr((<span class="keyword">const</span> <span class="keyword">void</span> *)&amp;CheckOverrides, &amp;info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MustOverrideValue mach_header = (MustOverrideValue)info.dli_fbase;</span><br><span class="line"><span class="keyword">const</span> MustOverrideSection *section = GetSectByNameFromHeader((<span class="keyword">void</span> *)mach_header, <span class="string">"__DATA"</span>, <span class="string">"MustOverride"</span>);</span><br><span class="line"><span class="keyword">if</span> (section == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *failures = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (MustOverrideValue addr = section-&gt;offset; addr &lt; section-&gt;offset + section-&gt;size; addr += <span class="keyword">sizeof</span>(<span class="keyword">const</span> <span class="keyword">char</span> **))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *entry = @(*(<span class="keyword">const</span> <span class="keyword">char</span> **)(mach_header + addr));</span><br><span class="line">    <span class="built_in">NSArray</span> *parts = [[entry substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">2</span>, entry.length - <span class="number">3</span>)] componentsSeparatedByString:<span class="string">@" "</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *className = parts[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSRange</span> categoryRange = [className rangeOfString:<span class="string">@"("</span>];</span><br><span class="line">    <span class="keyword">if</span> (categoryRange.length)</span><br><span class="line">    &#123;</span><br><span class="line">        className = [className substringToIndex:categoryRange.location];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> isClassMethod = [entry characterAtIndex:<span class="number">0</span>] == <span class="string">'+'</span>;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(className);</span><br><span class="line">    SEL selector = <span class="built_in">NSSelectorFromString</span>(parts[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Class subclass <span class="keyword">in</span> SubclassesOfClass(cls))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ClassOverridesMethod(isClassMethod ? object_getClass(subclass) : subclass, selector))</span><br><span class="line">        &#123;</span><br><span class="line">            [failures addObject:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ does not implement method %c%@ required by %@"</span>,</span><br><span class="line">                                 subclass, isClassMethod ? <span class="string">'+'</span> : <span class="string">'-'</span>, parts[<span class="number">1</span>], className]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   从中可以看到其从<code>Dl_info</code>中获取了section，<br>   什么是<code>Dl_info</code>，<code>dladdr</code>？<a href="http://man7.org/linux/man-pages/man3/dladdr.3.html" target="_blank" rel="noopener">我们要从Linux指令集中去查找</a>，<br>   <img src="http://upload-images.jianshu.io/upload_images/1513759-635cfd5c1231b6d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Linux中关于dladdr的说明"></p>
<p>  从其中的解释可以看出来，<code>dladdr</code>可以用来确定<code>addr</code>指明的地址是否存在于公用的对象中，这些对象是被调用程序所加载的。如果存在那么<code>dladdr</code>会返回公用对象及重叠<code>addr</code>的表示。该信息被封装到了<code>Dl_info</code>结构体中。取出<code>Dl_info</code>结构体中的<code>dli_fbase</code>,然后调用<code>getsectbynamefromheader_64</code>，就可以获取之前存储数据的<code>section</code>。然后遍历该<code>section</code>以找到所有被标识的方法。接下来利用<code>RunTime</code>找到所有的子类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">static</span> <span class="built_in">NSArray</span> *SubclassesOfClass(Class baseClass)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Class *classes;</span><br><span class="line">	    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> classCount;</span><br><span class="line">	    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">	    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">	      classes = objc_copyClassList(&amp;classCount); <span class="comment">// 获取项目中所有用到的类</span></span><br><span class="line">	    &#125;);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *subclasses = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; classCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Class cls = classes[i];</span><br><span class="line">        Class superclass = cls;</span><br><span class="line">        <span class="keyword">while</span> (superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (superclass == baseClass)</span><br><span class="line">            &#123;</span><br><span class="line">                [subclasses addObject:cls];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            superclass = class_getSuperclass(superclass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subclasses;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>  判断某个类是否覆盖了方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="built_in">BOOL</span> ClassOverridesMethod(Class cls, SEL selector)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> numberOfMethods;</span><br><span class="line">    Method *methods = class_copyMethodList(cls, &amp;numberOfMethods);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfMethods; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (method_getName(methods[i]) == selector)</span><br><span class="line">        &#123;</span><br><span class="line">            free(methods);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(methods);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有覆盖则报异常。<br>小结：MustOverrid在编译期利用<code>__attribute__((used,section(&quot;__DATA, MustOverride&quot;)))</code>来将方法名放到<code>section</code>中，然后在文件加载到runtime的时候找到这个<code>section</code>，进而找到对应地方法，找到所有的子类，利用<code>runtime</code>判断其是否覆盖了父类的方法。</p>
<h2 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h2><p>  关于load方法的几点说明：<br>  在类或者分类被加载到Runtime的时候，会触发<code>load</code>方法；并且只会在第一次被加载的时候被调用，所以只会调用一次。<br>  load方法的调用顺序：</p>
<ol>
<li>父类先调用<code>+load</code>方法，然后子类再调用。</li>
<li>分类调用<code>+load</code>方法要晚于原类。</li>
</ol>
<h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p><a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0474e/BABHIIEF.html" target="_blank" rel="noopener">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0474e/BABHIIEF.html</a><br><a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">http://tech.meituan.com/DiveIntoCategory.html</a><br><a href="http://man7.org/linux/man-pages/man3/dladdr.3.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man3/dladdr.3.html</a><br><a href="https://www.bignerdranch.com/blog/inside-the-bracket-part-5-runtime-api/" target="_blank" rel="noopener">https://www.bignerdranch.com/blog/inside-the-bracket-part-5-runtime-api/</a><br><a href="http://nshipster.com/__attribute__/" target="_blank" rel="noopener">http://nshipster.com/__attribute__/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/05/26/RegEx-in-objc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/RegEx-in-objc/" itemprop="url">正则表达式最佳实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T16:15:00+08:00">2017-05-26</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1513759-47f810d76025ba94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Regular-Expressions"><br>作为一名开发人员，无论是前端，后端，移动端，都可能会接触到正则表达式，最常见的场景就是注册登录了，我们需要对电话号码或者邮箱做校验，如果对用户名有特殊字符有限制的话还会对特殊字符做校验。我们通常的做法就是<strong>百度</strong>或者<strong>谷歌</strong>，最后复制粘贴完事，对于那一串奇奇怪怪的字符串感觉很头大。接下来的这篇文章会向你详细解释正则表达式的语法，分析正则表达式，并且附带上常用的表格，最后给出IOS中用到正则表达式的两个类<code>NSRegularExpress</code>，<code>NSPredicate</code>，NSString。</p>
<h2 id="主要内容包括"><a href="#主要内容包括" class="headerlink" title="主要内容包括"></a>主要内容包括</h2><p>一、简介<br>二、正则表达式的PlayGround<br>三、基本语法表及简介<br>四、正则表达式实例<br>五、正则表达式在IOS中<br>六、常用的正则表达式</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>正则表达式就是一个用来检索或者替换合乎某种条件的一串字符集。</p>
<h2 id="正则表达式的PlayGround"><a href="#正则表达式的PlayGround" class="headerlink" title="正则表达式的PlayGround"></a>正则表达式的PlayGround</h2><p>在学习正则表达式时，面对很多的长篇大论，可能比较枯燥无味，写代码跑项目又比较费时费力。<a href="http://www.regexpal.com/" target="_blank" rel="noopener">regexpal网站</a>（<strong>需要翻墙</strong>）刚好可以解决我们的问题，它可以随时测试我们写的正则是否有误，并且有语法检查和语法提示。在接下来的说明中，可以边看边操作了。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-a0b9b72716437239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正则表达式的PlayGround"></p>
<h2 id="基本语法表及简介"><a href="#基本语法表及简介" class="headerlink" title="基本语法表及简介"></a>基本语法表及简介</h2><p><img src="http://upload-images.jianshu.io/upload_images/1513759-c6cb378e6098d705.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="正则表达式常用指令集"></p>
<ul>
<li>纯文本形式，比如<code>a</code>就将匹配文本中的a,如果<code>Mike</code>就会匹配文本中的Mike，文本之间是<code>与</code>的关系。</li>
<li><strong>\</strong> 其中<code>\</code>是转意字符，表示该字符后面的字母有特殊含义，比如下面要说的<code>\d</code>,<code>\b</code>等，因为在很多语言中，比如0C，Swift中<code>\</code>已经是转意字符，所以需要<code>\\b</code>来表示<code>\b</code>的含义。</li>
<li><strong>[]</strong>匹配里面的任何一个字符，比如<code>p[abcde]</code>，将匹配pa，pb，pc，pd，pe。当然可以换成<code>p[a-e]</code>,其中<code>-</code>表示“至”的意思，<code>[0-9]</code>表示0到9间的任何一个数字。</li>
<li><strong>{}</strong>如上表，表示的是匹配的次数，如{6}，表示匹配六次，{5,}表示匹配5次以上。比较难以理解的是{2,4}?，这表示最少匹配两次，最多匹配四次，但是，如果四个字母同时出现了，就算两个匹配，如果三个字母出现了，就匹配两次。如：正则<code>[A-Z]{2,3}?</code>，检测<code>MIKEF</code>,就会产生两个匹配<code>MI</code>和<code>KE</code>，可以在上文的网站中练习。</li>
<li><strong>.</strong>匹配任何<em>一个字符</em>，比如<code>M.M</code>，匹配MuM，MdM，M@M，等。</li>
<li><strong>\w</strong>匹配<code>很想单词的字符</code>，包含字母，数字，下划线，但是不包含标点符号，及其他字符，比如：<code>hello\w</code>，匹配hello_，hello8，但是不匹配<code>hello!</code>。</li>
<li><strong>\d</strong>匹配数字，其和[0-9]是同意的。例如<code>\d\d?:\d\d</code>就是可以匹配时间，比如<code>12:30</code>和<code>9:20</code>等。digital单词的首字母</li>
<li><strong>\b</strong>表示文字的边界，比如空格和标点符号。如<code>go\b</code>将会匹配go home和go!但是不会匹配gone，在需要匹配整个单词的时候往往有用。boundary单词的首字母</li>
<li><strong>\s</strong>表示空格以及新的一行。比如<code>Hey\s</code>将会匹配<code>Hey man!</code>中的<code>Hey</code>。</li>
<li><strong>^</strong>表示一行的开头，比如<code>^Hello</code>将会匹配<code>Hello Everyone!</code>但是不会匹配<code>He said Hello</code>。注意：在[]里面的<code>^</code>表示的非的意思，如：<code>[^DE]</code>表示的是：不是DE的任何字符。</li>
<li><strong>$</strong>表示行的结尾，例如end$将会匹配<code>it was the end</code>但是不会匹配<code>the end is comming</code>。</li>
<li><strong>*</strong>表示匹配其前面的字符0次或者很多次，如：<code>go\*d</code>,将会匹配good,goood,gooood,goooooood,gd等。</li>
<li><strong>+</strong>表示匹配其前面的字符一次或者很多次，如：<code>go+d</code>将不会匹配<code>gd</code>。</li>
</ul>
<p>注：关于强匹配的概念，如果想了解的可以！<a href="http://www.regular-expressions.info/possessive.html,shang" target="_blank" rel="noopener">在正则ExpressionsInfo网站上学习</a>,<code>捕获</code>的意思就是被捕获的信息可以利用<code>$n</code>的形式来获取并且用来做替换。由于其使用不是很多，就不在赘述。</p>
<h2 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h2><p>经过上面对正则表达式基本语法的讲解及练习，我们来使用试着写几个正则表达式。</p>
<h3 id="英文名字校验，规则如下："><a href="#英文名字校验，规则如下：" class="headerlink" title="英文名字校验，规则如下："></a>英文名字校验，规则如下：</h3><ul>
<li>名字: 标准的英文字母，1到10个字母组成，首字母大写</li>
<li>Middle Name简写：标准英文字母，1个字母，大小写都可以</li>
<li>姓：标准的英文字母，可能有<code>&#39;</code>(只能出现一个)，比如： O’Brien，长度在2到10个字母，首字母大写’</li>
</ul>
<p>根据上面的表格我们很容易写出这样的</p>
<p>名字：<code>^[A-Z][a-z]{1,9}$</code>,其中^表示一行的开始[A-Z]表示第一个字母大写[a-z]表示中间的是小写字母，最后{1,9}表示1到9个字母，最后结尾是$<br>MiddleName: <code>^[a-x]|[A-Z]$</code>,其中|表示或的意思<br>姓：<code>^[A-Z]&#39;?[a-z]{1,9}$</code>，其中’?表示’可以出现一次也可以不出现</p>
<h3 id="日期，规则如下："><a href="#日期，规则如下：" class="headerlink" title="日期，规则如下："></a>日期，规则如下：</h3><p>日期应该在1/1/1900到31/12/2099年之间，并且日期的格式必须是<code>dd/mm/yyyy</code>或<code>dd-mm-yyyy</code>或者<code>dd.mm.yyyy</code>这三种格式：参考上面的速查表，我们可以写出如下的正则表达式来</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^0[1-9]|([1-2]\d)|3[01][/-.]0[1-9]|[1][012][/-.](19|20)\d\d$</span><br></pre></td></tr></table></figure>

<p>其中日期：<code>0[1-9]|([1-2]\\d)|3[01]</code>,也就是穷举了所有的可能01,02,03…9,然后1或者2拼上\d，最后是3可能是30和31<br>月份：<code>0[1-9]|[1][012]</code>,和前面的日期类似，并且更少了，大于10的之后10,11,12几种情况<br>年份：<code>(19|20)\d\d</code>前面是可能出现的年分19和20，后面就是任意0-9的组合<br>分隔符：<code>[/-.]</code>只可能出现这三种情况，所以用[]括起来即可</p>
<h3 id="日期加强版，规则如下："><a href="#日期加强版，规则如下：" class="headerlink" title="日期加强版，规则如下："></a>日期加强版，规则如下：</h3><p>格式是xx/xx/xx或xx.xx.xx或xx-xx-xx，分别是月，日，年，如：10-05-12表示12年10月5日，其中月分可以是英文全拼也可能是缩写，比如January-&gt;Jan，February-&gt;Feb，日期可能第几天，比如1st，2nd之类的，月日年之间可以有不定的几个空格，如March 13th, 2001：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\d&#123;1,2&#125;[-/.]\d&#123;1,2&#125;[-/.]\d&#123;1,2&#125;)|(Jan(uary)?|Feb(ruary)?|Mar(ch)?|Apr(il)?|May|Jun(e)?|Jul(y)?|Aug(ust)?|Sep(tember)?|Oct(ober)?|Nov(ember)?|Dec(ember)?)\s*\d&#123;1,2&#125;(st|nd|rd|th)?+[,]\s*\d&#123;4&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以先用（）将其切开，在用|将其切开<br>先看全是数字的：<code>(\d{1,2}[-/.]\d{1,2}[-/.]\d{1,2})</code>表示两个数字，两个数字的组合，如：<code>10-05-12</code><br>然后看字母类型的<code>(Jan(uary)?|Feb(ruary)?|Mar(ch)?|Apr(il)?|May|Jun(e)?|Jul(y)?|Aug(ust)?|Sep(tember)?|Oct(ober)?|Nov(ember)?|Dec(ember)?</code>穷举了所有的月份信息，然后<code>\s*</code>表示任意多个空格，然后是日期<code>\d{1,2}(st|nd|rd|th)?</code>再加若干个空格：<code>\s*</code>最后是四位数字。</p>
<h3 id="时间，规则如下："><a href="#时间，规则如下：" class="headerlink" title="时间，规则如下："></a>时间，规则如下：</h3><p>时间可以一位或者两位，数字，然后可以有若干个空格，最后是am或者pm，经过以上几个例子，我们不难写出：<code>\d{1,2}\s*[ab]m</code>这样的正则表达式</p>
<h2 id="正则表达式在iOS中的应用"><a href="#正则表达式在iOS中的应用" class="headerlink" title="正则表达式在iOS中的应用"></a>正则表达式在iOS中的应用</h2><h3 id="NSRegularExpress"><a href="#NSRegularExpress" class="headerlink" title="NSRegularExpress"></a>NSRegularExpress</h3><p>在IOS开发中，我们经常使用这个类来做有关文本校验筛选工作，对于对象的校验经常使用<code>NSPredicate</code>，其使用非常简单，主要包含创建，查找，替换几个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">NSString</span> *pattern = <span class="string">@"正则表达式"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"需要校验的文本"</span>;</span><br><span class="line"><span class="built_in">NSRange</span> range = <span class="built_in">NSMakeRange</span>(<span class="number">0</span>, string.length);</span><br><span class="line"><span class="built_in">NSRegularExpression</span> *regex = [<span class="built_in">NSRegularExpression</span> regularExpressionWithPattern:pattern options:<span class="built_in">NSRegularExpressionCaseInsensitive</span> error:&amp;error]; <span class="comment">// 创建RegularExpression对象</span></span><br><span class="line"><span class="built_in">NSArray</span> *matches = [regex matchesInString:string options:<span class="built_in">NSMatchingProgress</span> range:range]; <span class="comment">// 找到校验的结果matches中是NSTextCheckingResult对象，该对象中包含各种被查找对象的信息</span></span><br><span class="line"><span class="comment">// 下面两个方法还可以帮们替换掉找到的字符</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByReplacingMatchesInString:(<span class="built_in">NSString</span> *)string options:(<span class="built_in">NSMatchingOptions</span>)options range:(<span class="built_in">NSRange</span>)range withTemplate:(<span class="built_in">NSString</span> *)templ;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)replaceMatchesInString:(<span class="built_in">NSMutableString</span> *)string options:(<span class="built_in">NSMatchingOptions</span>)options range:(<span class="built_in">NSRange</span>)range withTemplate:(<span class="built_in">NSString</span> *)templ;</span><br></pre></td></tr></table></figure>

<h3 id="NSPredicate和正则表达式结合"><a href="#NSPredicate和正则表达式结合" class="headerlink" title="NSPredicate和正则表达式结合"></a>NSPredicate和正则表达式结合</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span>    *regularExpression = <span class="string">@"正则表达式"</span>;</span><br><span class="line"><span class="built_in">NSPredicate</span> *numberPre = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"SELF MATCHES %@"</span>,regularExpression];</span><br><span class="line"><span class="keyword">return</span> [numberPre evaluateWithObject:textString];</span><br></pre></td></tr></table></figure>

<h3 id="NSString的方法"><a href="#NSString的方法" class="headerlink" title="NSString的方法"></a>NSString的方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSRange</span>)rangeOfString:(<span class="built_in">NSString</span> *)aString options:(<span class="built_in">NSStringCompareOptions</span>)mask;</span><br><span class="line"><span class="built_in">NSRange</span> range = [searchedText rangeOfString:<span class="string">@"正则表达式"</span> options:<span class="built_in">NSRegularExpressionSearch</span>];</span><br></pre></td></tr></table></figure>

<h2 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h2><p>1.验证用户名和密码：”^[a-zA-Z]\w{5,15}$”<br>2.验证电话号码：（”^(\d{3,4}-)\d{7,8}$”）<br>eg：021-68686868  0511-6868686；<br>3.验证手机号码：”^1[3|4|5|7|8][0-9]\d{8}$”；<br>4.验证身份证号（15位或18位数字）：”\d{14}[[0-9],0-9xX]”；<br>5.验证Email地址：(“^\w+([-+.]\w+)<em>@\w+([-.]\w+)*.\w+([-.]\w+)</em>$”)；<br>6.只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$”) ;<br>7.整数或者小数：^[0-9]+([.]{0,1}[0-9]+){0,1}$<br>8.只能输入数字：”^[0-9]<em>$”。<br>9.只能输入n位的数字：”^\d{n}$”。<br>10.只能输入至少n位的数字：”^\d{n,}$”。<br>11.只能输入m~n位的数字：”^\d{m,n}$”。<br>12.只能输入零和非零开头的数字：”^(0|[1-9][0-9]</em>)$”。<br>13.只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。<br>14.只能输入有1<del>3位小数的正实数：”^[0-9]+(.[0-9]{1,3})?$”。<br>15.只能输入非零的正整数：”^+?[1-9][0-9]<em>$”。<br>16.只能输入非零的负整数：”^-[1-9][]0-9″</em>$。<br>17.只能输入长度为3的字符：”^.{3}$”。<br>18.只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。<br>19.只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。<br>20.只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。<br>21.验证是否含有^%&amp;’,;=?$\”等字符：”[^%&amp;’,;=?$\x22]+”。<br>22.只能输入汉字：”^[\u4e00-\u9fa5]{0,}$”。<br>23.验证URL：”^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$”。<br>24.验证一年的12个月：”^(0?[1-9]|1[0-2])$”正确格式为：”01″～”09″和”10″～”12″。<br>25.验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01″～”09″、”10″～”29″和“30”</del>“31”。<br>26.获取日期正则表达式：\d{4}[年|-|.]\d{\1-\12}[月|-|.]\d{\1-\31}日?<br>评注：可用来匹配大多数年月日信息。<br>27.匹配双字节字符(包括汉字在内)：[^\x00-\xff]<br>评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）<br>28.匹配空白行的正则表达式：\n\s<em>\r<br>评注：可以用来删除空白行<br>29.匹配HTML标记的正则表达式：&lt;(\S</em>?)[^&gt;]<em>&gt;.</em>?&lt;/&gt;|&lt;.<em>? /&gt;<br>评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力<br>30.匹配首尾空白字符的正则表达式：^\s</em>|\s<em>$<br>评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式<br>31.匹配网址URL的正则表达式：[a-zA-z]+://[^\s]</em><br>评注：网上流传的版本功能很有限，上面这个基本可以满足需求<br>32.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$<br>评注：表单验证时很实用<br>33.匹配腾讯QQ号：[1-9][0-9]{4,}<br>评注：腾讯QQ号从10 000 开始<br>34.匹配中国邮政编码：[1-9]\d{5}(?!\d)<br>评注：中国邮政编码为6位数字<br>35.匹配ip地址：((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。</p>
<h2 id="延伸阅读："><a href="#延伸阅读：" class="headerlink" title="延伸阅读："></a>延伸阅读：</h2><ol>
<li><a href="https://www.raywenderlich.com/30288/nsregularexpression-tutorial-and-cheat-sheet" target="_blank" rel="noopener">https://www.raywenderlich.com/30288/nsregularexpression-tutorial-and-cheat-sheet</a></li>
<li><a href="http://www.regexpal.com/" target="_blank" rel="noopener">http://www.regexpal.com/</a></li>
<li><a href="http://nshipster.com/nspredicate/" target="_blank" rel="noopener">http://nshipster.com/nspredicate/</a></li>
<li><a href="http://nshipster.com/nssortdescriptor/" target="_blank" rel="noopener">http://nshipster.com/nssortdescriptor/</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/05/26/understanding-web-view-js-bridge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/understanding-web-view-js-bridge/" itemprop="url">WebViewJavaScriptBridge源码剖析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-05-26T16:15:00+08:00">2017-05-26</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>WebViewJavaScriptBridge是IOS中JS和OC交互的常用框架，它利用block的形式处理回调(<a href="https://github.com/MikeFighting/OCJSBridgeDemo" target="_blank" rel="noopener">相关Demo已上传</a>)，支持以下两种调用:</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>它的两种使用场景如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-77f94fd61ed13eef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WebViewJavaScriptBridge使用场景"></p>
<h3 id="OC端的方法如下"><a href="#OC端的方法如下" class="headerlink" title="OC端的方法如下"></a>OC端的方法如下</h3><p>  <img src="http://upload-images.jianshu.io/upload_images/1513759-d5f7a8ecdd8956de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Method Frome OC"><br>  Method 1 是注册一个OC的方法–<code>testObjcCallback</code>,handler是JS掉用的内容，<code>responseCallback</code>是将OC处理返回给JS的回调(对应的是上述第2种调用)；<br>  Method 2 是调用JS的方法的<code>testJavascriptHandler</code>方法，<code>@{ @&quot;foo&quot;:@&quot;before ready&quot; }</code>是需要传递的参数，<code>responseCallback</code>是将JS处理结果返回给OC的回调（对应的是上述的第1种调用）</p>
<h3 id="JS端的方法如下"><a href="#JS端的方法如下" class="headerlink" title="JS端的方法如下"></a>JS端的方法如下</h3><p>  <img src="http://upload-images.jianshu.io/upload_images/1513759-eba410dda0ca2f3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Method Frome JS"><br>  Method 1 是JS注册一个方法供OC调用，<code>responseCallback(responseData)</code>是将处理结果返回OC。<br>  Method 2 是在点击了一个按钮之后JS调用OC的方法，<code>{&#39;foo&#39;: &#39;bar&#39;}</code>是给OC的参数，response是OC处理后返回给JS的数据。<br>  <em>注：JS中是可以不写<code>;</code>号的，这和swift一样</em></p>
<blockquote>
<p>JS调用OC，OC将处理结果回调给JS：要想被JS调用，我们首先要注册一个handler，和回调的            block，注册时候以键值对的形式存储这个block，handler，当JS调用OC时调用<code>webView:shouldStartLoadWithRequest:navigationType:</code>这个方法，根据JS传来的数据，找到之前保存的Block并且调用，同时新建一个需要把处理结果回调给JS的Blcok，OC处理完结果之后调用刚才创建的Block利用<code>stringByEvaluatingJavaScriptFromString</code>将处理结果返回给JS。<br>OC调用JS时与此类似。基于这个流程，我们来看<code>WebViewJavaScriptBridge</code>的实现过程。</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>接下来我们来分析从页面加载到OC和JS互相调用的整个过程：</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>  当加载HTML文件的时候调用<code>[webView loadHTMLString:appHtml baseURL:baseURL];</code>,这时会调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  - (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType &#123;</span><br><span class="line">    <span class="keyword">if</span> (webView != _webView) &#123; <span class="keyword">return</span> <span class="literal">YES</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [request URL];</span><br><span class="line">    __<span class="keyword">strong</span> WVJB_WEBVIEW_DELEGATE_TYPE* strongDelegate = _webViewDelegate;</span><br><span class="line">    <span class="keyword">if</span> ([_base isWebViewJavascriptBridgeURL:url]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([_base isBridgeLoadedURL:url]) &#123;</span><br><span class="line">            [_base injectJavascriptFile];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([_base isQueueMessageURL:url]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *messageQueueString = [<span class="keyword">self</span> _evaluateJavascript:[_base webViewJavascriptFetchQueyCommand]];</span><br><span class="line">            [_base flushMessageQueue:messageQueueString];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [_base logUnkownMessage:url];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:<span class="keyword">@selector</span>(webView:shouldStartLoadWithRequest:navigationType:)]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [strongDelegate webView:webView shouldStartLoadWithRequest:request navigationType:navigationType];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在这个方法中判断URL的类型，如果是<code>WebViewJavascriptBridgeURL</code>那么就会判断是<code>BridgeLoadedURL</code>，<code>QueueMessageURL</code>还是未知的URL，在首次调用时是返回YES的，然后的URL就是<code>BridgeLoadedURL</code>，我们在看它的判断条件<code>[self isSchemeMatch:url] &amp;&amp; [host isEqualToString:kBridgeLoaded];</code>Scheme是自己设置的<code>https</code>，那么<code>BridgeLoaded（__bridge_loaded__）</code>是什么呢？我们看<code>ExampleApp.html</code>文件，发现它的<code>script</code>标签中有这么一段代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  function setupWebViewJavascriptBridge(callback) &#123;</span><br><span class="line">      <span class="keyword">if</span> (window.WebViewJavascriptBridge) &#123; <span class="keyword">return</span> callback(WebViewJavascriptBridge); &#125;</span><br><span class="line">      <span class="keyword">if</span> (window.WVJBCallbacks) &#123; <span class="keyword">return</span> window.WVJBCallbacks.push(callback); &#125;</span><br><span class="line">      window.WVJBCallbacks = [callback];</span><br><span class="line">      var WVJBIframe = document.createElement('iframe');</span><br><span class="line">      WVJBIframe.style.display = 'none';</span><br><span class="line">      WVJBIframe.src = 'https://__bridge_loaded__';</span><br><span class="line">      document.documentElement.appendChild(WVJBIframe);</span><br><span class="line">      setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">setupWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class="line"> var uniqueId = <span class="number">1</span></span><br><span class="line"> function log(message, data) &#123;</span><br><span class="line"> var log = document.getElementById('log')</span><br><span class="line"> var el = document.createElement('div')</span><br><span class="line"> el.className = 'logLine'</span><br><span class="line"> el.innerHTML = uniqueId++ + '. ' + message + ':&lt;br/&gt;' + JSON.stringify(data)</span><br><span class="line"> <span class="keyword">if</span> (log.children.length) &#123; log.insertBefore(el, log.children[<span class="number">0</span>]) &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123; log.appendChild(el) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们发现了<code>https://__bridge_loaded__</code>这个iframe的<code>src</code>，并且在接下来调用<code>setupWebViewJavascriptBridge</code>时这个<code>src</code>会当做一个请求，这时会调用<code>shouldStartLoadWithRequest</code>这个方法。此时就满足了<code>isBridgeLoadedURL</code>这个请求。这时就会调用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_base injectJavascriptFile]</span><br></pre></td></tr></table></figure>

<p>注入一个JS文件，这个JS文件的主要内容是（篇幅问题，有删减）:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">window.WebViewJavascriptBridge = &#123;</span><br><span class="line"> registerHandler: registerHandler,</span><br><span class="line"> callHandler: callHandler,</span><br><span class="line"> disableJavscriptAlertBoxSafetyTimeout: disableJavscriptAlertBoxSafetyTimeout,</span><br><span class="line"> _fetchQueue: _fetchQueue,</span><br><span class="line"> _handleMessageFromObjC: _handleMessageFromObjC</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var messagingIframe;</span><br><span class="line">var sendMessageQueue = [];</span><br><span class="line">var messageHandlers = &#123;&#125;;</span><br><span class="line">var CUSTOM_PROTOCOL_SCHEME = 'https';</span><br><span class="line">var QUEUE_HAS_MESSAGE = '__wvjb_queue_message__';</span><br><span class="line">var responseCallbacks = &#123;&#125;;</span><br><span class="line">var uniqueId = <span class="number">1</span>;</span><br><span class="line">var dispatchMessagesWithTimeoutSafety = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">function registerHandler(handlerName, handler) &#123;</span><br><span class="line"> messageHandlers[handlerName] = handler;</span><br><span class="line">&#125;</span><br><span class="line">function callHandler(handlerName, data, responseCallback) &#123;</span><br><span class="line"> _doSend();</span><br><span class="line">&#125;</span><br><span class="line">function disableJavscriptAlertBoxSafetyTimeout() &#123;</span><br><span class="line"> dispatchMessagesWithTimeoutSafety = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">function _doSend(message, responseCallback) &#123;</span><br><span class="line"> sendMessageQueue.push(message);</span><br><span class="line"> messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _fetchQueue() &#123;</span><br><span class="line"> var messageQueueString = JSON.stringify(sendMessageQueue);</span><br><span class="line"> sendMessageQueue = [];</span><br><span class="line"> <span class="keyword">return</span> messageQueueString;</span><br><span class="line">&#125;</span><br><span class="line">function _dispatchMessageFromObjC(messageJSON) &#123;</span><br><span class="line"> <span class="keyword">if</span> (dispatchMessagesWithTimeoutSafety) &#123;</span><br><span class="line">  setTimeout(_doDispatchMessageFromObjC);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   _doDispatchMessageFromObjC();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">function _doDispatchMessageFromObjC() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _handleMessageFromObjC(messageJSON) &#123;</span><br><span class="line">       _dispatchMessageFromObjC(messageJSON);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">messagingIframe = document.createElement('iframe');</span><br><span class="line">messagingIframe.style.display = 'none';</span><br><span class="line">messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + '://' + QUEUE_HAS_MESSAGE;</span><br><span class="line">document.documentElement.appendChild(messagingIframe);</span><br><span class="line"></span><br><span class="line">registerHandler(<span class="string">"_disableJavascriptAlertBoxSafetyTimeout"</span>, disableJavscriptAlertBoxSafetyTimeout);</span><br><span class="line">setTimeout(_callWVJBCallbacks, <span class="number">0</span>);</span><br><span class="line">function _callWVJBCallbacks() &#123;</span><br><span class="line"> var callbacks = window.WVJBCallbacks;</span><br><span class="line"> delete window.WVJBCallbacks;</span><br><span class="line"> <span class="keyword">for</span> (var i=<span class="number">0</span>; i&lt;callbacks.length; i++) &#123;</span><br><span class="line">  callbacks[i](WebViewJavascriptBridge);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来分析下注入的JavaScript的内容。</p>
<ol>
<li>给window对象添加一个属性<code>WebViewJavascriptBridge</code>（<em>JS中可以直接给对象添加属性</em>）,这个对象包含以下内容：</li>
</ol>
<p>1) registerHandler:注册调用方法<br>2）callHandler:调用OC时的方法<br>3）disableJavscriptAlertBoxSafetyTimeout:超时时弹框是否展示的标示<br>4）_fetchQueue:获取Queue对象的方法<br>5）_handleMessageFromObjC:处理OC调用的方法</p>
<ol start="2">
<li>定义了一系列的变量来存储数据</li>
</ol>
<p>messagingIframe:iframe标签，当我们的WebView加载它的时候，会调用其中的<code>src</code>,<code>src</code>就是调用请求的URL。</p>
<p>   1）sendMessageQueue:message数组<br>   2）messageHandlers:handler对象 <em>JS中{}表示对象</em><br>   3）CUSTOM_PROTOCOL_SCHEME:scheme标示<br>   4）QUEUE_HAS_MESSAGE:有Message标识<br>   5）responseCallbacks:回调对象<br>   6）uniqueId:唯一标示ID</p>
<p>进过系列一的剖析，我们明白了使用<code>WebViewJavaScriptBridge</code>前需要做的准备工作，那么接下来，我们一起探讨<code>OC</code>和<code>JS</code>相互调用的具体执行过程以及其中的要点。</p>
<h2 id="JS调用OC，然后OC将处理结果返回JS"><a href="#JS调用OC，然后OC将处理结果返回JS" class="headerlink" title="JS调用OC，然后OC将处理结果返回JS"></a>JS调用OC，然后OC将处理结果返回JS</h2><h3 id="OC首先注册JS将调用的方法"><a href="#OC首先注册JS将调用的方法" class="headerlink" title="OC首先注册JS将调用的方法"></a>OC首先注册JS将调用的方法</h3><p>OC调用<code>registerHandler:</code>，这时将其调用信息存储在messageHandlers字典中以<code>handlerName</code>为Key,<code>给JS处理结果的Block</code>为Value(<code>_base.messageHandlers[handlerName] = [handler copy]</code>);</p>
<h3 id="在JS中调用被注册的方法"><a href="#在JS中调用被注册的方法" class="headerlink" title="在JS中调用被注册的方法"></a>在JS中调用被注册的方法</h3><p>JS调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> bridge.callHandler(<span class="string">'testObjcCallback'</span>, &#123;<span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line"> log(<span class="string">'JS got response'</span>, response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>来调用上文OC注册的方法，这个brige就是上文注入JS代码时候创建的，我们再它内部做了什么。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> data == <span class="string">'function'</span>) &#123;</span><br><span class="line">        responseCallback = data;</span><br><span class="line">        data = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _doSend(&#123; <span class="attr">handlerName</span>:handlerName, <span class="attr">data</span>:data &#125;, responseCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里判断了参数类型，如果传入的参数只有两个,并且第二个是<code>function</code>类型，那么就将第二个参数变为callBack,data置空，将handlerName和data转化成一个对象的两个属性并传给<code>_doSend()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> _doSend(<span class="params">message, responseCallback</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">           <span class="keyword">var</span> callbackId = <span class="string">'cb_'</span>+(uniqueId++)+<span class="string">'_'</span>+<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">           responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">           message[<span class="string">'callbackId'</span>] = callbackId;</span><br><span class="line">       &#125;</span><br><span class="line">       sendMessageQueue.push(message);</span><br><span class="line">       messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="string">'://'</span> + QUEUE_HAS_MESSAGE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里的responseCallback是<strong>JS先调用OC然后OC调用JS</strong>时才会有的，如果这种情况，那么需要用唯一的标识（callbackId），来将这个responseCallback存储在<code>responseCallbacks</code>中，并且给message添加<code>callbackId</code> 这个属性。<strong>这个数值会在下次OC调用JS的时候作为唯一的Key被用到。</strong>软后将<code>message</code>放入:<code>sendMessageQueue</code>队列中，然后拼接src。</p>
<h3 id="在回掉方法中拦截相应的方法，然后调用block"><a href="#在回掉方法中拦截相应的方法，然后调用block" class="headerlink" title="在回掉方法中拦截相应的方法，然后调用block"></a>在回掉方法中拦截相应的方法，然后调用block</h3><p>经过方法步骤2，会调用下面的回调方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中调用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *messageQueueString = [<span class="keyword">self</span> _evaluateJavascript:[_base webViewJavascriptFetchQueyCommand]];</span><br><span class="line">[_base flushMessageQueue:messageQueueString];</span><br></pre></td></tr></table></figure>

<p> 首先获取JS中的<code>messageQueue</code>(步骤2中的sendMessageQueue)，然后调用<code>flushMessageQueue：</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> messages = [<span class="keyword">self</span> _deserializeMessageJSON:messageQueueString];</span><br><span class="line"><span class="keyword">for</span> (WVJBMessage* message <span class="keyword">in</span> messages) &#123;</span><br><span class="line">    <span class="keyword">if</span> (![message isKindOfClass:[WVJBMessage <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"WebViewJavascriptBridge: WARNING: Invalid %@ received: %@"</span>, [message <span class="keyword">class</span>], message);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> _log:<span class="string">@"RCVD"</span> json:message];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////*********OC先调用了JS,JS再调用了OC*********///////////</span></span><br><span class="line">    <span class="built_in">NSString</span>* responseId = message[<span class="string">@"responseId"</span>];</span><br><span class="line">    <span class="keyword">if</span> (responseId) &#123;</span><br><span class="line">        <span class="comment">//调用之前存储的Bolck</span></span><br><span class="line">        WVJBResponseCallback responseCallback = _responseCallbacks[responseId];</span><br><span class="line">        responseCallback(message[<span class="string">@"responseData"</span>]);</span><br><span class="line">        [<span class="keyword">self</span>.responseCallbacks removeObjectForKey:responseId];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/////////*********JS先调用OC,OC再调用JS*********///////////</span></span><br><span class="line">    <span class="comment">/// 这里是JS先调用OC的时候存储的是 JS的回调函数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JS先调用的OC,OC再调用JS</span></span><br><span class="line">        WVJBResponseCallback responseCallback = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">NSString</span>* callbackId = message[<span class="string">@"callbackId"</span>];</span><br><span class="line">        <span class="keyword">if</span> (callbackId) &#123;</span><br><span class="line">            responseCallback = ^(<span class="keyword">id</span> responseData) &#123;</span><br><span class="line">                <span class="keyword">if</span> (responseData == <span class="literal">nil</span>) &#123;</span><br><span class="line">                    responseData = [<span class="built_in">NSNull</span> null];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//JS调用OC时候的存储（后续OC调用JS返回计算结果）</span></span><br><span class="line">                WVJBMessage* msg = @&#123; <span class="string">@"responseId"</span>:callbackId, <span class="string">@"responseData"</span>:responseData &#125;;</span><br><span class="line">                [<span class="keyword">self</span> _queueMessage:msg];</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseCallback = ^(<span class="keyword">id</span> ignoreResponseData) &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WVJBHandler handler = <span class="keyword">self</span>.messageHandlers[message[<span class="string">@"handlerName"</span>]];</span><br><span class="line">        <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"WVJBNoHandlerException, No handler for message from JS: %@"</span>, message);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用OC的Block,同时，如果OC调用responseCallback，则调用_queueMessage进行相应的处理</span></span><br><span class="line">        handler(message[<span class="string">@"data"</span>], responseCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先将返回的JSON字符串转换成对象，这里的字符串是调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> _fetchQueue(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> messageQueueString = <span class="built_in">JSON</span>.stringify(sendMessageQueue);</span><br><span class="line">  sendMessageQueue = [];</span><br><span class="line">  <span class="keyword">return</span> messageQueueString;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>获取的，这里将<code>sendMessageQueue</code>转为JSON，然后将其置空，这里为啥使用数组而不用对象来存储呢？因为可能JS还没有处理结束就有两次调用，要保证他们不丢失使用了数组。然后判断数组中的Message对象是否有<code>responseId</code>(JS调用OC第一次时存储的),这里没有<code>responseId</code>所以走<code>else</code>:如果有<code>callbackId</code>(在JS中作为回调用的)，定义<code>responseCallback</code>，这个<code>block</code>就是OC将处理结果返回给JS时用到的block。如果没有<code>callbackId</code>说明，不需要回调JS，这个时候<code>responseCallback</code>为空。最后调用步骤1中存储在<code>messageHandlers</code>对象中的block，并且将刚才创建的<code>responseCallback</code>作为参数传入，以便OC将计算结果传递给JS。</p>
<h3 id="OC将计算结果返回给JS"><a href="#OC将计算结果返回给JS" class="headerlink" title="OC将计算结果返回给JS"></a>OC将计算结果返回给JS</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[_bridge registerHandler:<span class="string">@"testObjcCallback"</span> handler:^(<span class="keyword">id</span> data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"testObjcCallback called: %@"</span>, data);</span><br><span class="line">    responseCallback(<span class="string">@"response form oc's call back"</span>);  </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>在<code>handler</code>的最后一步调用<code>responseCallback()</code>将处理结果回调给JS。这个<code>responseCallback()</code>就是我们在步骤3中创建的<code>responseCallback</code>。我们再来看这个block。看步骤3可以看到这个其内部调用</p>
<pre><code>[self _queueMessage:msg];
[self _dispatchMessage:message];</code></pre><p>在<code>_dispatchMessage</code>内部执行:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span>* javascriptCommand = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"WebViewJavascriptBridge._handleMessageFromObjC('%@');"</span>, messageJSON];</span><br></pre></td></tr></table></figure>

<p>接下来JS中的<code>_handleMessageFromObjC</code>就会接收到OC传过来处理结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> _doDispatchMessageFromObjC(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> message = <span class="built_in">JSON</span>.parse(messageJSON);</span><br><span class="line">       <span class="keyword">var</span> messageHandler;</span><br><span class="line">       <span class="keyword">var</span> responseCallback;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (message.responseId) &#123;</span><br><span class="line">           responseCallback = responseCallbacks[message.responseId];</span><br><span class="line">           <span class="keyword">if</span> (!responseCallback) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           responseCallback(message.responseData);</span><br><span class="line">           <span class="keyword">delete</span> responseCallbacks[message.responseId];</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// OC先调用JS是用到</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们看到了步骤三中的<code>responseId</code>的作用了，这时候<code>responseId</code>就表明了是OC将处理结果传递给JS并不需要JS再调用OC了，这时只调用<code>responseCallback(message.responseData);</code>将数据传给JS。<br>这样我们就完成了JS调用OC，然后OC将结果回调给JS的全部过程。</p>
<h2 id="OC调用JS-然后JS将处理结果返回给OC"><a href="#OC调用JS-然后JS将处理结果返回给OC" class="headerlink" title="OC调用JS,然后JS将处理结果返回给OC"></a>OC调用JS,然后JS将处理结果返回给OC</h2><h3 id="JS注册相应的方法供回调"><a href="#JS注册相应的方法供回调" class="headerlink" title="JS注册相应的方法供回调"></a>JS注册相应的方法供回调</h3><p>   同OC注册方法时候一样，JS也是用一个<code>messageHandlers</code>对象来存储</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerHandler</span>(<span class="params">handlerName, handler</span>) </span>&#123;</span><br><span class="line">messageHandlers[handlerName] = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OC调用JS时存储调用信息"><a href="#OC调用JS时存储调用信息" class="headerlink" title="OC调用JS时存储调用信息"></a>OC调用JS时存储调用信息</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendData:(<span class="keyword">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(<span class="built_in">NSString</span>*)handlerName &#123;</span><br><span class="line">      <span class="built_in">NSMutableDictionary</span>* message = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (data) &#123;</span><br><span class="line">          message[<span class="string">@"data"</span>] = data;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">          <span class="built_in">NSString</span>* callbackId = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"objc_cb_%ld"</span>, ++_uniqueId];</span><br><span class="line">          <span class="keyword">self</span>.responseCallbacks[callbackId] = [responseCallback <span class="keyword">copy</span>];</span><br><span class="line">          message[<span class="string">@"callbackId"</span>] = callbackId;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (handlerName) &#123;</span><br><span class="line">          message[<span class="string">@"handlerName"</span>] = handlerName;</span><br><span class="line">      &#125;</span><br><span class="line">      [<span class="keyword">self</span> _queueMessage:message];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里使用<code>message</code>字典来存储参数，方法名，使用<code>responseCallbacks</code>来存储JS处理完之后，需要回调的Block(这里为了确保多次调用不会覆盖之前的调用，使用了唯一的callbackId)。<br>同上文所述，最终会调用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span>*) _evaluateJavascript:(<span class="built_in">NSString</span>*)javascriptCommand &#123;</span><br><span class="line"><span class="keyword">return</span> [_webView stringByEvaluatingJavaScriptFromString:javascriptCommand];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JS调用-dispatchMessageFromObjC"><a href="#JS调用-dispatchMessageFromObjC" class="headerlink" title="JS调用_dispatchMessageFromObjC"></a>JS调用<code>_dispatchMessageFromObjC</code></h3><p>   这时message没有<code>responseId</code>，会走<code>else</code>，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (message.callbackId) &#123;</span><br><span class="line">                <span class="keyword">var</span> callbackResponseId = message.callbackId;</span><br><span class="line">                responseCallback = <span class="function"><span class="keyword">function</span>(<span class="params">responseData</span>) </span>&#123;</span><br><span class="line">                    _doSend(&#123; <span class="attr">handlerName</span>:message.handlerName, <span class="attr">responseId</span>:callbackResponseId, <span class="attr">responseData</span>:responseData &#125;);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> handler = messageHandlers[message.handlerName];</span><br><span class="line">            <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"WebViewJavascriptBridge: WARNING: no handler for message from ObjC:"</span>, message);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler(message.data, responseCallback);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了需要给OC传递结果的<code>responseCallback</code>，取出之前注册的<code>handler</code>:<code>messageHandlers[message.handlerName]</code>，然后调用这个<code>handler</code>，并将这个<code>responseCallback</code>作为参数传进去,<code>handler(message.data, responseCallback);</code></p>
<h3 id="JS将结果回传给OC"><a href="#JS将结果回传给OC" class="headerlink" title="JS将结果回传给OC"></a>JS将结果回传给OC</h3><p>在步骤三中调用handler:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span>(<span class="params">data, responseCallback</span>) </span>&#123;</span><br><span class="line"> log(<span class="string">'ObjC called testJavascriptHandler with'</span>, data)</span><br><span class="line"> <span class="keyword">var</span> responseData = &#123; <span class="string">'Javascript Says'</span>:<span class="string">'Right back atcha!'</span> &#125;</span><br><span class="line"> log(<span class="string">'JS responding with'</span>, responseData)</span><br><span class="line"> responseCallback(responseData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个<code>handler</code>的结尾调用步骤三种的<code>responseCallback</code>（传入的只有数据没有回调），根据步骤三可以看出来其会调用<code>_doSend</code>方法。该方法中由于没有传进去回调，所以不会给message对象添加<code>callbackId</code>，只调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendMessageQueue.push(message);</span><br><span class="line">messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="string">'://'</span> + QUEUE_HAS_MESSAGE;</span><br></pre></td></tr></table></figure>

<p>这是由于含有<code>responseId</code>(在步骤三中的<code>_doSend</code>调用时设置)，所以只会取出之前存储的block,并且将结果回传给OC:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用之前存储的Bolck</span></span><br><span class="line">WVJBResponseCallback responseCallback = _responseCallbacks[responseId];</span><br><span class="line">responseCallback(message[<span class="string">@"responseData"</span>]);</span><br><span class="line">[<span class="keyword">self</span>.responseCallbacks removeObjectForKey:responseId];</span><br></pre></td></tr></table></figure>

<p> 至此，OC和JS交互的所有逻辑已介绍完毕（WKWebView实现方式相同），总结下两种情景的回调，其实现方式及其相似，正如文章开头的总结。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/04/26/frame-work-sdwebimage0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/26/frame-work-sdwebimage0/" itemprop="url">SDWebImage学习笔记（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-26T21:17:00+08:00">2017-04-26</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="保证一段代码在主线程中运行，怎么做更好？"><a href="#保证一段代码在主线程中运行，怎么做更好？" class="headerlink" title="保证一段代码在主线程中运行，怎么做更好？"></a>保证一段代码在主线程中运行，怎么做更好？</h3><p>可以使用一个宏来替代，这样代码更加整洁，如</p>
<pre><code>#define dispatch_main_sync_safe(block)\
if ([NSThread isMainThread]) {\
    block();\
} else {\
    dispatch_sync(dispatch_get_main_queue(), block);\
}
#define dispatch_main_async_safe(block)\
if ([NSThread isMainThread]) {\
    block();\
} else {\
    dispatch_async(dispatch_get_main_queue(), block);\
}</code></pre><h3 id="Block除了常见的回调，还有什么应用场景？"><a href="#Block除了常见的回调，还有什么应用场景？" class="headerlink" title="Block除了常见的回调，还有什么应用场景？"></a>Block除了常见的回调，还有什么应用场景？</h3><p>在具体的处理方式需要客户端传入时。<br>如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSString</span> *(^SDWebImageCacheKeyFilterBlock)(<span class="built_in">NSURL</span> *url);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</span><br></pre></td></tr></table></figure>

<p>该处就是利用Block将处理CacheKey的方法开放给了客户端。通过block的返回值获取。其实这里用代理也可以实现，但是代理相对来说代码量会更多，并且代码较为分散。</p>
<h3 id="我们在加锁的时候一直用-synchronized-self-合理吗？"><a href="#我们在加锁的时候一直用-synchronized-self-合理吗？" class="headerlink" title="我们在加锁的时候一直用@synchronized (self)合理吗？"></a>我们在加锁的时候一直用@synchronized (self)合理吗？</h3><p>不合理，@synchronized (objc)，只要这个objc是同一个对象，那么就会获得同一把锁。如果访问的是两种不同的资源，那么就需要使用两种不同的objc,比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.runningOperations addObject:operation];</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</span><br><span class="line">    isFailedUrl = [<span class="keyword">self</span>.failedURLs containsObject:url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分别是对<code>runningOperations</code>和<code>failedURLs</code>同步，那么就需要使用两种不同的objc，当然都用<code>self</code>不能算错，但是将不需要同步的代码同步了，就降低了系统的性能。另外使用self,还容易引起死锁，比如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//class A</span></span><br><span class="line">   <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">   [_sharedLock lock];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"code in class A"</span>);</span><br><span class="line">   [_sharedLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//class B</span></span><br><span class="line">  [_sharedLock lock];</span><br><span class="line"> <span class="keyword">@synchronized</span> (objectA) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"code in class B"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> [_sharedLock unlock];</span><br></pre></td></tr></table></figure>

<h3 id="如果要让数组中的每个对象都调用某个方法怎么做？"><a href="#如果要让数组中的每个对象都调用某个方法怎么做？" class="headerlink" title="如果要让数组中的每个对象都调用某个方法怎么做？"></a>如果要让数组中的每个对象都调用某个方法怎么做？</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)makeObjectsPerformSelector:(SEL)aSelector</span><br><span class="line">- (<span class="keyword">void</span>)makeObjectsPerformSelector:(SEL)aSelector withObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)argument</span><br></pre></td></tr></table></figure>

<p>以上两个方法可以实现，而不需要分别遍历每个对象，然后分别调用<code>performSelector:</code></p>
<h3 id="内存缓存为啥要用NSCache？"><a href="#内存缓存为啥要用NSCache？" class="headerlink" title="内存缓存为啥要用NSCache？"></a>内存缓存为啥要用<code>NSCache</code>？</h3><p>NSCache和NSDictionary极其相似，他的方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> ObjectType)objectForKey:(KeyType)key;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(ObjectType)obj forKey:(KeyType)key; <span class="comment">// 0 cost</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(ObjectType)obj forKey:(KeyType)key cost:(<span class="built_in">NSUInteger</span>)g;<span class="comment">//该方法不常用，因为精确地计算对象所占的字节是很费力的，并且计算也会影响缓存的效率。</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(KeyType)key;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> totalCostLimit;  <span class="comment">// limits are imprecise/not strict</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> countLimit;  <span class="comment">// limits are imprecise/not strict</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> evictsObjectsWithDiscardedContent;<span class="comment">//内存吃紧时是否删除废弃的对象</span></span><br></pre></td></tr></table></figure>

<p>从中可以看到，他和NSMutableDictioary非常相似，但是为啥在做内存缓存时要用它呢？原因在于：</p>
<ol>
<li>当系统资源将要耗尽时，它可以自动删减缓存。如果采用字典，那么就要自己编写相关逻辑，在系统发出“低内存”通知时手工删减缓存。</li>
<li>NSMutableDictionary是非线程安全的，而NSCache是线程安全的。</li>
<li>NSMutableDictionary中的key必须实现NSCopying协议，NSCache中的key不必实现copy因为它是”保留”键的(强引用)，而不是”拷贝”键的。</li>
<li>如果缓存设置超过了设置的最大值，则会清除旧的数据，保留最新缓存的数据。</li>
</ol>
<h3 id="FOUNDATION-STATIC-INLINE放在方法名前有何作用？"><a href="#FOUNDATION-STATIC-INLINE放在方法名前有何作用？" class="headerlink" title="FOUNDATION_STATIC_INLINE放在方法名前有何作用？"></a>FOUNDATION_STATIC_INLINE放在方法名前有何作用？</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_STATIC_INLINE <span class="built_in">NSUInteger</span> SDCacheCostForImage(<span class="built_in">UIImage</span> *image) &#123;</span><br><span class="line"><span class="keyword">return</span> image.size.height * image.size.width * image.scale * image.scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内联函数的代码会被直接嵌入在被调用的地方，调用几次就嵌入几次，没有使用call指令，这样就减少了在函数调用过程中保存现场（压栈）恢复现场（弹栈）的操作，可以加快执行速度。不过调用次数多的话，会使可执行文件变大，这样会降低速度。相比起宏来说，内核开发者一般更喜欢使用内联函数。因为内联函数没有长度限制，格式限制。编译器还可以检查函数调用方式，以防止其被误用。</p>
<h3 id="inline-内联函数-在什么时候使用？"><a href="#inline-内联函数-在什么时候使用？" class="headerlink" title="inline(内联函数)在什么时候使用？"></a><code>inline</code>(内联函数)在什么时候使用？</h3><p>在<code>SDWebIamgeCompat</code>中使用了<code>inline UIImage *SDScaledImageForKey(NSString *key, UIImage *image)</code>,这是个内联函数(函数代码被放入符号表中，在使用时进行替换,比调用一般的函数更加高效)，那么我们在什么时候使用内联函数呢？<a href="http://stackoverflow.com/questions/1932311/when-to-use-inline-function-and-when-not-to-use-it" target="_blank" rel="noopener">经过查找相关资料</a>，总结下inline的使用场合：<br>使用<strong>inline</strong>的场合：</p>
<ol>
<li>想要使用<code>inline</code>替换<code>#define</code>时。</li>
<li><strong>短函数</strong>。（如果函数的代码较长，使用内联将消耗过多栈内存）</li>
<li>函数调用很频繁。</li>
</ol>
<p>不应使用<code>inline</code>的场合：</p>
<ol>
<li>很大的函数。</li>
<li>和I/O相关的函数。</li>
<li>构造函数和析构函数。</li>
<li>在开发框架时候，使用<code>inline</code>可能会破坏框架的兼容性。</li>
</ol>
<h3 id="获取某个目录下文件的个数："><a href="#获取某个目录下文件的个数：" class="headerlink" title="获取某个目录下文件的个数："></a>获取某个目录下文件的个数：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [_fileManager enumeratorAtPath:<span class="keyword">self</span>.diskCachePath];</span><br><span class="line">count = [[fileEnumerator allObjects] count];</span><br></pre></td></tr></table></figure>

<h3 id="如何让某个属性只在固定版本的时候才会有？"><a href="#如何让某个属性只在固定版本的时候才会有？" class="headerlink" title="如何让某个属性只在固定版本的时候才会有？"></a>如何让某个属性只在固定版本的时候才会有？</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIBackgroundTaskIdentifier</span> backgroundTaskId;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>

<p>上面这段代码就可以让backgroundTaskId在iPhone的版本在4.0以后才会有。</p>
<h3 id="Notification的方法调用所在的线程是根据Post时候所在线程决定的"><a href="#Notification的方法调用所在的线程是根据Post时候所在线程决定的" class="headerlink" title="Notification的方法调用所在的线程是根据Post时候所在线程决定的"></a>Notification的方法调用所在的线程是根据<code>Post</code>时候所在线程决定的</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter]   postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样注册该通知的对象就可以在主线程中调用响应的方法了。</p>
<h3 id="如何保持后台下载图片的线程一直存在？"><a href="#如何保持后台下载图片的线程一直存在？" class="headerlink" title="如何保持后台下载图片的线程一直存在？"></a>如何保持后台下载图片的线程一直存在？</h3><p>使用RunLoop可以让线程常驻(具体解释在我的[实例化讲解RunLoop]中有说明(<a href="https://mikefighting.github.io/2016/04/25/understanding-run-loop/))，调用`CFRunLoopRun()`和`CFRunLoopStop(CFRunLoopGetCurrent())`分别用来开始和结束一个RunLoop">https://mikefighting.github.io/2016/04/25/understanding-run-loop/))，调用`CFRunLoopRun()`和`CFRunLoopStop(CFRunLoopGetCurrent())`分别用来开始和结束一个RunLoop</a></p>
<h3 id="分类中需要填加属性怎么办？"><a href="#分类中需要填加属性怎么办？" class="headerlink" title="分类中需要填加属性怎么办？"></a>分类中需要填加属性怎么办？</h3><p>如果分类中的属性只是分类内部使用，那么其实可以直接使用关联，而不必非要显式创建一个属性，这样也可以直接使用<code>.</code>语法，这时没有属性，所以<code>.</code>语法的无论是在<code>=</code>左边，还是在<code>=</code>右边最终都会调用这个方法，例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> imageURLStorageKey;</span><br><span class="line">- (<span class="built_in">NSMutableDictionary</span> *)imageURLStorage &#123;</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *storage = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;imageURLStorageKey);</span><br><span class="line"><span class="keyword">if</span> (!storage)&#123;</span><br><span class="line">    storage = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLStorageKey, storage, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> storage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何让一个id类型的对象调用某个具体的方法？"><a href="#如何让一个id类型的对象调用某个具体的方法？" class="headerlink" title="如何让一个id类型的对象调用某个具体的方法？"></a>如何让一个<code>id</code>类型的对象调用某个具体的方法？</h3><p>让这个对象遵守某项协议就可以调用,如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation <span class="keyword">in</span> operations) &#123;</span><br><span class="line"><span class="keyword">if</span> (operation) &#123;</span><br><span class="line">    [operation cancel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，如果想让某个方法的返回值具有某个方法，也可以让这个返回值遵守某协议，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">                                        options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:  (SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                        completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;</span><br></pre></td></tr></table></figure>

<h3 id="设计接口时，要尽量考虑使用者的习惯，并对常见错误进行处理"><a href="#设计接口时，要尽量考虑使用者的习惯，并对常见错误进行处理" class="headerlink" title="设计接口时，要尽量考虑使用者的习惯，并对常见错误进行处理"></a>设计接口时，要尽量考虑使用者的习惯，并对常见错误进行处理</h3><p>在需要传入URL参数的地方，使用者很可能不小心传入了字符串，这个时候要么在方法中抛出异常，要么就在内部判断类型并替使用者做相应的转换，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">        <span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</span><br><span class="line">    url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="某个类添加通知的方式"><a href="#某个类添加通知的方式" class="headerlink" title="某个类添加通知的方式"></a>某个类添加通知的方式</h3><p>很多时候某个类要发出通知，我们经常放到宏里，但是如果这两个类是相关的，我们其实可以将通知放到对应的头文件中，然后在<code>.m</code>文件中将其赋值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> SDWebImageDownloadStartNotification;</span><br><span class="line"><span class="comment">///.m</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> SDWebImageDownloadStartNotification = <span class="string">@"SDWebImageDownloadStartNotification"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="使用NSURLConnection时，怎样控制是否缓存请求到的数据？"><a href="#使用NSURLConnection时，怎样控制是否缓存请求到的数据？" class="headerlink" title="使用NSURLConnection时，怎样控制是否缓存请求到的数据？"></a>使用NSURLConnection时，怎样控制是否缓存请求到的数据？</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSCachedURLResponse</span> *)connection:(<span class="built_in">NSURLConnection</span> *)connection willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse &#123;</span><br><span class="line">responseFromCached = <span class="literal">NO</span>; <span class="comment">// If this method is called, it means the response wasn't read from cache</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.request.cachePolicy == <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) &#123;</span><br><span class="line">    <span class="comment">// Prevents caching of responses</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedResponse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这里返回<code>nil</code>，那么将不会缓存这个response，如果返回<code>cachedResponse</code>表示可以缓存这个response.</p>
<p>IOS5.0之后，如果请求和响应满足以下条件，系统就会在如下目录中生成一个Cache.db这样一个数据库来存储缓响应的数据。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-541dae36f7d02f98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生成的缓存目录"><br>在缓存期间如果访问相同的<code>URL</code>，那么就会直接从这个数据库中得到相应的数据;同时在系统的内存告紧时，会自动把内存缓存清空。<br>这个缓存协议被回调的条件是:</p>
<ul>
<li>HTTP或者HTTPS请求（如果是自定义的协议，那么协议需要支持缓存）</li>
<li>请求必须是成功的(状态码为200-299)</li>
<li>响应必须是服务端传回来的，而不是本地缓存传回来的</li>
<li>进行该请求的NSURLRequest对象的<code>cachePolicy</code>是允许缓存的</li>
<li>服务的响应头含有支持缓存的字段</li>
<li>响应的内容大小没有超过缓存的大小（例如，提供磁盘缓存时，响应内容不能超过磁盘缓存的5%）</li>
</ul>
<p><strong>注意</strong>：如果要自定义NSURLCache,那么在自定义NSURLCache进行数据缓存时，一定要在<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>中进行初始化，</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/04/25/mutiple-cocoapods-coexist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/25/mutiple-cocoapods-coexist/" itemprop="url">Cocoapods多版本共存并自由切换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-25T07:43:00+08:00">2017-04-25</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Cocoapods是iOS中的第三方框架管理工具，一台电脑为什么要安装多个版本的Cocoapods呢？在公司里可能存在不同的IOS开发团队分别对不同的业务线进行开发，各个团队之间所用的Cocoapod版本不同，这时你被外派到另外一个团队做开发。</p>
<p><strong>Rubyems</strong>：简称gems是一个用于对rails组建近些年个打包的ruby打包系统，它提供了一个分发ruby程序喝库的标准格式，还提供了一个管理程序包的工具。Rubyems的功能类似于linux下的apt-get，是个包管理器，可以从远程下载所需的包。<br><strong>gem</strong>：你可以这样理解，gem是一系列文件和包的总称，是一些rails项目依赖的软件或者环境，或者是依赖的关系库，当你的项目中缺少的时候，你可以用gem install 来进行安装，这种安装是通过RubyGems这个包管理工具来安装的，当然你也可以通过bundleer来安装。<br><strong>RVM</strong>：Ruby Version Manager,ruby版本管理工具，利用它可以很方便的安装多个版本的Ruby。</p>
<h3 id="实现的原理"><a href="#实现的原理" class="headerlink" title="实现的原理"></a>实现的原理</h3><p>通过RVM来安装多个版本的ruby,再根据不同版本的ruby来安装相应版本的cocoapods，最后使用<code>rvm use</code>命令切换不同的ruby环境来使用不同版本的cocoapods.</p>
<h3 id="常用的几个指令"><a href="#常用的几个指令" class="headerlink" title="常用的几个指令"></a>常用的几个指令</h3><p>*<code>ruby -v</code>查看rugy的版本()<br>*<code>rvm -v</code> (查看rvm的版本)<br>*<code>gem sources -l</code>(查看gem shources)<br>*<code>rvm list</code>(查看已安装的所有版本:ruby)<br>*<code>rvm use rubyVersion</code>(使用某个版本的ruby),例如:<code>rvm use ruby-2.3.3</code><br>*<code>rvm install rubyVersion</code>(安装某个版本的ruby),例如:<code>rvm install 2.3.3</code><br>*<code>rvm use rubyVersion --default</code>(将某个版本的ruby设置为默认版本),例如<code>rvm use 1.9.3 --default</code><br>*<code>rvm remove rubyVersion</code>(删除某个版本的ruby),例如:<code>rvm remove 1.9.3</code><br>*<code>rvm list known</code>查看所有可用的ruby版本<br>*<code>sudo gem install cocoapods -v &lt;Version&gt; -n /usr/local/bin</code>安装cocoapod<br>*<code>gem list</code>查看当前gem下的所有安装包</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>步骤一、 执行<code>rvm -v</code>，如果发现没有<code>rvm</code>则执行<code>curl -L get.rvm.io | bash -s stable &amp;&amp; source ~/.rvm/scripts/rvm</code>安装rvm.<br>步骤二、 执行<code>rvm list known</code>查看所有可用的ruby版本，然后执行<code>rvm install someVersion</code>来执相应版本的ruby； 或者从<a href="https://rvm.io/binaries" target="_blank" rel="noopener">ruby官网</a>上下载不同版本Ruby时，一定要下载osx操作系统的，否则在执行<code>rvm mount ~/Downloads/ruby-2.3.3.tar.bz2</code>时，将会出现<code>Libraries missing for ruby-2.3.3: xcrun. Refer to your system manual for installing libraries</code>，下载完之后到响应的目录下执行<code>rvm mount ruby-2.2.3.tar.bz2</code>就可以安装对应的ruby。<br>步骤三、重复执行步骤二，安装不同版本的ruby，</p>
<h3 id="各种错误及处理方式"><a href="#各种错误及处理方式" class="headerlink" title="各种错误及处理方式"></a>各种错误及处理方式</h3><h4 id="cannot-execute-binary-file这种错误"><a href="#cannot-execute-binary-file这种错误" class="headerlink" title="cannot execute binary file这种错误"></a>cannot execute binary file这种错误</h4><p>执行完:<code>rvm use ruby-2.3.3</code>和<code>sudo gem install cocoapods</code>之后出现:<code>/Users/a58/.rvm/rubies/ruby-2.3.3/bin/ruby: /Users/a58/.rvm/rubies/ruby-2.3.3/bin/ruby: cannot execute binary file</code>这种错误。</p>
<h4 id="Gemset’’does-not-exist"><a href="#Gemset’’does-not-exist" class="headerlink" title="Gemset’’does not exist"></a>Gemset’’does not exist</h4><p>执行完<code>rvm use ruby-2.2.3</code>,出现:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Gemset<span class="string">''</span>does not exist,<span class="string">'rvm ruby-2.2.3 do rvm gemset create '</span> first, or append <span class="string">'--create'</span>.</span><br></pre></td></tr></table></figure>

<p>这种错误是由于没有设置<code>default</code>，在执行<code>rvm list</code>的时候会出现如下`</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Default ruby not set. Try 'rvm alias create default &lt;ruby&gt;'.</span></span><br></pre></td></tr></table></figure>

<p>这样的提示。使用<code>rvm --create ruby-2.1.9</code> 之后这种提示消失。逐个将其他版本的ruby也使用<code>rvm --create rubyVersion</code>这个指令，然后就可以切换至不同版本的ruby了。</p>
<h4 id="ERROR-Could-not-find-a-valid-gem"><a href="#ERROR-Could-not-find-a-valid-gem" class="headerlink" title="ERROR:Could not find a valid gem"></a>ERROR:Could not find a valid gem</h4><p>在执行<code>sudo gem install cocoapods</code>来安装cocoapods 的时候,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:Could not find a valid gem <span class="string">'cocoapods'</span> (&gt;= 0), here is why:</span><br><span class="line">Unable to download data from https://ruby.taobao.org/ - SSL_connect returned=1 errno=0 state=SSLv3 <span class="built_in">read</span> server certificate B: certificate verify failed (https://ruby.taobao.org/specs.4.8.gz)</span><br></pre></td></tr></table></figure>

<p>这是因为淘宝镜像最近出问题了，使用<code>gem sources -a http://rubygems-china.oss.aliyuncs.com</code>再安装一个镜像，然后可以执行<code>sudo gem install cocoapods</code>了，但是在执行<code>pod -v</code>,<code>pod search AFNetworking</code>,<code>pod setup</code>时却发现:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/a58/.rvm/rubies/ruby-2.2.3/lib/ruby/2.2.0/rubygems/dependency.rb:315:<span class="keyword">in</span> <span class="string">'to_specs'</span>: Could not find <span class="string">'cocoapods'</span> (&gt;= 0) among 6 total gem(s) (Gem::LoadError)`。</span><br></pre></td></tr></table></figure>

<h4 id="xcrun-error-active-developer-path…"><a href="#xcrun-error-active-developer-path…" class="headerlink" title="xcrun: error: active developer path…"></a>xcrun: error: active developer path…</h4><p>在执行<code>rvm install 2.1.0</code>时报错:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`xcrun: error: active developer path (<span class="string">"/Applications/Xcode.app/Contents/Developer"</span>) does not exist, use <span class="string">'xcode-select --switch path/to/Xcode.app'</span> to specify the Xcode that you wish to use <span class="keyword">for</span> <span class="built_in">command</span> line developer tools (or see <span class="string">'man xcode-select'</span>)</span><br></pre></td></tr></table></figure>

<p>这是因为rvm寻找的路径是<code>/Applications/Xcode.app/Contents/Developer</code>，而我的Xcode被我修改成了<code>Xcode8.0</code>,找不到路径了，所以把Xcode的名字改过来就好了。</p>
<h4 id="Error-running…"><a href="#Error-running…" class="headerlink" title="Error running…"></a>Error running…</h4><p>需要更新Homebrew</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error running <span class="string">'requirements_osx_brew_update_system ruby-2.1.0'</span>,</span><br><span class="line">showing last 15 lines of /Users/a58/.rvm/<span class="built_in">log</span>/1487732911_ruby-2.1.0/update_system.log`</span><br></pre></td></tr></table></figure>

<p>这个时候需要更新<code>Homebrew</code>,执行<code>brew update</code>来更新Homebrew，这时却发现<code>Error: /usr/local must be writable!</code>，然后点击<code>Command + Shift + G</code>,然后输入<code>/usr</code>这个时候就看到<strong>usr</strong>目录，找到下面的<strong>local</strong>文件夹，右击”Get Info”，将最下面的权限中的everyone改为可读写的，这时就可以执行<code>brew update</code>指令了。执行完之后再执行<code>rvm install ruby 2.2.2</code>，就可看到如下图所示，就说明ruby安装成功了: 执行<code>sudo gem install cocoapods</code>这个指令就可以成安装cocoapods了，接着执行<code>pod --version</code>，就可以查看当前的pod版本号了:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/Users/a58/.rvm/gems/ruby-2.2.2@global/gems/cocoapods-1.2.0/lib/cocoapods/executable.rb:89: warning: Insecure world writable dir /usr/<span class="built_in">local</span> <span class="keyword">in</span> PATH, mode 040777</span><br><span class="line">1.2.0</span><br></pre></td></tr></table></figure>

<p>在执行完<code>brew update</code>之后再执行有关<code>pod</code>的指令还是会报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/a58/.rvm/rubies/ruby-2.2.3/lib/ruby/2.2.0/rubygems/dependency.rb:315:<span class="keyword">in</span> <span class="string">'to_specs'</span>: Could not find <span class="string">'cocoapods'</span> (&gt;= 0) among 6 total gem(s) (Gem::LoadError)</span><br></pre></td></tr></table></figure>

<p>这样的错误。然后把现有的cocoapod卸载，执行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem uninstall cocoapods</span><br></pre></td></tr></table></figure>

<p>卸载完之后执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods -v 1.2.0 -n /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure>

<p>这时依然会出现这个错误</p>
<h4 id="在使用2-0-0版本的ruby安装pod的时候出现如下错误"><a href="#在使用2-0-0版本的ruby安装pod的时候出现如下错误" class="headerlink" title="在使用2.0.0版本的ruby安装pod的时候出现如下错误"></a>在使用2.0.0版本的ruby安装pod的时候出现如下错误</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ERROR:SSL verification error at depth 1: unable to get <span class="built_in">local</span> issuer certificate (20)</span><br><span class="line">ERROR:You must add /O=Digital Signature Trust Co./CN=DST Root CA X3 to your <span class="built_in">local</span> trusted store</span><br><span class="line">ERROR:SSL verification error at depth 2: self signed certificate <span class="keyword">in</span> certificate chain (19)</span><br><span class="line">ERROR:Root certificate is not trusted (/C=US/O=GeoTrust Inc./CN=GeoTrust Global CA)</span><br><span class="line">ERROR:While executing gem ... (Errno::EPERM)</span><br><span class="line">Operation not permitted - /usr/bin/pod</span><br></pre></td></tr></table></figure>

<h4 id="Operation-not-permitted"><a href="#Operation-not-permitted" class="headerlink" title="Operation not permitted -"></a>Operation not permitted -</h4><p>在osx是10.11.6的时候,gem update –system会出错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR:While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/update_rubygems</span><br></pre></td></tr></table></figure>

<p>这时候需要到<a href="https://rubygems.org/pages/download#formats" target="_blank" rel="noopener">rubyGem的官网</a>现在最新的zip文件，解压进入到rubygems-2.6.10文件中，然后执行<code>ruby setup.rb</code>就可以安装gem了。</p>
<h4 id="missing-bin-ruby"><a href="#missing-bin-ruby" class="headerlink" title="missing bin/ruby"></a>missing bin/ruby</h4><p>删除某个版本的<code>ruby</code>的时候，出现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby-2.2.3 [ missing bin/ruby ]</span><br></pre></td></tr></table></figure>

<p>这时前往<code>/Users/用户名/.rvm/rubies/ruby-2.2.3</code>,然后删除对应的<code>ruby-2.2.3</code>即可。</p>
<h4 id="rvm-instlall-2-2-3-报错"><a href="#rvm-instlall-2-2-3-报错" class="headerlink" title="rvm instlall 2.2.3 报错"></a>rvm instlall 2.2.3 报错</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Empty path passed to certificates update, <span class="built_in">functions</span> stack: requirements_osx_update_openssl_cert_run rvm_requiremnts_fail_or_run_action __rvm_osx_ssl_certs_ensure_for_ruby __rvm_osx_ssl_certs_ensure_for_ruby_except_jruby external_import_setup external_import main`，</span><br></pre></td></tr></table></figure>

<p>这时执行<code>rvm reinstall 2.2.3 --disable-binary</code>这个时候又出现错误:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dyld: lazy symbol binding failed: Symbol not found: _clock_gettime</span><br><span class="line">dyld: Symbol not found: _clock_gettime</span><br></pre></td></tr></table></figure>

<p>其原因在于没有安装Xcode的CommandLineTools工具，执行下面的代码：<code>xcode-select --install</code>即可。</p>
<h4 id="ERROR-While-executing-gem…-TypeError"><a href="#ERROR-While-executing-gem…-TypeError" class="headerlink" title="ERROR:While executing gem…(TypeError)"></a>ERROR:While executing gem…(TypeError)</h4><p>安装pod时候出现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`ERROR:While executing gem ... (TypeError)</span><br><span class="line">no implicit conversion of nil into String</span><br></pre></td></tr></table></figure>

<p>执行：gem update –system</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/04/10/useing-core-graphics-for-scratch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/10/useing-core-graphics-for-scratch/" itemprop="url">利用Core Graphics实现刮奖效果</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-10T16:53:00+08:00">2017-04-10</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>刮奖是商家类项目中经常使用的组件，其实现方式也有多种，下面介绍一种使用Core Graphics实现的一种方式。</p>
<p>Core Graphics中有一种根据遮罩图片(Masking Images)和原图片最终合成位图的方法，下面看一个官方文档给出的效果来一个直观的展示。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-1fd246bfd247ca29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原图"><br><img src="http://upload-images.jianshu.io/upload_images/1513759-a551b423e34ebc65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="遮罩图"><br><img src="http://upload-images.jianshu.io/upload_images/1513759-e83b5cbb73ba007d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="合成图"><br>从中可以看到黑色的部分将原图显示了出来，白色的部分把原图遮住了，灰色的部分和原图经过一定的算法进行了合成。我们可以通过不断的改变遮罩层中某部分的颜色，最终产生刮奖的效果。具体步骤如下：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-60f70dd8905db127.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现步骤"><br>从中可以看出，刚开始产生的Marsk是黑色的，这时合成之后蒙层图片原样展示，手指一动的时候往mask上绘制了白色的线条，这样，合成之后蒙层上被划过的地方被白色所取代，这样就出现了刮奖的效果，在每次绘制完成之后只需要调用<code>setNeedsDisplay</code>方法，然后在<code>drawRect</code>方法中不断展现最终合成的图片即可。<br>具体的代码如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGColorSpaceRef</span> colorspace = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line"><span class="keyword">float</span> scale = [<span class="built_in">UIScreen</span> mainScreen].scale;</span><br><span class="line"><span class="comment">//1. 获取刮奖层</span></span><br><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(hideView.bounds.size, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line">[hideView.layer renderInContext:<span class="built_in">UIGraphicsGetCurrentContext</span>()];</span><br><span class="line">hideView.layer.contentsScale = scale;</span><br><span class="line">hideImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>().CGImage;</span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"></span><br><span class="line">size_t imageWidth = <span class="built_in">CGImageGetWidth</span>(hideImage);</span><br><span class="line">size_t imageHeight = <span class="built_in">CGImageGetHeight</span>(hideImage);</span><br><span class="line"><span class="built_in">CFMutableDataRef</span> pixels = <span class="built_in">CFDataCreateMutable</span>(<span class="literal">NULL</span>, imageWidth * imageHeight);</span><br><span class="line"><span class="comment">//2. 获取context手指滑动时不断在这个context上画上白线。</span></span><br><span class="line">contextMask = <span class="built_in">CGBitmapContextCreate</span>(<span class="built_in">CFDataGetMutableBytePtr</span>(pixels), imageWidth, imageHeight , <span class="number">8</span>, imageWidth, colorspace, kCGImageAlphaNone);</span><br><span class="line"><span class="built_in">CGContextFillRect</span>(contextMask, <span class="keyword">self</span>.frame);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置滑动时候产生的线条颜色是白色</span></span><br><span class="line"><span class="built_in">CGContextSetStrokeColorWithColor</span>(contextMask, [<span class="built_in">UIColor</span> whiteColor].CGColor);</span><br><span class="line"><span class="built_in">CGContextSetLineWidth</span>(contextMask, _sizeBrush);</span><br><span class="line"><span class="built_in">CGContextSetLineCap</span>(contextMask, kCGLineCapRound);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGDataProviderRef</span> dataProvider = <span class="built_in">CGDataProviderCreateWithCFData</span>(pixels);</span><br><span class="line"><span class="built_in">CGImageRef</span> mask = <span class="built_in">CGImageMaskCreate</span>(imageWidth, imageHeight, <span class="number">8</span>, <span class="number">8</span>, imageWidth, dataProvider, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 根据iamge mask产生最终的图片</span></span><br><span class="line">scratchImage = <span class="built_in">CGImageCreateWithMask</span>(hideImage, mask);</span><br><span class="line"><span class="built_in">CGImageRelease</span>(mask);</span><br><span class="line"><span class="built_in">CGColorSpaceRelease</span>(colorspace);</span><br></pre></td></tr></table></figure>

<p>手指滑动时候调用的方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">[<span class="keyword">super</span> touchesMoved:touches withEvent:event];</span><br><span class="line"><span class="built_in">UITouch</span> *touch = [[event touchesForView:<span class="keyword">self</span>] anyObject];</span><br><span class="line">currentTouchLocation = [touch locationInView:<span class="keyword">self</span>];</span><br><span class="line">previousTouchLocation = [touch previousLocationInView:<span class="keyword">self</span>];</span><br><span class="line">[<span class="keyword">self</span> scratchTheViewFrom:previousTouchLocation to:currentTouchLocation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制图像</span></span><br><span class="line">- (<span class="keyword">void</span>)scratchTheViewFrom:(<span class="built_in">CGPoint</span>)startPoint to:(<span class="built_in">CGPoint</span>)endPoint &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> needRender = [<span class="keyword">self</span> needRenderWithCurrentLocation:endPoint previousLocation:previousTouchLocation];</span><br><span class="line"><span class="keyword">if</span> (!needRender) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> scale = [<span class="built_in">UIScreen</span> mainScreen].scale;</span><br><span class="line"><span class="built_in">CGContextMoveToPoint</span>(contextMask, startPoint.x * scale, (<span class="keyword">self</span>.frame.size.height - startPoint.y) * scale);</span><br><span class="line"><span class="built_in">CGContextAddLineToPoint</span>(contextMask, endPoint.x * scale, (<span class="keyword">self</span>.frame.size.height - endPoint.y) * scale);</span><br><span class="line"><span class="built_in">CGContextStrokePath</span>(contextMask);</span><br><span class="line"><span class="comment">// 调用drawRect 方法</span></span><br><span class="line">[<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line"><span class="keyword">self</span>.isDrawn = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line"><span class="built_in">UIImage</span> *imageToDraw = [<span class="built_in">UIImage</span> imageWithCGImage:scratchImage];</span><br><span class="line">[imageToDraw drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="keyword">self</span>.frame.size.width, <span class="keyword">self</span>.frame.size.height)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/04/07/understanding-aspects-source-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/07/understanding-aspects-source-code/" itemprop="url">IOS中AOP框架Aspects源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-07T16:38:00+08:00">2017-04-07</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="iOS中AOP框架Aspects源码分析"><a href="#iOS中AOP框架Aspects源码分析" class="headerlink" title="iOS中AOP框架Aspects源码分析"></a>iOS中AOP框架Aspects源码分析</h2><p>AOP是Aspect Oriented Programming的缩写，意思就是面向切面编程。具体的解释可以到<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="noopener">维基百科</a>上或者其它地方查看。在IOS中使用Swizzle技术可以实现面向切面编程，我在<a href="http://www.jianshu.com/p/69859d580354" target="_blank" rel="noopener">RunTime应用实例–关于埋点的思考</a>博文中也提到了Aspects框架，下面就来对该框架做以分析。</p>
<h2 id="一般的Swizzle是怎么实现的？"><a href="#一般的Swizzle是怎么实现的？" class="headerlink" title="一般的Swizzle是怎么实现的？"></a>一般的Swizzle是怎么实现的？</h2><p>在RunTime应用实例–关于埋点的思考，也讲到了MethodSwizzle的技术，下面来看最常见的实现方案。比如我们要Hook住UIButton的<code>sendAction:to:forEvent:</code>，这时候我们一般这样做:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="keyword">void</span>)load&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    SEL originSEL = <span class="keyword">@selector</span>(sendAction:to:forEvent:);</span><br><span class="line">    SEL swizzleSEL = <span class="keyword">@selector</span>(swizzleSendAction:to:forEvent:);</span><br><span class="line">    Class processedClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    Method originMethod = class_getInstanceMethod(processedClass, originSEL);</span><br><span class="line">    Method swizzleMethod = class_getInstanceMethod(processedClass, swizzleSEL);</span><br><span class="line">    method_exchangeImplementations(originMethod, swizzleMethod);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)swizzleSendAction:(SEL)action to:(<span class="keyword">id</span>)target forEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line"><span class="comment">// 执行相应的逻辑</span></span><br><span class="line"><span class="comment">// 调用原来的系统方法</span></span><br><span class="line">[<span class="keyword">self</span> swizzleSendAction:action to:target forEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的解释可以参见<strong>RunTime应用实例–关于埋点的思考</strong>这篇文章。</p>
<h2 id="这样做有什么弊端？"><a href="#这样做有什么弊端？" class="headerlink" title="这样做有什么弊端？"></a>这样做有什么弊端？</h2><ul>
<li>我们要给每一个要Hook的方法额外新加一个方法，方法的参数个数是一样的。</li>
<li>如果每个被Hook的方法内部的实现逻辑都一样，那么就需要在每个新添加的方法中调用这段实现逻辑。</li>
<li>我们新加的代码是在被Hook方法之前还是之后调用的呢？</li>
<li>我们能放将这个新加的方法转化为一个Block呢？这样代码会更紧凑，逻辑更清晰。</li>
<li>如果这个方法转化为Block，那么如何将这个Block替换掉原来的方法实现Swizzle呢？怎样在合适的时候调用这个block呢？</li>
</ul>
<p>带着这些问题我们来看Aspects是如何实现的。</p>
<h2 id="主要的实现思路"><a href="#主要的实现思路" class="headerlink" title="主要的实现思路"></a>主要的实现思路</h2><ol>
<li>使用和原方法相同参数不同方法名的方法，替换被hook的方法，这样系统在找不到这个方法的时候就会走到<code>forwardInvocation:</code>。</li>
<li>使用<code>__ASPECTS_ARE_BEING_CALLED__</code>替换掉系统的<code>forwardInvocation:</code>。 </li>
<li>给类增加<code>AspectsForwardInvocationSelectorName</code>方法，它的实现是原来的<code>forwardInvocation:</code>的IMP。</li>
<li>当要hook的方法被调用时，系统会调用<code>forwardInvocation:</code>方法。由于这个方法也被替换掉了，所以会调用<code>__ASPECTS_ARE_BEING_CALLED__</code>。</li>
<li><code>__ASPECTS_ARE_BEING_CALLED__</code>内部，先调用被hook方法之前的block,再调用替换被hook方法的block，以及没有替换的实现，最后调用被hook方法之之后的block。</li>
<li>如果hook出错，则再调用原来的<code>AspectsForwardInvocationSelectorName</code>的方法。</li>
</ol>
<h2 id="Aspects-m包含的内部类及分类"><a href="#Aspects-m包含的内部类及分类" class="headerlink" title="Aspects.m包含的内部类及分类"></a><code>Aspects.m</code>包含的内部类及分类</h2><ul>
<li><strong>AspectInfo</strong>:存储被hook方法的信息。</li>
<li><strong>AspectIdentifier</strong>:记录每一次Aspect的信息。</li>
<li><strong>AspectsContainer</strong>:某个类或者某个对象所有被hook方法的集合。</li>
<li><strong>AspectTracker</strong>:对所有hook方法的操作（增加或者减少）。</li>
<li><strong>NSInvocation (Aspects)</strong>:获取NSInvocation的参数。</li>
<li><strong>NSObject (Aspects)</strong>:框架的主要分类，定义公共接口。</li>
</ul>
<p>各类之间的关系如图：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-4268aad7e1e7cd89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/510" alt="Aspect框架各类之间的结构"></p>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>公共方法主要调用：<code>aspect_add</code>方法，该方法内部主要调用三个方法</p>
<ol>
<li><code>AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector);</code>获取该方法对应的<code>AspectsContainer</code>。</li>
</ol>
<ul>
<li>将要hook的方法转化为aliasSelector。</li>
<li>取得关联的AspectsContainer，如果没有，怎设置关联的AspectsContainer；</li>
</ul>
<ol start="2">
<li><code>identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];</code>,将调用的参数封装成AspectIdentifier。</li>
</ol>
<ul>
<li>通过：<code>aspect_blockMethodSignature</code>取的block对应的<code>NSMethodSignature</code>,</li>
<li>创建<code>AspectIdentifier</code>并且返回</li>
</ul>
<ol start="3">
<li><code>aspect_prepareClassAndHookSelector(self, selector, error);</code>，准备工作及hook方法。</li>
</ol>
<ul>
<li>aspect_hookClass，内部调用<code>aspect_swizzleForwardInvocation</code>，将系统的<code>forwardInvocation:</code> 替换为<code>__ASPECTS_ARE_BEING_CALLED__</code>。</li>
<li>在改方法内部分别调用被hook方法之前，替换被hook方法，被hook方法之后的方法。 </li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Before hooks.  </span></span><br><span class="line">aspect_invoke(classContainer.beforeAspects, info);</span><br><span class="line">aspect_invoke(objectContainer.beforeAspects, info);</span><br><span class="line"><span class="comment">// Instead hooks.</span></span><br><span class="line"><span class="built_in">BOOL</span> respondsToAlias = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">if</span> (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;</span><br><span class="line">aspect_invoke(classContainer.insteadAspects, info);</span><br><span class="line">aspect_invoke(objectContainer.insteadAspects, info);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">Class klass = object_getClass(invocation.target);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123;</span><br><span class="line">  [invocation invoke];</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span> (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// After hooks.</span></span><br><span class="line">aspect_invoke(classContainer.afterAspects, info);</span><br><span class="line">aspect_invoke(objectContainer.afterAspects, info);</span><br></pre></td></tr></table></figure>

<p>从中可以看出Aspect重要使用了NSInvocation来避免了不同参数个数的限制，通过将block转换为NSMethodSignature对象，可以实现对原有方法的替换或者Swizzle，然后调用其<code>invoke</code>方法，可以在适当的时机触发这个block，通过标识将block分为，原方法之前，之后，替换原方法等做法。而不必像一般实现方法那样，改变每个新加方法中调用原来方法的位置来实现。</p>
<h2 id="其它Tips"><a href="#其它Tips" class="headerlink" title="其它Tips"></a>其它Tips</h2><ol>
<li>如果某个类只可能被其它一个类用到，那么可以将它们写到一个<code>.m</code>文件中，这是高内聚的一种表现。</li>
<li>类，包括分类的出现，其实是为了更好的组织代码，让代码的功能更清晰易懂。</li>
<li>将一段代码加锁的方式：可以将代码块作为参数，然后对其执行前后加锁，这样做的好处是：如果以后要换锁的类型，那么只要在这个方法中改变就可以了：例如：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> aspect_performLocked(dispatch_block_t block) &#123;</span><br><span class="line"><span class="keyword">static</span> OSSpinLock aspect_lock = OS_SPINLOCK_INIT;</span><br><span class="line">OSSpinLockLock(&amp;aspect_lock);</span><br><span class="line">block();</span><br><span class="line">OSSpinLockUnlock(&amp;aspect_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>可以通过自定义结构体的方式将block转换成NSMethodSignature对象，然后在适当的时候调用。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)invoke;</span><br><span class="line">- (<span class="keyword">void</span>)invokeWithTarget:(<span class="keyword">id</span>)target;</span><br></pre></td></tr></table></figure>

<p> 这两个方法来触发这个block。具体做法请见：AspectBlockRef这个结构体和<code>aspect_blockMethodSignature</code>这个方法。<strong>这里有一个疑问：</strong>根据<a href="https://llvm.org/svn/llvm-project/compiler-rt/tags/Apple/Libcompiler_rt-10/BlocksRuntime/Block_private.h" target="_blank" rel="noopener">苹果官方提供的block定义</a>，其中是没有signature这个字段的:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Revised new layout. */</span></span><br><span class="line"><span class="keyword">struct</span> Block_descriptor &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p> 但是Aspect中的block转化为响应的结构体：<code>AspectBlockRef   layout = (__bridge void *)block;</code>之后就会自动有signature字段，这点不是很理解还望大神指教。</p>
<ol start="5">
<li>给定一个对象，和这个对象的SEL，如果参数非常多，使用<code>performSelector:withObject:</code>这种方式不太合适，这时可以借鉴YYKit中的<code>NSObject+YYAdd</code>里面的方法，如果这时有NSInvocation对象，那么可以直接调用<code>objc_msgSend(self, SEL, invocation)</code>这种方式来实现。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="击水湘江">
            
              <p class="site-author-name" itemprop="name">击水湘江</p>
              <p class="site-description motion-element" itemprop="description">努力让明天的自己爱上今天的自己！</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">57</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">击水湘江</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
