<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.3">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT">


<meta name="description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:type" content="website">
<meta property="og:title" content="击水湘江">
<meta property="og:url" content="https://mikefighting.github.io/page/6/index.html">
<meta property="og:site_name" content="击水湘江">
<meta property="og:description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="击水湘江">
<meta name="twitter:description" content="努力让明天的自己爱上今天的自己！">






  <link rel="canonical" href="https://mikefighting.github.io/page/6/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>击水湘江</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">击水湘江</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Born To Fight!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2016/06/07/thingking-in-track-using-runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/07/thingking-in-track-using-runtime/" itemprop="url">RunTime应用实例--关于埋点的思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-07T11:35:00+08:00">2016-06-07</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>埋点是现在很多App中都需要用到的，这个问题可能每个人都能处理，但是怎样来减少埋点所带来的侵入性，怎样用更加简洁的方式来处理埋点问题，怎样减少误埋，如果上线了发现少埋了怎么办？下面是本文讨论的重点（<a href="https://github.com/MikeFighting/LogByRunTime" target="_blank" rel="noopener">本文Demo已上传GitHub，可以下载讨论</a>）:</p>
<ul>
<li>什么是埋点？埋点的作用是什么？</li>
<li>常规的处理方式是怎样的？</li>
<li>我们可以怎样优化？</li>
<li>怎样使用RunTime对其进行优化？</li>
<li>在实践中遇到了什么问题以及解决方案？</li>
<li>最理想的埋点是什么样的？</li>
<li>其中可能存在的问题是什么？</li>
</ul>
<p>接下来将对其一一做以说明:</p>
<h2 id="什么是埋点？埋点的作用是什么？"><a href="#什么是埋点？埋点的作用是什么？" class="headerlink" title="什么是埋点？埋点的作用是什么？"></a>什么是埋点？埋点的作用是什么？</h2><p>其实埋点也叫日志上报，其实就是根据需求上报一系列关于用户行为的数据，比如：用户点击了哪个按钮，用户浏览了哪个网站，用户在某个页面停留了多久等数据。这些数据对于运营来说很有用，他们可以用来分析某个功能开发的是不是合理，是不是因为某个地方的不合理而到导致了转化率的下降，从而对我们的App进行相应的改进，我们来看下某个第三方平台提供的埋点实例。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-01e20264d3596c3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="埋点统计字段定义"><br>上图中说明了，某个时间对应的事件ID,以及针对这个事件需要关联的字段。下面是后台系统对某个埋点所做的数据统计:<br><img src="http://upload-images.jianshu.io/upload_images/1513759-4630c1435e321dbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="后台系统对埋点的数据分析"></p>
<p>这样我们就可以详细的分析出用户对于App的反馈，从而及时的修改我们的产品。</p>
<h2 id="常规的埋点的做法是怎样的？"><a href="#常规的埋点的做法是怎样的？" class="headerlink" title="常规的埋点的做法是怎样的？"></a>常规的埋点的做法是怎样的？</h2><p>其实很简单，我们就在相应的事件里面加入相关的代码，给服务器上报数据不就得了。如下所示:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个一个按钮的响应事件</span></span><br><span class="line">- (<span class="keyword">void</span>)someButtonAction:(<span class="built_in">UIButton</span> *)someButton&#123;</span><br><span class="line"><span class="comment">// 该按钮需要处理的业务</span></span><br><span class="line">[<span class="keyword">self</span> upDateSomthing]</span><br><span class="line"><span class="comment">// 开始埋点</span></span><br><span class="line"><span class="comment">// eid:事件id，sa:用户id, cI:当前时间</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *upLoadDic = @&#123;<span class="string">@"eid"</span>:<span class="string">@"311"</span>,<span class="string">@"sa"</span>:<span class="string">@"706976487532177"</span>,<span class="string">@"cI"</span>:<span class="string">@"2016-6-4 12:11:34"</span>&#125;;</span><br><span class="line">[ZHUpLoadManager upLoadWithDic:upLoadDic];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一个埋点问题就解决了，单同时却隐藏着很多问题:1.这样每点击一个一下按钮就请求一次网络会不会出现性能问题？2.如果这样频繁的数据上报会不会消耗更多的用户流量？3.这样的代码能经受住需求的变更吗？比如字段变了，或者你把<code>cI</code>看错了，应该是<code>cl</code>。4.这样的代码会不会造成难以测试？5.这样的频繁上报会不会增加服务器端的压力？6.代码整洁吗？……(<strong>程序员的一个好习惯是:这个代码能否经受住需求的变更。</strong>)</p>
<h2 id="我们可以怎样优化？"><a href="#我们可以怎样优化？" class="headerlink" title="我们可以怎样优化？"></a>我们可以怎样优化？</h2><ol>
<li>首先我们可以用一个类，来专门处理这些需要上报的埋点的字段，将这些字段作为常量,例如:</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LogManager.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kLogEventKey;   <span class="comment">//事件id</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kLogUserIdKey;  <span class="comment">//用户id</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kLogOperationInterval;  <span class="comment">//操作时间</span></span><br><span class="line"><span class="comment">// LogManager.m</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> kLogEventKey   = <span class="string">@"co"</span>; <span class="comment">//事件id</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> kLogUserIdKey  = <span class="string">@"sa"</span>; <span class="comment">//用户id</span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> kLogOperationInterval  = <span class="string">@"cq"</span>; <span class="comment">//操作时间</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对于用户id，当前时间，用户手机型号，手机品牌，等等与用户所在页面无关的内容，可以用统一的一个类进行处理，将其作为这个类的一个属性，使用<code>getter</code>方法将其相应的数值返回即可(对于恒定不变的可以使用懒加载)。</li>
<li>这样的数据传输策略是有问题的，每次点击都上报，可能一个面需要上报的地方很多，这就会造成很大的性能问题，我们可以<strong>先将需要上传的数据缓存起来，然后缓存够50条数据上报一次，或者每隔5分钟上报一次</strong>;</li>
<li>为了节省流量我们可以，1）将数据压缩之后再上报,<a href="http://www.jianshu.com/p/7016ffdbe97d" target="_blank" rel="noopener">可以参考我的另一篇文章</a>；2）和服务端商量，用尽可能短的字段，如:<code>cityName = @&quot;北京&quot;;</code>变为<code>cn = @&quot;北京&quot;;</code>3)尽量不要上传的频率过高，如第三点。</li>
<li>如何解决代码的整洁，易于测试的问题？请看下面。</li>
</ol>
<h2 id="怎样使用RunTime来进行优化？"><a href="#怎样使用RunTime来进行优化？" class="headerlink" title="怎样使用RunTime来进行优化？"></a>怎样使用RunTime来进行优化？</h2><p>我么能不能利用RunTime来给每一个Button的响应事件中添加一段代码，利用这段代码来进行埋点上报呢？或者进一步来说我们能不能给所有继承自UIControl的对象都添加这样一段代码呢？这样我们不是可以捕获所有的用户事件了吗？(其实答案是否定的，看第五条);这时我们可以利用Mehod Swizzle,或者叫<code>方法注入</code>,或者叫<code>hook</code>住了某个方法，听着挺玄乎，其实就是RunTime的一个API,这个API能够交换两个方法的实现。通过这个API,我们可以这样实现方法注入。如下图所示:<br><img src="http://upload-images.jianshu.io/upload_images/1513759-4e30c9b337c4c891.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法注入的实现过程"><br>那么我们点击按钮系统会不会给每个按钮都执行一个统一的方法？然后我们往这个方法中嵌入响应的代码片段就可以了。答案是肯定的。我们可以往</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendAction:(SEL)action to:(<span class="keyword">nullable</span> <span class="keyword">id</span>)target forEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>

<p>这个方法里面嵌入相应的代码片段。我们可以这样:1.将互换方法实现的的这个方法放到一个工具类中，因为我们可能不止一处要用到这种方法。2.我们给UIControl添加一个Category,然后在里面调用这个工具类然后实现所插入的代码片段。这里我们既然可以得到<code>target</code>还有<code>action</code>,那么很多情况下我们就可以唯一确定这个埋点了，那么我们怎样从这么多的埋点中选出这个这个埋点呢？<strong>我们其实可以用字典和数组结合的方式将这些方法的target和方法的参数一一存起来，然后在嵌入的方法内部获取其对应的方法，以及其相应的，这个事先配置好的字典和数组的结合放在哪里比较合适呢？plist。</strong>下面就以最简单的形式展示这种思路:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工具类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZHSwizzleTool</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)zhSwizzleWithClass:(Class)processedClass originalSelector:(SEL)originSelector swizzleSelector:(SEL)swizzlSelector;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZHSwizzleTool</span></span></span><br><span class="line"> +(<span class="keyword">void</span>)zhSwizzleWithClass:(Class)processedClass originalSelector:(SEL)originSelector swizzleSelector:(SEL)swizzlSelector&#123;</span><br><span class="line"></span><br><span class="line">    Method originMethod = class_getInstanceMethod(processedClass, originSelector);</span><br><span class="line">    Method swizzleMethod = class_getInstanceMethod(processedClass, swizzlSelector);</span><br><span class="line">    <span class="built_in">BOOL</span> didAddMethod = class_addMethod(processedClass, originSelector, method_getImplementation(swizzleMethod), method_getTypeEncoding(swizzleMethod));</span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">    class_replaceMethod(processedClass, swizzlSelector, method_getImplementation(originMethod), method_getTypeEncoding(originMethod));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        method_exchangeImplementations(originMethod, swizzleMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIControl</span> (<span class="title">ZHSwizzle</span>)</span></span><br><span class="line">+(<span class="keyword">void</span>)load&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">SEL originSEL = <span class="keyword">@selector</span>(sendAction:to:forEvent:);</span><br><span class="line">SEL swizzleSEL = <span class="keyword">@selector</span>(sendSwizzleAction:to:forEvent:);</span><br><span class="line"></span><br><span class="line">[ZHSwizzleTool zhSwizzleWithClass:[<span class="keyword">self</span> <span class="keyword">class</span>]originalSelector:originSEL swizzleSelector:swizzleSEL];</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"> - (<span class="keyword">void</span>)sendSwizzleAction:(SEL)action to:(<span class="keyword">id</span>)target   forEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里调用的是原来的系统方法</span></span><br><span class="line">[<span class="keyword">self</span> sendSwizzleAction:action to:target forEvent:event];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *selectorName = <span class="built_in">NSStringFromSelector</span>(action);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个plist中存储的数据格式是这样的:@&#123;@"someViewController":@"selector0":@[para0,para1,para2],@"selector1":@[para0,para1]]&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *pathString = [[<span class="built_in">NSBundle</span> mainBundle]pathForResource:<span class="string">@"ZHLogInfo"</span> ofType:<span class="string">@"plist"</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *plistDic = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:pathString];</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 获取Target的名字</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *controllerDic = plistDic[<span class="built_in">NSStringFromClass</span>([target <span class="keyword">class</span>])];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 获取这个方法对应的参数列表</span></span><br><span class="line"><span class="built_in">NSArray</span> *parameterArray = controllerDic[selectorName];</span><br><span class="line"><span class="comment">//3. 实例化数据中心</span></span><br><span class="line">ZHLogDataCenter *logCenter = [[ZHLogDataCenter alloc]init];</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *logInfoDic = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *parameter <span class="keyword">in</span> parameterArray) &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *getSelector = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,parameter];</span><br><span class="line">SEL getSeletor = <span class="built_in">NSSelectorFromString</span>(getSelector);</span><br><span class="line"><span class="comment">//4. 从数据中心中获取相应的数据</span></span><br><span class="line"><span class="keyword">id</span> value =  [logCenter performSelector:getSeletor withObject:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//5.获取成功则将其存入需要上传的字典</span></span><br><span class="line"><span class="keyword">if</span> (value)</span><br><span class="line">[logInfoDic setObject:value forKey:parameter];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//6.将这个字典存入埋点管理类，其会将其存入缓存并等待上传</span></span><br><span class="line">[ZHLogCenter zhLogWithInforDictionary:logInfoDic];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p> 下面是这个代码中用到的Plist中的配置:<br><img src="http://upload-images.jianshu.io/upload_images/1513759-3c28e14477b58263.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="埋点相关字段的plist配置"></p>
<h2 id="在实践中遇到了什么问题以及解决方案？"><a href="#在实践中遇到了什么问题以及解决方案？" class="headerlink" title="在实践中遇到了什么问题以及解决方案？"></a>在实践中遇到了什么问题以及解决方案？</h2><ol>
<li>并不是所有的事件都是有继承自UIControl的控件来发出的，比如：手势，点击Cell。</li>
<li>并不是所有的按钮点击了之后就立马需要埋点上传？可能在按钮的响应方法中经过了层层的<code>if(){  } else{  }</code>最后才需要埋点。</li>
<li>和事件所在类无关的埋点数据可以同意从<code>ZHLogDataCenter</code>这个类中中取，那么如果这个数据是和所在类有关呢？</li>
<li>对于代理方法该怎样处理？</li>
<li>如果很多个按钮对应着一个事件该怎样处理？</li>
<li>项目中事件的处理方法不尽相同，方法的参数个数不一样，并且方法的返回值也不一样，如何对他们进行统一的处理?</li>
</ol>
<p>下面我们来一一解决这些问题。</p>
<p><strong>问题1</strong>：对于不是来自UIControl的子类发出的事件，我们一样是可以进行hooK，只不过方法有所不同。我们在UIControl的分类中写了一段嵌入的代码，确实hook住了系统UIButton的点击事件，是<strong>因为UIButton自身会调用UIControl的这个方法。但是对于点击事件，这个是我们自己写的一个方法，它的父类<code>UIViewController</code>中是没有的，所以在执行我们自己点击事件的方法时UIViewController分类中要嵌入的方法是不会被调用的，这时候怎么办，我们可以动态的给我们自己要hook的ViewController动态的添加一个方法，然后就可以hook了</strong>（这一点不太好理解）。具体的添加方法，可以参考本文的实例代码。</p>
<p><strong>问题2</strong>：对于是否上传和具体的业务逻辑相关的情况，我们可以用方法所在类的一个属性值进行标记，这个属性写在<code>.m</code>文件中即可(KVC可以获取.m文件中的属性值。)，我们先执行要hook那个类的方法，然后根据<code>plist</code>中配置的相关标记进行相应的处理（这里的属性值其实也是不必要的，我么可以根据类名和方法名字符串的哈希生成唯一的key，然后利用runtime自动关联到这个类的<code>mf_condition</code>属性上，这个属性是一个字典其key就是刚才生成的，value就是运行完这个方法之后得到的值，然后这个值再跟plist中的配置做以比较）。</p>
<p><strong>问题3</strong>：对于和事件所在类有紧密关联的埋点数据，比如某个页面对应的产品ID,比如某个页面点击了cell，之后这个cell对应的model的ID。这个时候我们可以参考方法2，添加一个属性，用一个属性值来存储这些这些需要上传的具体数据。</p>
<p><strong>问题4</strong>：代理方法和手势的处理也是一样的，既然一个类实现了某个代理方法，那么其<code>[someInstance respondsToSelector:someSelector]</code>所返回的BOOL值应该是YES的，然后其它的就和手势的处理是一样的了。</p>
<p><strong>问题5</strong>：对于很多按钮对应一个响应事件的情况，我们可以利用RunTime动态的给按钮添加一个属性，比如:buttonIdentifier,这样我们就可以在plist中进行相应的配置，以进行相应的埋点处理。</p>
<p><strong>问题6</strong>：这个问题其实就是hook住所有的方法，然后给他们添加同一个代码段的问题，这时候我们可以使用<code>Aspects</code>这个第三方框架：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">  withOptions:(AspectOptions)options</span><br><span class="line">   usingBlock:(<span class="keyword">id</span>)block</span><br><span class="line">error:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line"><span class="keyword">return</span> aspect_add((<span class="keyword">id</span>)<span class="keyword">self</span>, selector, options, block, error);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>调用这个接口，因为在<code>UIViewController</code>的分类中调用这个接口的对象不一样，并且我们根据<code>plist</code>中的配置hook的selector不一样，然而最后执行的block却是一样的，这就很好的解决了问题。</p>
<h2 id="最理想的埋点是什么样的？"><a href="#最理想的埋点是什么样的？" class="headerlink" title="最理想的埋点是什么样的？"></a>最理想的埋点是什么样的？</h2><p>最理想的埋点是动态的，就是PM给我们说需要哪些埋点，然后服务器给我们发一个类似与上文中提到的<code>plist</code>一样的文件，或者一个<code>json</code>,我们存到本地，如果这些埋点没有更新，我们就从本地中读取相应的文件，做相应的埋点，如果有更新，我们重新从服务器获取最新的需要埋的点，然后进行相应埋点。这样就解决了少埋，或者埋点不恰当，需要添加埋点的问题。</p>
<h2 id="其中可能存在的问题是什么？"><a href="#其中可能存在的问题是什么？" class="headerlink" title="其中可能存在的问题是什么？"></a>其中可能存在的问题是什么？</h2><p>当然这里面也有其难以处理的问题，比如我们使用了一个第三方控件，这个第三方控件的事件回调不是用delegate实现的，而是用block实现的，并且这个埋点和具体的业务逻辑有关系，那么这种方法就难以处理了。 如果很多事件的逻辑处理放到了block中进行，那么也将造难以处理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2016/06/01/internationalization-for-ios/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/01/internationalization-for-ios/" itemprop="url">iOS中的国际化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-01T08:05:00+08:00">2016-06-01</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>IOS中，如果系统的语言或者地区变化了，我们怎样让App中显示的语言, 日期，数字，货币单位的格式随着变化呢？下面将介绍IOS中简单的国际化的方法：</p>
<p>在GitHub上下载一个<a href="https://github.com/MikeFighting/Bilingual" target="_blank" rel="noopener">需要国际化的工程:</a><br>打开这个工程你可以当看到如下的一个界面：</p>
<img src="http://upload-images.jianshu.io/upload_images/1513759-5f34f732ca292932.png" width="320" heigt="568" style="display:block;margin:0 auto">

<p>然后点开<code>StoryBoard</code>，你会发现里面的控件都非常简单。为了国际话，我们需要往项目中再添加一门语言。添加语言的方式是，<code>Project---&gt;Info---&gt;Localizations</code>点击”+”来添加相应语言，这里我们选择Chinese(simplified)简体中文。然后将弹出的对话框中的LaunchScreen.strings和main.storyBoard都勾选了。这样我们的基本工作就完成了，下面正式开始:</p>
<h2 id="创建-strings文件"><a href="#创建-strings文件" class="headerlink" title="创建.strings文件"></a>创建.strings文件</h2><p>创建<code>.strings</code>文件，点击command + N 新建文件，在Resouce中选择Strings File文件，命名为Localizable，这样系统就会在不同语言环境下选择不同的.strings文件进行加载，显示不同的语言。</p>
<h2 id="处理Localizable-strings"><a href="#处理Localizable-strings" class="headerlink" title="处理Localizable.strings"></a>处理Localizable.strings</h2><p>点击<code>Localizable.strings</code>文件，点击右侧的Localization按钮，然后选择需要本地化的语言，选择汉语，然后再次点击Localizable.strings，你会发现右侧的Localizattion下面多了几个选择语言的选项，Base,English,Chinese(simplified)选中English，然后就会发现又多了一个.strings文件。</p>
<h2 id="配置-string文件"><a href="#配置-string文件" class="headerlink" title="配置.string文件"></a>配置.string文件</h2><p>对不同的.string文件配置不同的Value值，在.string中配置的格式是”KEY” = “VALUE”;,  注意最后的分号。我们在localizable.strings(English)中加上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"I write %@ lines every day."</span> = <span class="string">"I write %@ lines every day."</span>;</span><br><span class="line"><span class="string">"Do you like coding ?"</span> = <span class="string">"Do you like coding ?"</span>;</span><br></pre></td></tr></table></figure>

<p>在Localizable.strings(Chinese simplified)中添加</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"I write %@ lines every day."</span> = <span class="string">"我每天写%@行代码。"</span>;</span><br><span class="line"><span class="string">"Do you like coding ?"</span> = <span class="string">"你喜欢编程吗？"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在ViewController.m中改写相应的加载方法将原来的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_viewControllerNumLabel.text = @<span class="string">"I write 1000000000 lines every day."</span>;</span><br><span class="line">[_viewControllerLikeButotn setTitle:@<span class="string">"Do you like coding ?"</span> forState:UIControlStateNormal];</span><br></pre></td></tr></table></figure>

<p>替换为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_viewControllerNumLabel.text = [NSString stringWithFormat:NSLocalizedString(@<span class="string">"I write %@ lines every day."</span>, nil),@1000000000];</span><br><span class="line">[_viewControllerLikeButotn setTitle:NSLocalizedString(@<span class="string">"Do you like coding ?"</span>, nil) forState:UIControlStateNormal];</span><br></pre></td></tr></table></figure>

<p>这时候将系统的语言设置成简体中文，<code>General -&gt; International -&gt; Language -&gt; Chinese</code>，然后再重新运行App，你会发现变其中的一个Label和一个Button上的文字改变了。</p>
<h2 id="图片的处理"><a href="#图片的处理" class="headerlink" title="图片的处理"></a>图片的处理</h2><p>修改不同的图片。这时你会发现，有些时候，我们的图片上会有文字，这些文字是不能用代码改变的，所以这时要加载不同的图片，利用步骤4中的方法，我们给图片名用一个Key来表示，然后将不同的图片名作为value写在不同的.strings文件中，我们在English中加入：</p>
<p><code>&quot;imageName&quot; = &quot;english&quot;;</code><br>我们在Chinese中加入：<code>&quot;imageName&quot; = &quot;chinese&quot;;</code><br>其中english和chinese都是图片的文字，然后在ViewControlelr中添加如下代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_viewControllerImageView.image = [UIImage imageNamed:NSLocalizedString(@<span class="string">"imageName"</span>,nil)];</span><br></pre></td></tr></table></figure>

<p>这时，修改相应的语言就将会出现不同的图片。</p>
<h2 id="处理StoryBoard"><a href="#处理StoryBoard" class="headerlink" title="处理StoryBoard"></a>处理StoryBoard</h2><p>修改没有被引出的控件的显示。点击Main.StoryBoard,你会发现下面有一个Main.strings(Chinese Simplified)文件，这时将里面有关Lable的代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Class = <span class="string">"UILabel"</span>; text = <span class="string">"Hello I am a Lable"</span>; ObjectID = <span class="string">"zki-n6-dit"</span>; */</span><br><span class="line"><span class="string">"zki-n6-dit.text"</span> = <span class="string">"Hello I am a Lable"</span>;</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Class = <span class="string">"UILabel"</span>; text = <span class="string">"Hello I am a Lable"</span>; ObjectID = <span class="string">"zki-n6-dit"</span>; */</span><br><span class="line"><span class="string">"zki-n6-dit.text"</span> = <span class="string">"您好，我是一个Label"</span>;</span><br></pre></td></tr></table></figure>

<p>再次运行代码，你会发现这个时候没有用代码修改的Lable显示的内容也变了。</p>
<h2 id="数字的处理"><a href="#数字的处理" class="headerlink" title="数字的处理"></a>数字的处理</h2><p>还有一个细节问题，数字的格式，运行App时候你会发现原来显示的格式是1000000000，但是我国用的数字表示方式应该是1,000,000,000，西班牙用的数字表示方式是:1.000.000.000,这个怎么国际化呢？这个时候需要在ViewController中添加如下代码:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSNumberFormatter *numberFormatter = [NSNumberFormatter new];</span><br><span class="line">numberFormatter.numberStyle =NSNumberFormatterDecimalStyle;</span><br><span class="line">NSString *numberString = [numberFormatter stringFromNumber:@1000000000];</span><br><span class="line">_viewControllerNumLabel.text = [NSString stringWithFormat:NSLocalizedString(@<span class="string">"I write %@ lines every day."</span>, nil),numberString];</span><br></pre></td></tr></table></figure>

<p>这里利用NSNumberFormatter来进行对数字格式的转化,这里需要注意，再运行App的时候需要将相应的地区也设置成相应的  General -&gt; International -&gt; Region Format -&gt; China</p>
<h2 id="App显示国际化"><a href="#App显示国际化" class="headerlink" title="App显示国际化"></a>App显示国际化</h2><p>如何让App显示的名字也国际化？这时需要添加一个plist文件InfoPlist.strings，然后将这个文件进行Localizable，在生成的相应的english和chinese中添加需要显示的App的名字，如：在Chinese的文件中添加:”CFBundleDisplayName” = “双语者”,重新运行App就会发现App的名字也随着语言的改变也改变了，最后App国际化的结果为:</p>
<img src="http://upload-images.jianshu.io/upload_images/1513759-8391f5cf97d6771b.png" width="320" height="568" style="display:block; margin:0 auto">

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2016/05/31/swift-closures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/31/swift-closures/" itemprop="url">Swift学习Tip之Closures</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-31T06:39:00+08:00">2016-05-31</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="闭包简介"><a href="#闭包简介" class="headerlink" title="闭包简介"></a>闭包简介</h2><p>什么是<code>Closures</code>？    <code>Closures</code>也就是我们常说的闭包，闭包是一个具有函数功能的代码块，它类似于OC中的<code>Block</code>,它能够在它被定义的上下文中，被常量或者变量所捕捉和存储。也就是是说把常量和变量<code>Closing</code>(包)住了，这也是<code>Closures</code>的由来。全局函数和嵌套函数(<code>Global and nested functions</code>)是闭包的一种特例，闭包有一下三种形式:</p>
<ul>
<li>全局函数是有名称但是不会捕获任何数值得闭包。</li>
<li>嵌套函数是有名称并且可以从它们的封闭的函数体内部捕获数值的闭包。</li>
<li>闭包表达式是用轻量级的语言所书写，并且能够从它们所在的上下文中获取数值的一种没有名称的closures。</li>
</ul>
<p>由于Swift本身对闭包做了很多的优化，这使得闭包的使用更加的简单明了，这些优化包括:</p>
<ul>
<li>从上下文中推断出参数类型和返回值类型</li>
<li>在单一表达的闭包(<code>single-expression</code>)中隐含返回值</li>
<li>简化参数名</li>
<li>尾随闭包语法</li>
</ul>
<h2 id="闭包的基本语法"><a href="#闭包的基本语法" class="headerlink" title="闭包的基本语法"></a>闭包的基本语法</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//闭包表达式的类型和函数的类型是一样的，都是参数加上返回值,但是闭包后面有一个in, 这个关键字来告诉编译器，闭包的参数和返回值已经定义完了，下面是闭包执行语句了。</span></span><br><span class="line">&#123;</span><br><span class="line">    (参数) -&gt; 返回值类型 <span class="keyword">in</span></span><br><span class="line">    执行语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面说明闭包的基本用法:</p>
<ul>
<li>闭包的完整写法:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 闭包的完整写法</span></span><br><span class="line">let sayHiToSomeBody:(String) -&gt; Void = &#123;</span><br><span class="line">        (name: String) -&gt; Void <span class="keyword">in</span></span><br><span class="line">        print(<span class="string">"Hi \(name)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sayHiToSomeBody(<span class="string">"Mike"</span>)</span><br><span class="line">    <span class="comment">// Print: Hi Mike</span></span><br></pre></td></tr></table></figure>

<ul>
<li>没有返回值得闭包</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于这个闭包没有返回值，所以Void可以省略</span></span><br><span class="line">let sayHiToSomeBodyWithoutReturnValue:(String) -&gt; Void = &#123;</span><br><span class="line">    (name: String) <span class="keyword">in</span></span><br><span class="line">    print(<span class="string">"Hi \(name)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayHiToSomeBodyWithoutReturnValue(<span class="string">"Jimme"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>没有参数没有返回值得闭包</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数没有返回值的写法</span></span><br><span class="line"><span class="keyword">let</span> sayHiToSomeBodyWithoutParaAndReturnValue:() -&gt;<span class="type">Void</span> = &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Hi Wallace"</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayHiToSomeBodyWithoutParaAndReturnValue() </span><br><span class="line"><span class="comment">// Print: Hi Wallace</span></span><br></pre></td></tr></table></figure>

<ul>
<li>闭包做为一个参数</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 闭包做为一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionToRunClosureAsParam</span><span class="params">(someClosure:<span class="params">()</span></span></span> -&gt; ()) -&gt;<span class="type">String</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"run before the closure"</span>)</span><br><span class="line">        someClosure()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I ran the closure"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(functionToRunClosureAsParam(&#123;<span class="built_in">print</span>(<span class="string">"try it now"</span>)&#125;))</span><br><span class="line">    <span class="comment">// Print:</span></span><br><span class="line">    <span class="comment">// run before the closure</span></span><br><span class="line">    <span class="comment">// try it now</span></span><br><span class="line">    <span class="comment">// I ran the closure</span></span><br></pre></td></tr></table></figure>

<ul>
<li>闭包做为函数的返回值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 闭包做为函数的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeFunctionWithClosureToReturn</span><span class="params">(somePara:String)</span></span> -&gt;() -&gt; ()&#123; </span><br><span class="line">       <span class="keyword">let</span> resultClosure = &#123; <span class="built_in">print</span>(<span class="string">"\(somePara)"</span>)&#125;</span><br><span class="line">       <span class="keyword">return</span> resultClosure</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">let</span> yellSomeString = makeFunctionWithClosureToReturn(<span class="string">"I Love Swift"</span>)</span><br><span class="line">      yellSomeString()</span><br><span class="line">    <span class="comment">// Print: I Love Swift</span></span><br></pre></td></tr></table></figure>

<ul>
<li>捕获值，（在闭包内部捕获闭包所在的上下文(<code>surrounding context</code>)的变量）</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 捕获值(这里也是一个以闭包做为返回值的函数)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFuncWithClosureReturn</span><span class="params">(forIncrement amount: Int)</span></span> -&gt; () -&gt;<span class="type">Int</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> runningTotal = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 这个闭包是没有参数，只有返回值，这个返回值是由someFuncWithClosureReturn()的参数，和内部的变量</span></span><br><span class="line">    <span class="keyword">let</span> incrementer:()-&gt;<span class="type">Int</span> = &#123;</span><br><span class="line">        runningTotal += amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            函数其实也是闭包的一种，所以可以这样写</span></span><br><span class="line">    <span class="comment">//            func incrementer() -&gt;Int &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//                runningTotal += amount;</span></span><br><span class="line">    <span class="comment">//                return runningTotal</span></span><br><span class="line">    <span class="comment">//            &#125;</span></span><br><span class="line">    <span class="keyword">return</span> incrementer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> incrementByTen = someFuncWithClosureReturn(forIncrement: <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(incrementByTen()) <span class="comment">// Print 10</span></span><br><span class="line"><span class="built_in">print</span>(incrementByTen()) <span class="comment">// Print 20</span></span><br><span class="line"><span class="built_in">print</span>(incrementByTen()) <span class="comment">// Print 30</span></span><br></pre></td></tr></table></figure>

<ul>
<li>尾随闭包<code>Trailing Closures</code>:如果闭包是函数的最后一个参数，并且闭包比较长，这个时候可以在()的后面写一个{}来做为闭包。上文提到的functionToRunClosureAsParam()就是这样一个例子，所以我们可以使用尾随闭包来简化函数的调用。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//闭包做为函数的最后一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionToRunClosureAsParam</span><span class="params">(someClosure:<span class="params">()</span></span></span> -&gt; ()) -&gt;<span class="type">String</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"run before the closure"</span>)</span><br><span class="line">someClosure()</span><br><span class="line"><span class="keyword">return</span> <span class="string">"I ran the closure"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里将闭包提出了()</span></span><br><span class="line"><span class="comment">// 而不是上文中的:print(functionToRunClosureAsParam(&#123;print("try it now")&#125;))</span></span><br><span class="line"><span class="built_in">print</span>(functionToRunClosureAsParam()&#123;<span class="built_in">print</span>(<span class="string">"Try it now "</span>)&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="闭包的高级用法"><a href="#闭包的高级用法" class="headerlink" title="闭包的高级用法"></a>闭包的高级用法</h2><ul>
<li><code>Noescape Closures</code>:非逃逸型闭包,如果闭包是函数的一个参数，那么这个闭包只能在函数内部使用；<code>Escape Closures</code>:逃逸型闭包,当闭包做为函数的一个参数的时候，有时候在函数已经执行完，并且已经返回，但是这之后才调用闭包，这种闭包就称为逃逸闭包（Escaping Closure),逃逸型闭包可以用在异步操作。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非逃逸型闭包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithNoescapeClosure</span><span class="params">(@noescape closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逃逸型闭包，如果强制将其改变为非逃逸型的将会报错，因为非逃逸型只能在函数内部使用，而这个闭包却被存在了函数之外的数组中，所以必须是逃逸型的，如果强制改为非逃逸型的，会报错</span></span><br><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] = [] <span class="comment">// 这是一个存贮闭包的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHandler: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非逃逸型的闭包如果使用了全局变量，那么可以省去self,下面举例说明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x = <span class="number">100</span> &#125;</span><br><span class="line">        someFunctionWithNoescapeClosure &#123; x = <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// prints "200"</span></span><br><span class="line"></span><br><span class="line">completionHandlers.first?() <span class="comment">// 这个时候取出数组中存放的已经逃逸的闭包，然后执行它，就会让 instanc.x变为100</span></span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// prints "100”</span></span><br></pre></td></tr></table></figure>

<p>下面在举个例子说明<code>Noescape Closures</code>的用法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 再比如非逃逸型闭包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(@noescape code: <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    <span class="comment">/* 我们可以这样做 */</span></span><br><span class="line">    <span class="comment">// 仅调用它</span></span><br><span class="line">    code()</span><br><span class="line">    <span class="comment">// 做为非逃逸型参数传递给另外一个函数</span></span><br><span class="line">    doItMore(code)</span><br><span class="line">    <span class="comment">// 在另外一个非逃逸的函数中捕获智</span></span><br><span class="line">doItMore &#123;</span><br><span class="line">        code()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 我们不可以做 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 将它赋值为一个需要可逃逸闭包参数的函数</span></span><br><span class="line"><span class="comment">dispatch_async(dispatch_get_main_queue(), code)</span></span><br><span class="line"><span class="comment">        // 存储它</span></span><br><span class="line"><span class="comment">        let _code:() -&gt; () = code</span></span><br><span class="line"><span class="comment">        // 在另一个可逃逸的闭包</span></span><br><span class="line"><span class="comment">        let __code = &#123; code() &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doItMore</span><span class="params">(@noescape code: <span class="params">()</span></span></span> -&gt; ()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Autoclosures</code>自动闭包:如果函数中的一个闭包参数被<code>@autoclosures</code>修饰，那么这个函数在被调用的时候可以省去花括号,注意如果一个闭包被autoClosures修饰的时候默认是noescape型的，所以在不能用到异步处理中，这是只需要在将<code>@autoclosure</code>变为<code>@autoclosure(escaping)</code>就可以了</li>
</ul>
<p>下面举例说明:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is ["Ewa", "Barry", "Daniella"]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveCustomer</span><span class="params">(@autoclosure customerProvider: <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Now serving \(customerProvider())!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">serveCustomer(customersInLine.removeAtIndex(<span class="number">0</span>)) <span class="comment">// 这个时候回省去&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再比如一个以闭包做为参数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(@autoclosure pred: <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> pred() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"It's true"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">2</span> &gt; <span class="number">1</span>) <span class="comment">// 如果不加@autoclosure，我们不得不f(&#123;2 &gt; 1&#125;)</span></span><br><span class="line"><span class="comment">// It's true</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2016/05/19/msg-forwarding-exception/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/19/msg-forwarding-exception/" itemprop="url">iOS消应用实例--异常处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-19T10:16:00+08:00">2016-05-19</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h3><p>最近发现了一个在项目中常用的异常处理工具NullSafe，分析了它的实现原理，不小心发现了一个小Bug，现将其分享出来，<a href="https://github.com/MikeFighting/NSNullHandler" target="_blank" rel="noopener">关于这篇文章的Demo已经上传至GitHub</a>，看完如有收获，欢迎Star，如有疑问欢迎issue，大家一起学习。在IOS开发中我们可能会遇到下面的情景:服务器给我们返回得某个字段是null,比如<code>someValue:null</code>，这个时候我们利用第三方工具转化之后会得到<code>someValue = &lt;null&gt;</code>,这个时候如果我们判断这个<code>someValue</code>的类型，会看到其为:NSNull。那么问题来了，如果这个someValue是要给控件赋值，比如:<code>someLabel.text = someVlaue</code>，这个时候相当于<code>someLabel.text = nil</code>,显然，是不会有问题的。<strong>但是有时候我们可能会给这个貌似是NSString的对象发送消息(因为我们在Model里定义了NSString * someValue)</strong>，比如:<code>[someValue length]</code>。这个时候由于<code>null</code>这个对象没有这个方法,也就是是说：<code>null 这个对象不能处理这个消息</code>所有就会Crash，让程序闪退。那么我们怎样处理来避免这种Crash呢？我们怎样处理这个消息呢？</p>
<h3 id="OC的消息转发流程"><a href="#OC的消息转发流程" class="headerlink" title="OC的消息转发流程"></a>OC的消息转发流程</h3><p>首先我们来看一下<code>NSObject.h</code>中我们不常用到的几个方法,以及它们的含义:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否发现了这个method，如果发了，将其添加给该对象，并且返回YES,如果没有返回NO。</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel; </span><br><span class="line"><span class="comment">// 同上类似</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel;</span><br><span class="line"><span class="comment">// 这个方法来指定未被识别的消息首先要指向得对象</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector;  </span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)instanceMethodSignatureForSelector:(SEL)aSelector;</span><br><span class="line"><span class="comment">// 遍历一个类的实例方法得到这个消息得NSMethodSignature，这个返回值包含了对这个method相关的描述，如果这个method不能找到，那么返回nil.</span></span><br><span class="line"><span class="comment">//遍历一个类的实例方法或者类方法来得到这个消息的NSMethodSignature</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line"><span class="comment">// NSObject的子类可以覆盖这个方法来讲消息转发给其它的对象。当一个对象发送一个消息，但是这个对象不能响应这个消息，那么RunTime会给这个对象一个来转发这个消息的机会。</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br></pre></td></tr></table></figure>

<p>这个对象通过创建一个NSInvocation对象作为参数来调用这个forwardInvocation方法，然后改对象会调用这个方法来将消息转发给其它对象。<br>这个NSInvocation对象其实是有上一个方法methodSignatureForSelector中返回的NSMethodSignature来得到的，所以在重写这个方法之前我们必须重写methodSignatureForSelector方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个类的实例是否具有相应这个selector的能力，也就是说这个类有没有这样一个方法</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)instancesRespondToSelector:(SEL)aSelector;</span><br><span class="line"><span class="comment">// 遍历一个类的实例方法或者类方法 得到这个方法的IMP(函数指针，指向这个方法的具体实现)</span></span><br><span class="line">- (IMP)methodForSelector:(SEL)aSelector;</span><br><span class="line"><span class="comment">// 遍历一个类的实例方法列表，得到这个方法IMP</span></span><br><span class="line">+ (IMP)instanceMethodForSelector:(SEL)aSelector;</span><br><span class="line"><span class="comment">// 如果一个对象收到了一个消息，但是它不能处理这个消息，并且这个消息没有被转发，那么系统将会调用这个方法。</span></span><br><span class="line">- (<span class="keyword">void</span>)doesNotRecognizeSelector:(SEL)aSelector;</span><br><span class="line">同时这个方法会引发一个<span class="built_in">NSInvalidArgumentException</span>，并且引发error.</span><br></pre></td></tr></table></figure>

<p>那么这几个方法，在系统中是怎样的调用顺序呢？我们来看下图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-2e5449addfd826bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IOS中消息处理得流程"></p>
<p>从中可以看出在给一个对象发送消息的时候，如果对象没有对应的IML，那么会调用对象所属类的</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br></pre></td></tr></table></figure>

<p>方法，然后看对于这个SEL对象是否可以执行，如果不可以执行则会调用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>

<p>来找到一个对象处理这个方法(我们可以返回一个对象，这个对象可以处理这个方法)，如果这个方法返回的是<code>nil</code>，那么会调用这个对象的</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>

<p>这个方法，如果这方法调用之后，仍然没有找到对应的<code>NSMethodSignature</code>，那么会调用:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doesNotRecognizeSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>

<p>这个方法，并且抛出异常，如果这个时候返回了一个有效的<code>NSMethodSignature</code>，那么会调用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br></pre></td></tr></table></figure>

<p>到这里消息的处理结束。</p>
<p>那么对于NSNull这个对象，我们如何让它处理一个其自身不能处理的消息呢？这时候，我们肯定会想到，将这个消息传递给其它可以处理的对象。那么问题来了：我们如何能找到这样一个对象呢？这时候我们想到了<strong>RunTime</strong>,利用<code>RunTime</code>的<code>objc_getClassList</code>方法，我们可以获取整个项目中注册得所有类（只要在项目中添加了这个类文件，无论这个类是否被使用），<strong>这个时候我们可以过滤掉用不到的父类，以节约循环得次数，因为子类已经继承了父类的方法，所以具有处理这个消息得能力</strong>，之后首先利用上文提到的<code>instancesRespondToSelector</code>来判断这个类是否可以响应这个消息，如果可以响应，那么可以利用上文提到的<code>instanceMethodSignatureForSelector</code>来得到这个<code>NSMethodSignature</code>,并且返回。通过上述分析，系统会调用这个<code>forwardInvocation</code>,这个是时候我们调用NSInvocation的<code>invokeWithTarget</code>这个方法来将这个消息发送给nil,在OC中向一个nil发送任何消息都不会引起程序Crash,至此一个由于服务器返回数据异常而导致的Crash被解决了。</p>
<blockquote>
<p>这显然增加了系统的容错能力，在项目调试阶段，可能由于数据不完善，所以可以利用这个方法来规避Crash,但是在数据基本完善之后，我们可以去掉这种方法以便我们在程序Crash的时候，及时提醒后台人员来完善数据。</p>
</blockquote>
<h3 id="NullSafe的实现详解"><a href="#NullSafe的实现详解" class="headerlink" title="NullSafe的实现详解"></a>NullSafe的实现详解</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">@implementation</span> <span class="title">NSNull</span> (<span class="title">NullSafe</span>)</span></span><br><span class="line"></span><br><span class="line"> - (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">@synchronized</span>([<span class="keyword">self</span> <span class="keyword">class</span>])</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">// 寻找 method signature</span></span><br><span class="line">  <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:selector];</span><br><span class="line">  <span class="keyword">if</span> (!signature)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">//改消息不能被NSNull处理，所以我们要寻找其它的可以处理的类  </span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableSet</span> *classList = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *signatureCache = <span class="literal">nil</span>;<span class="comment">// 缓存这个找到的 method signature，以便下次寻找</span></span><br><span class="line"><span class="keyword">if</span> (signatureCache == <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line"> classList = [[<span class="built_in">NSMutableSet</span> alloc] init];</span><br><span class="line"> signatureCache = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取项目中的所有类，并且去除有子类的类。</span></span><br><span class="line"> <span class="comment">// objc_getClassList：这个方法会将所有的类缓存，以及这些类的数量。我们需要提供一块足够大得缓存来存储它们，所以我们必须调用这个函数两次。第一次来判断buffer的大小，第二次来填充这个buffer。</span></span><br><span class="line"> <span class="keyword">int</span> numClasses = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>); </span><br><span class="line"> Class *classes = (Class *)malloc(<span class="keyword">sizeof</span>(Class) * (<span class="keyword">unsigned</span> <span class="keyword">long</span>)numClasses);</span><br><span class="line"> numClasses = objc_getClassList(classes, numClasses);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">NSMutableSet</span> *excluded = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  </span><br><span class="line">  Class someClass = classes[i];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 筛选出其中含有子类的类，加入:excluded中</span></span><br><span class="line">  Class superclass = class_getSuperclass(someClass);</span><br><span class="line">  <span class="keyword">while</span> (superclass)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 如果父类是NSObject,则跳出循环，并且加入classList</span></span><br><span class="line"><span class="keyword">if</span> (superclass == [<span class="built_in">NSObject</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line"> <span class="comment">// 将系统中用到的所有类都加到了ClassList中</span></span><br><span class="line"> [classList addObject:someClass];</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类不是NSObject,将其父类添加到excluded</span></span><br><span class="line">[excluded addObject:superclass];</span><br><span class="line"> superclass = class_getSuperclass(superclass);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 删除所有含有子类的类</span></span><br><span class="line"> <span class="keyword">for</span> (Class someClass <span class="keyword">in</span> excluded)</span><br><span class="line"> &#123;</span><br><span class="line">  [classList removeObject:someClass];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//释放内存</span></span><br><span class="line"> free(classes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先检测缓存是否有这个实现</span></span><br><span class="line"><span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(selector);</span><br><span class="line">signature = signatureCache[selectorString];</span><br><span class="line"><span class="keyword">if</span> (!signature)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//找到方法的实现</span></span><br><span class="line"> <span class="keyword">for</span> (Class someClass <span class="keyword">in</span> classList)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">if</span> ([someClass instancesRespondToSelector:selector])</span><br><span class="line">  &#123;</span><br><span class="line">signature = [someClass instanceMethodSignatureForSelector:selector];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//缓存以备下次使用</span></span><br><span class="line"> signatureCache[selectorString] = signature ?: [<span class="built_in">NSNull</span> null];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ([signature isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]])</span><br><span class="line">&#123;</span><br><span class="line"> signature = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> signature;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span>  *)invocation &#123;</span><br><span class="line"> <span class="comment">// 让nil来处理这个invocation</span></span><br><span class="line"> [invocation invokeWithTarget:<span class="literal">nil</span>];</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在原文中作者是这样写的:  [excluded addObject:NSStringFromClass(superclass)];<br><strong>这样ClassList中存放的是Class，而excluded中存放的确是String,这样就不能过滤掉不必要的类</strong>。所以，我将其改为了: [excluded addObject:superclass];<em>不知道作者是不是考虑了其他问题，也可能是由于其大意。</em></p>
<h3 id="延伸阅读："><a href="#延伸阅读：" class="headerlink" title="延伸阅读："></a>延伸阅读：</h3><ol>
<li><a href="http://www.jianshu.com/p/8774e192d8db" target="_blank" rel="noopener">http://www.jianshu.com/p/8774e192d8db</a></li>
<li><a href="http://www.cocoabuilder.com/archive/cocoa/48930-objc-getclasslist-pointers-and-nsarray.html" target="_blank" rel="noopener">http://www.cocoabuilder.com/archive/cocoa/48930-objc-getclasslist-pointers-and-nsarray.html</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="noopener">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2016/05/18/ios-tips-sum0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/18/ios-tips-sum0/" itemprop="url">iOS开发Tips</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-05-18T07:41:00+08:00">2016-05-18</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在iOS开发中，应用大多以XML或JSON的格式传输数据的，并且XML和JSON通常会比较大，所以客户端需要用下载或者上传的时间会较长，这时我们可以考虑压缩数据，Gzip是一种比zip更优的压缩技术，它可以将数据压缩到60%，因此对客户端和服务器端来说就更加的轻量级了。总结下Gzip的优点:</p>
<ol>
<li>降低客户端对数据的下载时间和上传时间</li>
<li>节省流量**。那么在IOS中我们如何使用gZip呢？</li>
</ol>
<p>我们可以使用：<code>LFCGzipUtility</code>这个框架来进行，我们可以先讲字符串转换成NSData，然后压缩成NSData:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> * gZipData = [LFCGzipUtility gzipData:[needCompressedString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]];</span><br></pre></td></tr></table></figure>

<p>解压缩和这个几乎一样，这里就不再赘述</p>
<p>1.iOS开发中，由于版本经常更新，为适配新的版本我们通常要相应的更新Xcode,通常我们可以在iTunes上直接更新，但是由于网速的问题，一般会非常之慢。这时候我们可能会选择在网上找一个安装包，由于前段时间在网上看到有些Xcode有病毒，所以最好用官方的版本。这里提供了官方的下载地址，要比在iTunes上更新快很多的。打开这个网址:<br><a href="https://developer.apple.com/downloads/" target="_blank" rel="noopener">https://developer.apple.com/downloads/</a></p>
<p>详细得步骤如下所示:<br><img src="http://upload-images.jianshu.io/upload_images/1513759-c25cec0f43eb304e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="官网下载各种版本Xcode详解"></p>
<p>2.当我们的Xcode升级了，这时候很多第三方插件都不可用了，这时候怎么办？</p>
<p>这个时候我们需要给<code>plist</code>文件加一个键值对就可以了,找到plist止呕中的** DVTPlugInCompatibilityUUIDs**新加一个item,这个item的value值可以在终端中执行：<code>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID</code>来进行获取，如下图所示:<br><img src="http://upload-images.jianshu.io/upload_images/1513759-28104bc507eea0f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="给plist添加DVTPlugInCompatibilityUUIDs"></p>
<p>3.要发布新版本了，忽然发现<strong>This certificate has an invalid issuer</strong>，这时候我们一般这么办：</p>
<ul>
<li>下载这个证书,并且双击安装到Keychain。<br><a href="https://developer.apple.com/certificationauthority/AppleWWDRCA.cer" target="_blank" rel="noopener">https://developer.apple.com/certificationauthority/AppleWWDRCA.cer</a></li>
<li>在KeyChain中选中”View”-&gt;”Show Expired Certificates”</li>
<li>确保”Certificates”是选中的。如下图所示:</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-2f3de7433172f4ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选中Certificates"></p>
<ul>
<li>从”login”和’’system”选项中，移除和苹果开发者相关的证书即可。<a href="http://stackoverflow.com/questions/35390072/this-certificate-has-an-invalid-issuer-apple-push-services" target="_blank" rel="noopener">该问题在Stackoverflow中有详细的说明。</a></li>
</ul>
<p>GitHub上LFCGzipUtility的下载地址:<br><a href="https://github.com/levinXiao/LFCGzipUtility" target="_blank" rel="noopener">https://github.com/levinXiao/LFCGzipUtility</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2016/04/25/understanding-run-loop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/25/understanding-run-loop/" itemprop="url">实例化讲解RunLoop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-25T18:42:00+08:00">2016-04-25</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前看过很多有关RunLoop的文章，其中要么是主要介绍RunLoop的基本概念，要么是主要讲解RunLoop的底层原理，很少用真正的实例来讲解RunLoop的，这其中有大部分原因是由于大家在项目中很少能用到RunLoop吧。基于这种原因，本文中将用很少的篇幅来对基础内容做以介绍，然后主要利用实例来加深大家对RunLoop的理解,<a href="https://github.com/MikeFighting/PractiseRunLoop" target="_blank" rel="noopener">本文中的代码已经上传GitHub</a>,大家可以下载查看，有问题欢迎Issue我。本文主要分为如下几个部分:</p>
<ul>
<li>RunLoop的基础知识</li>
<li>初识RunLoop，如何让RunLoop进驻线程</li>
<li>深入理解Perform Selector</li>
<li>一直”活着”的后台线程</li>
<li>深入理解NSTimer</li>
<li>让两个后台线程有依赖性的一种方式</li>
<li>NSURLConnetction的内部实现</li>
<li>AFNetWorking中是如何使用RunLoop的?</li>
<li>其它:利用GCD实现定时器功能</li>
<li>延伸阅读</li>
</ul>
<hr>
<h2 id="RunLoop的基本概念"><a href="#RunLoop的基本概念" class="headerlink" title="RunLoop的基本概念"></a>RunLoop的基本概念</h2><p>什么是<code>RunLoop</code>？提到RunLoop，我们一般都会提到线程，这是为什么呢？先来看下<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="noopener">官方对<code>RunLoop</code>的定义</a>:<code>RunLoop</code>系统中和线程相关的基础架构的组成部分(<strong>和线程相关</strong>)，一个RunLoop是一个事件处理环，系统利用这个事件处理环来安排事务，协调输入的各种事件。<code>RunLoop</code>的目的是让你的线程在有工作的时候忙碌，没有工作的时候休眠(<strong>和线程相关</strong>)。可能这样说你还不是特别清楚<code>RunLoop</code>究竟是用来做什么的，打个比方来说明:我们把线程比作一辆跑车，把这辆跑车的主人比作<code>RunLoop</code>，那么在没有’主人’的时候，这个跑车的生命是<strong>直线型</strong>的，其启动，运行完之后就会废弃(没有人对其进行控制，’撞坏’被收回)，当有了<code>RunLoop</code>这个主人之后，‘线程’这辆跑车的生命就有了保障，这个时候，跑车的生命是<strong>环形</strong>的，并且在主人有比赛任务的时候就会被<code>RunLoop</code>这个主人所唤醒,在没有任务的时候可以休眠(在IOS中，开启线程是很消耗性能的，开启主线程要消耗1M内存，开启一个后台线程需要消耗512k内存，我们应当在线程没有任务的时候休眠，来释放所占用的资源，以便CPU进行更加高效的工作)，这样可以增加跑车的效率,也就是说<code>RunLoop</code>是为线程所服务的。这个例子有点不是很贴切，<strong>线程和RunLoop之间是以键值对的形式一一对应的，其中key是thread，value是runLoop(这点可以从<a href="http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz" target="_blank" rel="noopener">苹果公开的源码中看出来</a>)</strong>，<strong>其实RunLoop是管理线程的一种机制，这种机制不仅在IOS上有，在Node.js中的EventLoop，Android中的Looper，都有类似的模式</strong>。刚才所说的比赛任务就是<strong>唤醒跑车这个线程</strong>的一个<code>source</code>;<code>RunLoop Mode</code>就是，一系列输入的<code>source</code>,<code>timer</code>以及<code>observer</code>，<code>RunLoop Mode</code>包含以下几种: <code>NSDefaultRunLoopMode</code>,<code>NSEventTrackingRunLoopMode</code>,<code>UIInitializationRunLoopMode</code>,<code>NSRunLoopCommonModes</code>,<code>NSConnectionReplyMode</code>,<code>NSModalPanelRunLoopMode</code>,至于这些mode各自的含义，读者可自己查询，网上不乏这类资源;</p>
<h2 id="初识RunLoop，如何让RunLoop进驻线程"><a href="#初识RunLoop，如何让RunLoop进驻线程" class="headerlink" title="初识RunLoop，如何让RunLoop进驻线程"></a>初识RunLoop，如何让RunLoop进驻线程</h2><p>我们在主线程中添加如下代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"while begin"</span>);</span><br><span class="line"><span class="comment">// the thread be blocked here</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">[runLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line"><span class="comment">// this will not be executed</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"while end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们可以看到主线程在执行完<code>[runLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</code> 之后被阻塞而没有执行下面的<code>NSLog(@&quot;while end&quot;)</code>;同时，我们利用GCD，将这段代码放到一个后台线程中:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"while begin"</span>);</span><br><span class="line"><span class="built_in">NSRunLoop</span> *subRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">[subRunLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"while end"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个时候我们发现这个while循环会一直在执行；这是为什么呢?我们先将这两个<code>RunLoop</code>分别打印出来:<br><img src="http://upload-images.jianshu.io/upload_images/1513759-e6f4d26e1ae55d20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440" alt="主线程的RunLoop"><br>由于这个日志比较长，我就只截取了上面的一部分。<br>我们再看我们新建的子线程中的<code>RunLoop</code>,打印出来之后:<br><img src="http://upload-images.jianshu.io/upload_images/1513759-fa79f186a6e43047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440" alt="backGroundThreadRunLoop.png"><br>从中可以看出来：我们新建的线程中:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sources0 = (null),</span><br><span class="line">sources1 = (null),</span><br><span class="line">observers = (null),</span><br><span class="line">timers = (null),</span><br></pre></td></tr></table></figure>

<p> 我们看到虽然有Mode，但是我们没有给它<code>soures,observer,timer</code>，其实Mode中的这些<code>source,observer,timer</code>，统称为这个<code>Mode</code>的<code>item</code>，如果一个<code>Mode</code>中一个<code>item</code>都没有，则这个RunLoop会直接退出，不进入<strong>循环</strong>(其实线程之所以可以一直存在就是由于RunLoop将其带入了这个循环中)。下面我们为这个RunLoop添加个source:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">NSPort</span> *macPort = [<span class="built_in">NSPort</span> port];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"while begin"</span>);</span><br><span class="line"><span class="built_in">NSRunLoop</span> *subRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">[subRunLoop addPort:macPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">[subRunLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"while end"</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,subRunLoop);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样我们可以看到能够实现了和主线程中相同的效果，线程在这个地方暂停了，为什么呢？我们明天让RunLoop在<code>distantFuture</code>之前都一直run的啊？相信大家已经猜出出来了。这个时候线程被<code>RunLoop</code>带到‘坑’里去了，这个‘坑’就是一个循环，在循环中这个线程可以在没有任务的时候休眠，在有任务的时候被唤醒；当然我们只用一个<code>while(1)</code>也可以让这个线程一直存在，但是这个线程会一直在唤醒状态，及时它没有任务也一直处于运转状态，这对于CPU来说是非常不高效的。<br><strong>小结:我们的RunLoop要想工作，必须要让它存在一个Item(source,observer或者timer)，主线程之所以能够一直存在，并且随时准备被唤醒就是应为系统为其添加了很多Item</strong></p>
<h2 id="深入理解Perform-Selector"><a href="#深入理解Perform-Selector" class="headerlink" title="深入理解Perform Selector"></a>深入理解Perform Selector</h2><p>我们先在主线程中使用下<code>performselector</code>:<br></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tryPerformSelectorOnMianThread&#123;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(mainThreadMethod) withObject:<span class="literal">nil</span>]; &#125;</span><br><span class="line">- (<span class="keyword">void</span>)mainThreadMethod&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"execute %s"</span>,__func__);</span><br><span class="line"><span class="comment">// print: execute -[ViewController mainThreadMethod]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这样我们在ViewDidLoad中调用<code>tryPerformSelectorOnMianThread</code>,就会立即执行，并且输出:print: execute -[ViewController mainThreadMethod];<br> 和上面的例子一样，我们使用GCD,让这个方法在后台线程中执行：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)tryPerformSelectorOnBackGroundThread &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(backGroundThread) onThread:[<span class="built_in">NSThread</span> currentThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)backGroundThread&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%u"</span>,[<span class="built_in">NSThread</span> isMainThread]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"execute %s"</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，我们调用<code>tryPerformSelectorOnBackGroundThread</code>这个方法，我们会发现，下面的<code>backGroundThread</code>不会被调用，这是什么原因呢？<br>这是因为，在调用<code>performSelector:onThread: withObject: waitUntilDone</code>的时候，系统会给我们创建一个Timer的<strong>source</strong>，加到对应的RunLoop上去，然而这个时候我们没有<code>RunLoop</code>,如果我们加上RunLoop:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)tryPerformSelectorOnBackGroundThread&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(backGroundThread) onThread:[<span class="built_in">NSThread</span> currentThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    [runLoop run];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时就会发现我们的方法正常被调用了。那么为什么主线程中的<code>perfom selector</code>却能够正常调用呢？通过上面的例子相信你已经猜到了，主线程的RunLoop是一直存在的，所以我们在主线程中执行的时候，无需再添加RunLoop。从Apple的文档中我们也可以得到验证：</p>
<blockquote>
<p>Each request to perform a selector is queued on the target thread’s run loop and the requests are then processed sequentially in the order in which they were received. 每个执行perform selector的请求都以队列的形式被放到目标线程的run loop中。然后目标线程会根据进入run loop的顺序来一一执行。<br>当perform selector在后台线程中执行的时候，这个线程必须有一个开启的runLoop</p>
</blockquote>
<h2 id="一直”活着”的后台线程"><a href="#一直”活着”的后台线程" class="headerlink" title="一直”活着”的后台线程"></a>一直”活着”的后台线程</h2><p>现在有这样一个需求，每点击一下屏幕，让子线程做一个任务,然后大家一般会想到这样的方式:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSThread</span> *myThread;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)alwaysLiveBackGoundThread &#123;</span><br><span class="line">    <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(myThreadRun) object:<span class="string">@"etund"</span>];</span><br><span class="line">    <span class="keyword">self</span>.myThread = thread;</span><br><span class="line">    [<span class="keyword">self</span>.myThread start];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)myThreadRun &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"my thread run"</span>);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="keyword">self</span>.myThread);</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(doBackGroundThreadWork) onThread:<span class="keyword">self</span>.myThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)doBackGroundThreadWork&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"do some work %s"</span>,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这个方法中，我们利用一个强引用来获取了后台线程中的thread,然后在点击屏幕的时候，在这个线程上执行<code>doBackGroundThreadWork</code>这个方法，此时我们可以看到，在<code>touchesBegin</code>方法中，self.myThread是存在的，但是这是为是什么呢？这就要从线程的五大状态来说明了:<strong>新建状态、就绪状态、运行状态、阻塞状态、死亡状态</strong>，这个时候尽管内存中还有线程，但是这个线程在执行完任务之后已经死亡了，经过上面的论述，我们应该怎样处理呢？我们可以给这个线程的RunLoop添加一个source，那么这个线程就会检测这个source等待执行，而不至于死亡(<em>有工作的强烈愿望而不死亡</em>):</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)myThreadRun&#123;</span><br><span class="line"></span><br><span class="line"> [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>]; </span><br><span class="line"> [[<span class="built_in">NSRunLoop</span> currentRunLoop] run]</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"my thread run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候再次点击屏幕，我们就会发现，后台线程中执行的任务可以正常进行了。</p>
<blockquote>
<p>正常情况下，后台线程执行完任务之后就处于死亡状态，我们要避免这种情况的发生可以利用RunLoop，并且给它一个Source这样来保证线程依旧还在</p>
</blockquote>
<h2 id="深入理解NSTimer"><a href="#深入理解NSTimer" class="headerlink" title="深入理解NSTimer"></a>深入理解NSTimer</h2><p>我们平时使用NSTimer，一般是在主线程中的，代码大多如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tryTimerOnMainThread&#123;</span><br><span class="line">    <span class="built_in">NSTimer</span> *myTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.5</span> target:<span class="keyword">self</span>   </span><br><span class="line">    selector:<span class="keyword">@selector</span>(timerAction) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    [myTimer fire];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerAction&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"timer action"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候代码按照我们预定的结果运行，如果我们把这个Tiemr放到后台线程中呢?</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"><span class="built_in">NSTimer</span> *myTimer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.5</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerAction) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">[myTimer fire];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个时候我们会发现，这个timer只执行了一次，就停止了。这是为什么呢？通过上面的讲解，想必你已经知道了，<strong>NSTimer,只有注册到RunLoop之后才会生效，这个注册是由系统自动给我们完成的</strong>,既然需要注册到RunLoop,那么我们就需要有一个<code>RunLoop</code>,我们在后台线程中加入如下的代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">[runLoop run];</span><br></pre></td></tr></table></figure>

<p>这样我们就会发现程序正常运行了。在Timer注册到RunLoop之后，RunLoop会为其重复的时间点注册好事件，比如1：10，1：20，1：30这几个时间点。有时候我们会在这个线程中执行一个耗时操作，这个时候RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer，这就造成了误差(Timer有个冗余度属性叫做<code>tolerance</code>,它标明了当前点到后，容许有多少最大误差)，可以在执行一段循环之后调用一个耗时操作，很容易看到timer会有很大的误差，这说明在线程很闲的时候使用NSTiemr是比较傲你准确的，当线程很忙碌时候会有较大的误差。系统还有一个<code>CADisplayLink</code>,也可以实现定时效果，它是一个和屏幕的刷新率一样的定时器。如果在两次屏幕刷新之间执行一个耗时的任务，那其中就会有一个帧被跳过去，造成界面卡顿。另外GCD也可以实现定时器的效果，由于其和RunLoop没有关联，所以有时候使用它会更加的准确，这在<a href="#anchor8">最后会给予说明</a>。</p>
<h2 id="让两个后台线程有依赖性的一种方式"><a href="#让两个后台线程有依赖性的一种方式" class="headerlink" title="让两个后台线程有依赖性的一种方式"></a>让两个后台线程有依赖性的一种方式</h2><p>给两个后台线程添加依赖可能有很多的方式，这里说明一种利用<code>RunLoop</code>实现的方式。原理很简单，我们先让一个线程工作，当工作完成之后唤醒另外的一线程,通过上面对<code>RunLoop</code>的说明，相信大家很容易能够理解这些代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)runLoopAddDependance&#123;</span><br><span class="line"><span class="keyword">self</span>.runLoopThreadDidFinishFlag = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Start a New Run Loop Thread"</span>);</span><br><span class="line"><span class="built_in">NSThread</span> *runLoopThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleRunLoopThreadTask) object:<span class="literal">nil</span>];</span><br><span class="line">[runLoopThread start];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Exit handleRunLoopThreadButtonTouchUpInside"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">while</span> (!_runLoopThreadDidFinishFlag) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.myThread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Begin RunLoop"</span>);</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="built_in">NSPort</span> *myPort = [<span class="built_in">NSPort</span> port];</span><br><span class="line">        [runLoop addPort:myPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"End RunLoop"</span>);</span><br><span class="line">        [<span class="keyword">self</span>.myThread cancel];</span><br><span class="line">        <span class="keyword">self</span>.myThread = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> &#125;</span><br><span class="line">- (<span class="keyword">void</span>)handleRunLoopThreadTask &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Enter Run Loop Thread"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"In Run Loop Thread, count = %ld"</span>, i);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if 0</span></span><br><span class="line"><span class="comment">// 错误示范</span></span><br><span class="line">_runLoopThreadDidFinishFlag = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">// 这个时候并不能执行线程完成之后的任务，因为Run Loop所在的线程并不知道runLoopThreadDidFinishFlag被重新赋值。Run Loop这个时候没有被任务事件源唤醒。</span></span><br><span class="line"><span class="comment">// 正确的做法是使用 "selector"方法唤醒Run Loop。 即如下:</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Exit Normal Thread"</span>);</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(tryOnMyThread) onThread:<span class="keyword">self</span>.myThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line"><span class="comment">// NSLog(@"Exit Run Loop Thread");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NSURLConnection的执行过程"><a href="#NSURLConnection的执行过程" class="headerlink" title="NSURLConnection的执行过程"></a>NSURLConnection的执行过程</h2><p>在使用NSURLConnection时，我们会传入一个Delegate,当我们调用了<code>[connection start]</code>之后，这个Delegate会不停的收到事件的回调。实际上，<strong>start这个函数的内部会获取CurrentRunloop</strong>，然后在其中的DefaultMode中添加4个source。如下图所示，CFMultiplexerSource是负责各种Delegate回调的，CFHTTPCookieStorage是处理各种Cookie的。如下图所示:<br><img src="http://upload-images.jianshu.io/upload_images/1513759-09e30658d91e4b06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="NSURLConnection的执行过程"><br>从中可以看出，当开始网络传输是，我们可以看到NSURLConnection创建了两个新的线程:com.apple.NSURLConnectionLoader和com.apple.CFSocket.private。其中CFSocket是处理底层socket链接的。NSURLConnectionLoader这个线程内部会使用RunLoop来接收底层socket的事件，并通过之前添加的source，来通知(<code>唤醒</code>)上层的Delegate。这样我们就可以理解我们平时封装网络请求时候常见的下面逻辑了:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!_isEndRequest)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"entered run loop"</span>);</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"main finished，task be removed"</span>);</span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line"> &#123;</span><br><span class="line">  _isEndRequest = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就可以解决下面这些疑问了:<br></p>
<ol>
<li>为什么这个While循环不停的执行，还需要使用一个RunLoop? 程序执行一个while循环是不会耗费很大性能的，我们这里的目的是想让子线程在有任务的时候处理任务，没有任务的时候休眠，来节约CPU的开支。</li>
<li>如果没有为RunLoop添加item,那么它就会立即退出，这里的item呢? 其实系统已经给我们默认添加了4个source了。</li>
<li>既然<code>[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</code>让线程在这里停下来，那么为什么这个循环会持续的执行呢？因为这个一直在处理任务，并且接受系统对这个Delegate的回调，也就是这个回调<strong>唤醒</strong>了这个线程，让它在这里循环。</li>
</ol>
<h2 id="AFNetWorking中是如何使用RunLoop的-？"><a href="#AFNetWorking中是如何使用RunLoop的-？" class="headerlink" title="AFNetWorking中是如何使用RunLoop的 ？"></a>AFNetWorking中是如何使用RunLoop的 ？</h2><p>在AFN中AFURLConnectionOperation是基于NSURLConnection构建的，其希望能够在后台线程来接收Delegate的回调。<br>为此AFN创建了一个线程,然后在里面开启了一个RunLoop，然后添加<code>item</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</span><br><span class="line">    <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [runLoop run];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">    _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">    [_networkRequestThread start];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里这个<code>NSMachPort</code>的作用和上文中的一样，就是让线程不至于在很快死亡，然后RunLoop不至于退出(如果要使用这个MachPort的话，调用者需要持有这个NSMachPort，然后在外部线程通过这个port发送信息到这个loop内部,它这里没有这么做)。然后和上面的做法相似，在需要后台执行这个任务的时候，会通过调用:<code>[NSObject performSelector:onThread:..]</code>来将这个任务扔给后台线程的RunLoop中来执行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">[<span class="keyword">self</span>.lock lock];</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line"><span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GCD定时器的实现"><a href="#GCD定时器的实现" class="headerlink" title="GCD定时器的实现"></a>GCD定时器的实现</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)gcdTimer&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the queue</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// creat timer</span></span><br><span class="line"><span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line"><span class="comment">// config the timer (starting time，interval)</span></span><br><span class="line"><span class="comment">// set begining time</span></span><br><span class="line">dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>));</span><br><span class="line"><span class="comment">// set the interval</span></span><br><span class="line">uint64_t interver = (uint64_t)(<span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">dispatch_source_set_timer(<span class="keyword">self</span>.timer, start, interver, <span class="number">0.0</span>);</span><br><span class="line">dispatch_source_set_event_handler(<span class="keyword">self</span>.timer, ^&#123;</span><br><span class="line"><span class="comment">// the tarsk needed to be processed async</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"gcdTimer"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_resume(<span class="keyword">self</span>.timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ol>
<li><a href="http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-%5B%3F%5D-:shi-yao-shi-run-loop%3F/" target="_blank" rel="noopener">http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-%5B%3F%5D-:shi-yao-shi-run-loop%3F/</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1</a></li>
<li><a href="http://www.cocoachina.com/ios/20150601/11970.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20150601/11970.html</a></li>
<li><a href="http://www.jianshu.com/p/de2716807570" target="_blank" rel="noopener">http://www.jianshu.com/p/de2716807570</a></li>
<li><a href="http://blog.csdn.net/enuola/article/details/9163051" target="_blank" rel="noopener">http://blog.csdn.net/enuola/article/details/9163051</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2016/03/17/setting-obs-step-by-step/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/17/setting-obs-step-by-step/" itemprop="url">Mac版OBS设置详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-17T15:27:00+08:00">2016-03-17</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="OBS是什么？"><a href="#OBS是什么？" class="headerlink" title="OBS是什么？"></a>OBS是什么？</h3><p>OBS是目前为止，最好用的直播软件，它支持Windows 7/8/10, Linux并且还支持OS X(Mac电脑的系统)，老外的软件，无广告，全免费，适用于32和64位的各种电脑，所以成为<code>斗鱼</code>，<code>哔哩哔哩</code>等各种直播网站主播的必备品。</p>
<h3 id="怎样使用OBS？"><a href="#怎样使用OBS？" class="headerlink" title="怎样使用OBS？"></a>怎样使用OBS？</h3><ol>
<li>下载安装</li>
</ol>
<p>进入OBS<a href="https://obsproject.com/" target="_blank" rel="noopener">官方网站</a>，然后点击绿色的OSX 10.8+(<strong>或者是其它的版本</strong>)，下载安装，然后你会看到如下界面<img src="http://upload-images.jianshu.io/upload_images/1513759-820e18d263ca116f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OBS主页面"></p>
<ol start="2">
<li>点击设置，进入如下界面</li>
</ol>
<p>(<a href="http://upload-images.jianshu.io/upload_images/1513759-56330d89c8171b75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener">http://upload-images.jianshu.io/upload_images/1513759-56330d89c8171b75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240</a>)</p>
<p>通用中可以设置OBS的语言，点击串流会看到如下界面:<br><img src="http://upload-images.jianshu.io/upload_images/1513759-8a432ea667b0c50a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通用设置">，串流类型选择<strong>自定义流媒体服务器</strong>，下面的<em>URL</em>和<em>流密钥</em>需要根据直播间中的<em>直播信息</em>进行填写，<strong>登陆斗鱼账号，点击用户名—&gt;个人中心—&gt;主播相关—&gt;直播设置—&gt;进入直播房间</strong></p>
<p>然后可以看到下图：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-a6203bd85cd9618f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的直播房间"></p>
<ol start="3">
<li><p>这个时候点击获取推流码，即可看到<em>rtmp地址</em>和<em>直播码</em>，将其填入OBS中串流的设置中。</p>
</li>
<li><p>这个时候OBS的主页面还是黑色的，没有任何的输入，原因是没有给他添加输入源，这是点击<em>场景<em>下面的*</em>+<strong>添加一个场景，点击来源下面的</strong>+*<em>添加一个来源，一般我们会选择</em>视频捕获<em>或者只</em>窗口捕获</em> 视频捕获是直播电脑摄像头录取的视频，窗口捕获是直播电脑上打开的窗口，这里以<em>窗口捕获</em>为例，添加完窗口捕获之后，点击窗口捕获下面的小齿轮:<br><img src="http://upload-images.jianshu.io/upload_images/1513759-4ba24c915b50123d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置窗口"><br>然后选择需要直播的窗口，这个时候可能里面没有我们要直播的窗口，比如Xcode，这时，可能是我们没有打开Xcode,打开Xcode之后，我们再，次打开OBS，让其重新识别一次窗口，这时就可以选择Xcode了，选择完之后，点击确定。</p>
</li>
<li><p>这个时候点击开始串流，并且打开直播房间的开始直播就可以了。</p>
</li>
</ol>
<h3 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h3><p>Mac电脑使用OBS的时候往往会遇到这样一个问题，外界的声音可以录取，但是电脑自身发出的声音，比如音乐，某些网站的声音，是不能直播，这时候我们需要下载一个软件，<a href="http://en.softonic.com/s/soundflower:mac" target="_blank" rel="noopener">soundflower</a>，下载之后，进入系统偏好设置-&gt;声音–&gt;输出，然后选中Multi-Output Device<br><img src="http://upload-images.jianshu.io/upload_images/1513759-62bcf9ab8763b2dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统设置">,然后点击OB中的视频，将音频中的<strong>桌面音频设备设置为Soundflower(2ch)</strong><br><img src="http://upload-images.jianshu.io/upload_images/1513759-99598b6e3d7992c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OBS设置Sondflower"><br>如果噪音太大，这个时候可以点击麦克风下面的齿轮，设置噪音阈值，来对噪音进行过滤。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="击水湘江">
            
              <p class="site-author-name" itemprop="name">击水湘江</p>
              <p class="site-description motion-element" itemprop="description">努力让明天的自己爱上今天的自己！</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">57</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">击水湘江</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
