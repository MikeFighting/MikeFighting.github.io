<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Write the Code,Change the World" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:type" content="website">
<meta property="og:title" content="击水湘江">
<meta property="og:url" content="https://mikefighting.github.io/page/2/index.html">
<meta property="og:site_name" content="击水湘江">
<meta property="og:description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="击水湘江">
<meta name="twitter:description" content="努力让明天的自己爱上今天的自己！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://mikefighting.github.io/page/2/"/>





  <title>击水湘江 - Born To Fight!</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">击水湘江</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Born To Fight!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/09/27/servlet-introduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/27/servlet-introduce/" itemprop="url">Servlet简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-27T22:48:54+08:00">
                2017-09-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="相关资料下载地址"><a href="#相关资料下载地址" class="headerlink" title="相关资料下载地址"></a>相关资料下载地址</h3><p><a href="http://grepcode.com/file/repo1.maven.org/maven2/javax.servlet/servlet-api/2.2/javax/servlet/Servlet.java?av=f" target="_blank" rel="external">http://grepcode.com/file/repo1.maven.org/maven2/javax.servlet/servlet-api/2.2/javax/servlet/Servlet.java?av=f</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/09/10/java-detials/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/java-detials/" itemprop="url">可能被遗漏的Java细节</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-10T16:15:27+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Java中的类型转换"><a href="#Java中的类型转换" class="headerlink" title="Java中的类型转换"></a>Java中的类型转换</h3><h4 id="兼容的自动转换"><a href="#兼容的自动转换" class="headerlink" title="兼容的自动转换"></a>兼容的自动转换</h4><p>在编程中把一种类型的值赋给另一种类型的变量是合法的。如果这两种类型是兼容的，那么Java会自动对其进行类型转换。例如：把int类型的值赋给long类型的变量就可以。然而如果两种类型不兼容，那么就不会发生这种隐式的类型转换。例如，没有将double类型转化为byte类型的定义。这种不兼容的转化只能自己强制进行。<br>满足以下两个条件时，Java会自动给你进行类型转换：</p>
<ul>
<li>这两种类型是兼容的。</li>
<li>目的类型的范围要比源类型的范围大。</li>
</ul>
<p>数字类型，包括整数和浮点类型都是彼此兼容的，但是，数字类型和字符类型（char）或布尔类型（bollean）是不兼容的。</p>
<h4 id="不兼容的强制转换"><a href="#不兼容的强制转换" class="headerlink" title="不兼容的强制转换"></a>不兼容的强制转换</h4><p>虽然自动转换很好，但是它不能满足所有的需求。例如，你需要将一个int类型的变量付给一个byte类型的变量，你就需要使用(target-type)value这种转换了。下面演示将int转换为byte，如果整数超出了byte类型的取值范围，那么它的值将会因为对byte类型的值取%而减少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a;</div><div class="line"><span class="keyword">byte</span> b;</div><div class="line"><span class="comment">// ...</span></div><div class="line">b = (<span class="keyword">byte</span>)a;</div></pre></td></tr></table></figure>
<p>当把浮点数转换为整数类型时会发生一种不同的转换：截断。你知道整数没有小数部分，当你把浮点数转化为整数的时候，其小数部分将会被舍弃。例如，如果将值1.23赋给一个整数，那么其结果是1，0.23被舍弃了。如果浮点数值太而不能适合目标整数类型，那么它的值将会因为对目标类型值域取模而减少。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> <span class="comment">// Demonstrate casts.</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Conversion</span> </span>&#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">       <span class="keyword">byte</span> b;</div><div class="line">       <span class="keyword">int</span> i = <span class="number">257</span>;</div><div class="line">       <span class="keyword">double</span> d = <span class="number">323.142</span>;</div><div class="line">       System.out.println(<span class="string">"\nConversion of int to byte."</span>);</div><div class="line">       b = (<span class="keyword">byte</span>) i;</div><div class="line">       System.out.println(<span class="string">"i and b "</span> + i + <span class="string">" "</span> + b);</div><div class="line">       System.out.println(<span class="string">"\nConversion of double to int."</span>);</div><div class="line">       i = (<span class="keyword">int</span>) d;</div><div class="line">       System.out.println(<span class="string">"d and i "</span> + d + <span class="string">" "</span> + i);</div><div class="line">       System.out.println(<span class="string">"\nConversion of double to byte."</span>);</div><div class="line">       b = (<span class="keyword">byte</span>) d;</div><div class="line">       System.out.println(<span class="string">"d and b "</span> + d + <span class="string">" "</span> + b);</div><div class="line">&#125; &#125;</div></pre></td></tr></table></figure>
<p>该程序的输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Conversion of <span class="keyword">int</span> to <span class="keyword">byte</span>.</div><div class="line">i and b <span class="number">257</span> <span class="number">1</span></div><div class="line">Conversion of <span class="keyword">double</span> to <span class="keyword">int</span>.</div><div class="line">d and i <span class="number">323.142</span> <span class="number">323</span></div><div class="line">Conversion of <span class="keyword">double</span> to <span class="keyword">byte</span>.</div><div class="line">d and b <span class="number">323.142</span> <span class="number">67</span></div></pre></td></tr></table></figure>
<p>当值257被强制转换为byte变量时，其结果是257除以256(256是byte类型的变化范围)的余数。当把变量d转换为int类型时，它的小数部分被舍弃了。当吧变量d转换为byte类型时，它的小数部分被舍弃了，而且它的值减少为256的模，即67。</p>
<h4 id="表达式中的类型提升"><a href="#表达式中的类型提升" class="headerlink" title="表达式中的类型提升"></a>表达式中的类型提升</h4><p>在表达式中，有时候中间值的精度会比较高，它有可能超过任何一个操作数的范围。例如，考虑下面的表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span> a = <span class="number">40</span>;</div><div class="line"><span class="keyword">byte</span> b = <span class="number">50</span>;</div><div class="line"><span class="keyword">byte</span> c = <span class="number">100</span>;</div><div class="line"><span class="keyword">int</span> d = a * b / c;</div></pre></td></tr></table></figure>
<p>其中间结果<code>a*b</code>很容易超出它的任何一个byte型操作数的范围。为了处理这种问题，当分析表达式时，Java会自动提升各个byte或者short型的操作数为int型。这意味着表达式<code>a*b</code>是使用整数而不是字节型来运算的。这样，尽管变量a和b都被指定为byte型，50*40的中间表达式的结果2000是合法的。</p>
<p>自动类型提升很好，但是有时候会引起令人疑惑的编译错误。例如，这个看起来正确的程序却会引起问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span> b = <span class="number">50</span>;</div><div class="line">b = b * <span class="number">2</span>; <span class="comment">// Error! Cannot assign an int to a byte!</span></div></pre></td></tr></table></figure>
<p>这里看上去完全合法，但由于当表达式求值的时候，操作数被自动提升为了int型，所以需要强制转换才可以赋值（但是你必须考虑好溢出的情况）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span> b = <span class="number">50</span>;</div><div class="line">b = (<span class="keyword">byte</span>)(b * <span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>这样就不会有编译器错误了。</p>
<h4 id="类型提升的约定"><a href="#类型提升的约定" class="headerlink" title="类型提升的约定"></a>类型提升的约定</h4><p>除了将byte型和short型提升到int型以外，Java还定义了其它的类型提升规则。如果一个操作数是long型，那么整个表达式将被提升到long型；如果一个操作数是float型，整个表达式将被提升到float型；如果一个操作数是double型，计算结构就是double型。我们用个例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promote</span> </span>&#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">       <span class="keyword">byte</span> b = <span class="number">42</span>;</div><div class="line">       <span class="keyword">char</span> c = <span class="string">'a'</span>;</div><div class="line">       <span class="keyword">short</span> s = <span class="number">1024</span>;</div><div class="line">       <span class="keyword">int</span> i = <span class="number">50000</span>;</div><div class="line">       <span class="keyword">float</span> f = <span class="number">5.67f</span>;</div><div class="line">       <span class="keyword">double</span> d = .<span class="number">1234</span>;</div><div class="line">       <span class="keyword">double</span> result = (f * b) + (i / c) - (d * s);</div><div class="line">       System.out.println((f * b) + <span class="string">" + "</span> + (i / c) + <span class="string">" - "</span> + (d * s));</div><div class="line">       System.out.println(<span class="string">"result = "</span> + result);</div><div class="line">&#125; &#125;</div></pre></td></tr></table></figure>
<p>我们来分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> result = (f * b) + (i / c) - (d * s);</div></pre></td></tr></table></figure>
<p>的类型提升过程，在第一个子表达式<code>f*b</code>中，变量b被 升为float类型，该子表达式的结果当然是float类型。 接下来，在子表达式i/c，中，变量c被 升为int类型，该子表达式的结果当然是int类型。然 后，子表达式<code>d*s</code>中的变量s被 升为double类型，该子表达式的结果当然也是double类型。 最后，考虑三个中间值，float类型，int类型，和double类型。float类型加int类型的结果是float 类型。然后float类型减去 升为double类型的double类型，该表达式的最后结果是double型。</p>
<h3 id="Java中的break"><a href="#Java中的break" class="headerlink" title="Java中的break"></a>Java中的break</h3><p>Java中的break除了可以用来在switch或者循环中终止某个条件或者循环，还可以作为goto语句的一种形式来使用。Java中没有goto语句，因为goto让程序流程变得非结构化，可能让程序难以理解和维护，并且可以阻止某些编译器优化。但是，有些地方使用goto语句有助于流程控制，并且是合法的。例如，从嵌套很深的循环中退出来，goto语句就很有帮助。因此，Java定义了break语句的一种扩展形式来处理这种情况。通过给某个代码块加上标签，那么<strong>其内部的break语句</strong>就可以在某些情况下跳转到该标签。这个代码块不必非要是循环或者switch，它可以是任意的代码块。标签的指定如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Using break as a civilized form of goto.</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Break</span> </span>&#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">       <span class="keyword">boolean</span> t = <span class="keyword">true</span>;</div><div class="line">       first: &#123;</div><div class="line">         second: &#123;</div><div class="line">           third: &#123;</div><div class="line">            System.out.println(<span class="string">"Before the break."</span>);</div><div class="line">            <span class="keyword">if</span>(t) <span class="keyword">break</span> second; <span class="comment">// break out of second block</span></div><div class="line">            System.out.println(<span class="string">"This won't execute"</span>);</div><div class="line">&#125; </div><div class="line">           System.out.println(<span class="string">"This won't execute"</span>);</div><div class="line">         &#125;</div><div class="line">         System.out.println(<span class="string">"This is after second block."</span>);</div><div class="line">       &#125;</div><div class="line">&#125; &#125;</div></pre></td></tr></table></figure>
<p>改程序的输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Before the <span class="built_in">break</span>.</div><div class="line">This is after second block.</div></pre></td></tr></table></figure>
<p>这个示例中有三个嵌套的代码块，每一个都有它自己的标签。break语句使得循环往外层跳转，直接跳过了second标签的的代码块，直接执行了first标签的代码块。</p>
<h3 id="Java中的方法重载"><a href="#Java中的方法重载" class="headerlink" title="Java中的方法重载"></a>Java中的方法重载</h3><p>方法重载就是说如果两个方法有相同的方法名字，但是其参数不同（参数个数不同或者参数类型不同），那么Java会根据调用时候不同的参数类型来匹配不同的方法来调用。然而有时候其类型匹配不是很精确：比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">// Automatic type conversions apply to overloading.</span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">OverloadDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">     System.out.println(<span class="string">"No parameters"</span>);</div><div class="line">    &#125; </div><div class="line">    <span class="comment">// Overload test for two integer parameters. </span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a，<span class="keyword">int</span> b)</span> </span>&#123; </div><div class="line">      System.out.println(<span class="string">"a and b: "</span> + a + <span class="string">" "</span> + b);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// overload test for a double parameter</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</div><div class="line">      System.out.println(<span class="string">"Inside test(double) a: "</span> + a);</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">      OverloadDemo ob = <span class="keyword">new</span> OverloadDemo();</div><div class="line">      <span class="keyword">int</span> i = <span class="number">88</span>;</div><div class="line">      ob.test(); ob.test(<span class="number">10</span>，<span class="number">20</span>); </div><div class="line">      ob.test(i); <span class="comment">// this will invoke test(double)</span></div><div class="line">      ob.test(<span class="number">123.2</span>); <span class="comment">// this will invoke test(double)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">No parameters</div><div class="line">a and b: 10 20</div><div class="line">Inside <span class="built_in">test</span>(double) a: 88</div><div class="line">Inside <span class="built_in">test</span>(double) a: 123.2</div></pre></td></tr></table></figure>
<p>这里，我们的<code>test(i)</code>中i是int型，但是在调用时，我们发现调用<code>test(double)</code>类型，这是因为在调用<code>test(int)</code>型的时候Java找不到相应的类型，所以就将int扩大为了double，然后就调用了<code>test(double)</code>，如果我们这里定义了一个<code>test(int)</code>，那么就会调用这个<code>test(int)</code>而不会将int扩大为double。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>在继承中，super可以用来表示父类，可以调用父类特有的方法。还有一种应用情况是：它可以用来调用父类中被子类所隐藏的属性，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> i; &#125; </div><div class="line">    <span class="comment">// Create a subclass by extending class A.</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> i; <span class="comment">// this i hides the i in A</span></div><div class="line">      B(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</div><div class="line">       <span class="keyword">super</span>.i = a; <span class="comment">// i in A</span></div><div class="line">       i = b; <span class="comment">// i in B</span></div><div class="line">&#125; </div><div class="line">      <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</div><div class="line">       System.out.println(<span class="string">"i in superclass: "</span> + <span class="keyword">super</span>.i);</div><div class="line">       System.out.println(<span class="string">"i in subclass: "</span> + i);</div><div class="line">&#125; &#125; </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UseSuper</span> </span>&#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">       B subOb = <span class="keyword">new</span> B(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">       subOb.show();</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该程序的输出为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i <span class="keyword">in</span> superclass: 1</div><div class="line">i <span class="keyword">in</span> subclass: 2</div></pre></td></tr></table></figure>
<p>尽管B中的实例变量i隐藏了A中的i，使用super就可以访问超类中定义的i。其实， super也可以用来调用超类中被子类隐藏的方法。 </p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在类的层次结构中，构造函数的调用顺序是从父类到子类。并且父类的构造方法的调用要放在子类构造方法的第一行中。如果子类中没有用到super()，那么每个父类默认的或者无参数的构造函数将执行。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Create a super class.</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">      A() &#123;</div><div class="line">       System.out.println(<span class="string">"Inside A's constructor."</span>);</div><div class="line">&#125; &#125; </div><div class="line">    <span class="comment">// Create a subclass by extending class A.</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">      B() &#123;</div><div class="line">       System.out.println(<span class="string">"Inside B's constructor."</span>);</div><div class="line">&#125; &#125; </div><div class="line">    <span class="comment">// Create another subclass by extending B.</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</div><div class="line">      C() &#123;</div><div class="line">       System.out.println(<span class="string">"Inside C's constructor."</span>);</div><div class="line">&#125; &#125; </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CallingCons</span> </span>&#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">C c = <span class="keyword">new</span> C(); &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该程序的输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Inside A’s constructor</div><div class="line">Inside B’s constructor</div><div class="line">Inside C’s constructor</div></pre></td></tr></table></figure>
<p>由此可见，构造函数以派生的顺序被调用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/09/10/chat-computer-science-basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/chat-computer-science-basic/" itemprop="url">计算机基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-10T10:10:40+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>我们先来看一个有趣的例子：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-f48d5ace81b3d0cb.png" alt="溢出128"></p>
<p>在这里我们定义了一个<code>signed char</code>类型的数据，将其赋值为128，然后系统给我们一个警告，意思就是说它隐式地将数值给转换成了<strong>-128</strong>，这究竟是为什么呢？</p>
<p>其实在计算机中数值都是以补码的形式存储的：</p>
<blockquote>
<p>正数的补码是其自身，负数的补码是其对应的正数的反码加1。</p>
</blockquote>
<p>我们先看一下-42在计算机中是如何表示的：<br>它是先将其对象的正数42，0010 1010然后取反1101 0101，然后再加1，得到1101 0110。</p>
<p>我们知道signed char是占八位的。其存储范围是：0000 0000到1111 1111。那么128的补码还是128，其二进制表示为：1000 0000。但是这里有个问题，因为其类型是有符号的，所以最高位是符号位，也就是说这个数不能用来表示128了，那么它表示多少呢？我们就要看看它是谁的补码就是好了。我们先将<code>1000 0000</code>取反，然后的到<code>0111 1111</code>，加一得到<code>1000 0000</code>，再乘以-1,得到-128。如果不太明白，我我们可以将128变大，变成129：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-d236d51fa77178ad.png" alt="溢出129"></p>
<p>129为整数，其补码是其自身，1000 0001，又因为其最高位是符号位，所以其表示的是一个负数，它表示多少呢？先将其取反<code>0111 1110</code>，然后+1得到<code>0111 1111</code>，这时127，最后乘以-1得到-127。</p>
<h3 id="switch语句为什么比if-else快？"><a href="#switch语句为什么比if-else快？" class="headerlink" title="switch语句为什么比if else快？"></a>switch语句为什么比if else快？</h3><p>因为编译器在编译switch语句的时候会检查每个case常量，并且会创建出一个”跳转表”，这个表用来在表达式的基础上选择执行路径，其时间复杂度是O(1)，而if else的时间复杂度是O(n)，所以switch case要比if else快很多。</p>
<h3 id="寄存器是什么？"><a href="#寄存器是什么？" class="headerlink" title="寄存器是什么？"></a>寄存器是什么？</h3><p>寄存器是一种存储信息的硬件，它和内存一样可以用来存储，但是和内存不同的是，它的速度极其快（比RAM的主存要快得多，它还有一些辅助功能，它常常被用做软件和外设之间通信的桥梁，起到缓冲的作用，同时CPU中寄存器速度非常快，这就让经常需要用到的数据放到寄存器中，而不需要每次都从主存中去读取，从而提高了程序的执行速度。软件将信息写入寄存器，然后外设将信息从寄存器中读出去。如果外设有信息需要软件进行处理，那么它也需要先将信息放到寄存器中，然后有软件从中读取。寄存器的主要功能包括：</p>
<ul>
<li>某些功能的配置和初始化，特别是在初始化阶段</li>
<li>缓存存储</li>
<li>不同种类的输入输出</li>
<li>状态报告，比如某个硬件的状态发生了变化</li>
</ul>
<p>常见的寄存器包括：MAR(Memory Address Register)，这个寄存器主要用来存放下一条即将执行的指令，CPU根据MAR中指令的地址取出指令，然后放到MDR(Memory Data Register中，然后CIR(Current Instruction Regitster)将指令从MDR中拷贝一份。MBR(Memory Buffer Register)，用来存放要放入存储器的数据和从存储器中读出的数据。<a href="https://www.youtube.com/watch?time_continue=220&amp;v=TBADs7knuWM" target="_blank" rel="external">相关资料可以参考YouTube</a></p>
<h3 id="CPU为什么需要三级缓存？"><a href="#CPU为什么需要三级缓存？" class="headerlink" title="CPU为什么需要三级缓存？"></a>CPU为什么需要三级缓存？</h3><p>CPU和内存的速度不匹配是计算机领域的一个重要问题，如果内存中采用和CPU中相同型号的寄存器，那么其代价又会太高，并且根据局部性原理，这种需求是没有必要的。存储器的<strong>价格，速度，容量</strong>是人们考虑的主要因素，但是它们之间也存在这制约因素：速度越快，价格就越高；容量越大，价格越高；容量越大，速度越低。根据局部性原理(Principle of Locality)我们的程序中常用的数据又基本都是固定的。所以就在CPU和内存之间采用了三级缓存（它内部存储的）来提高获取数据的速度，如果数据能在L1，L2，L3中找到的话就直接从中取，如果没有再从内存取，如果内存没有，再从外存取，这样就会提高获取数据的速度。<strong>这里要注意每个处理器都有其自己的缓存区，最后他们共享一块内存，这就会造成数据不一致的严重问题。</strong></p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>在多任务执行的时候，上下文切换是指从一个线程或者进程切换到另外一个线程或者进程，这里的上下文是指：<strong>CPU寄存器和程序计数器中的内容。</strong>它的具体内容包含以下三个步骤：</p>
<ol>
<li>挂起当前进程，将当前的CPU状态保存至内存</li>
<li>从内存中获取接下来将要执行进程的上下文，并且将其存入CPU寄存器中</li>
<li>返回程序计数器指定的位置（例如进程被终止的点）并且继续执行进程</li>
</ol>
<p>这里的切换包含进程切换和线程切换两种情况，它们之间的相同点和不同点为：</p>
<h4 id="一、进程切换"><a href="#一、进程切换" class="headerlink" title="一、进程切换"></a>一、进程切换<br></h4><p>虚拟内存空间不能保持相同；调用操作系统内核；寄存器内容的切入切出和内核操作的转移是最消耗性能的；</p>
<h4 id="二、线程切换"><a href="#二、线程切换" class="headerlink" title="二、线程切换"></a>二、线程切换<br></h4><p>虚拟内存空间保持相同；调用操作系统内核；寄存器内容的切入切出和内核操作的转移是最消耗性能的；</p>
<p>这其中还有一个隐含的性能消耗点是：处理器缓存系统的失效。在虚拟内存空间切换的过程中会导致处理器的Translation Lookaside Buffer (TLB) 失效，这会造成很大的内存损耗。造成上下文切换的原因有：进程自动让出其时间片，或者调度器给它分配的时间片到了，或者硬件发生了中断操作，加锁，或者其它的软件操作也会造成上下文切换。上下文切换很消耗大量的CPU时间造成较大的性能损耗。</p>
<h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><p>线程是寄存器的一组状态，这组状态用来规定程序的执行顺序，执行地址，以及下条指令的地址。</p>
<p>参考资料:</p>
<ol>
<li><p><a href="https://stackoverflow.com/questions/5440128/thread-context-switch-vs-process-context-switch" target="_blank" rel="external">线程上下文切换和进程上下文</a></p>
</li>
<li><p><a href="http://www.linfo.org/context_switch.html" target="_blank" rel="external">上下文切换的定义</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/5201852/what-is-a-thread-really" target="_blank" rel="external">线程的定义</a></p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/09/08/chat-uitableView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/chat-uitableView/" itemprop="url">聊聊UITableView</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-08T14:18:29+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>在UITableViewCell展示过一次，第二次展示时会被复用。</strong>，系统自带的UITableview的复用方式，除了减少了内存消耗之外没有任何的好处。这种内存消耗的减少也是以产生一堆Cell复用的时带来的Bug作为代价的。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/09/06/google-the-clean-code-talks-inheritance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/06/google-the-clean-code-talks-inheritance/" itemprop="url">代码整洁之道-继承，多态和测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-06T07:50:00+08:00">
                2017-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="代码整洁的讨论，条件和多态"><a href="#代码整洁的讨论，条件和多态" class="headerlink" title="代码整洁的讨论，条件和多态"></a>代码整洁的讨论，条件和多态</h3><p><img src="http://upload-images.jianshu.io/upload_images/1513759-0ac66a6395d8b9ff.png" alt="Conclusion"></p>
<p>条件和多态是怎样影响测试的？</p>
<ol>
<li>大多数的if可以被多态所取代</li>
</ol>
<p>为什么要取代ifs</p>
<ol>
<li>没有if的代码更容易阅读</li>
<li>没有if的代码更容易测试</li>
<li>多态更容易维护：容易扩展</li>
</ol>
<p>什么时候使用多态：</p>
<ol>
<li>如果一个对象基于其不同的状态，而表现不一样</li>
<li>如果你要在不同的地方来检测这种条件</li>
</ol>
<p>对于基本数据类型，我们使用<code>&gt;,&lt;,==,!=</code>来做比较。我们要避免使用<code>if</code>。</p>
<p>尽量不适用if<br>不要返回null（使用null之后不能够Dispatch这个错误）,而是返回一个Null对象，比如一个空的list<br>不要返回error代码，而是抛出异常</p>
<h3 id="尽量少用继承"><a href="#尽量少用继承" class="headerlink" title="尽量少用继承"></a>尽量少用继承</h3><p>多态需要使用继承<br>小心继承的层级太深</p>
<h3 id="将条件用多态替代"><a href="#将条件用多态替代" class="headerlink" title="将条件用多态替代"></a>将条件用多态替代</h3><p>你有一个条件，该条件是基于某个对象的类型来选择不同的行为。</p>
<p>将这些条件的判断一到一个子类的覆盖方法中。然后将原来的的方变成一个抽象方法。<br>我们用下面的例子：</p>
<pre><code class="java"><span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>{

  <span class="keyword">switch</span> (_type) {

   <span class="keyword">case</span> ENROPEAN:
        <span class="keyword">return</span> getBaseSpeed();

   <span class="keyword">case</span> AFRICAN:
        <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() * _numberOfCoconuts;

   <span class="keyword">case</span> NORWEGIAN_BLUE:
        <span class="keyword">return</span> (_isNailed) ? <span class="number">0</span> : getBaseSpeed(_voltage);
  }

  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Should be unreachable"</span>);
}
</code></pre>
<p>比如我们有一个<code>1+ 2 * 3</code>的表达式，如果用树来表示应该是这样的： </p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-44f337f613e5c3f2.png" alt="1 + 2 * 3"></p>
<p>这时候大多情况下我们会写下面的的代码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-4efa0dbac30dd19d.png" alt="Implement"></p>
<p>那么大多数情况下会出问题，比如：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-3ee95ff9e5c8dd78.png" alt="Evaluate UML"></p>
<p>从中我们可以看到叶子节点的左右分支都是null，上文已经提到null是很不好的。比如叶子节点我们需要的只是数值，没有function，没有left和right数值。</p>
<p>那么怎么办呢？我们需要将原来的Node创建两个子类，一个ValueNode，一个OpNode。UML图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-e32bbbf0adf5e116.png" alt="SubClass UML"></p>
<p>创建子类之后：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-92adea90f4f9f44d.png" alt="Node Subclass"></p>
<p>Java只针对某个类编译。</p>
<p>这样最终我们的UML图是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-d12731bff0df6db3.png" alt="ValueNode"></p>
<p>用多态替代switch case。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-8e09c9eb66adc448.png" alt="多态UML"></p>
<p>然后系统的操作类变为：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-f3b681a924bba620.png" alt="Operation Class"></p>
<p>然后我们再创建两个<code>OpNode</code>的子类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-d6699abc050608e6.png" alt="OpNodeSubClass"></p>
<p>然后我们有了除去Operation字段的UML图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-1ebf2e28e6c0c310.png" alt="NoOperationUML"></p>
<h2 id="进一步探讨"><a href="#进一步探讨" class="headerlink" title="进一步探讨"></a>进一步探讨</h2><p>定义一个<code>toString()</code>方法来打印表达式的前缀，并且在适当的时候加上括号。<br>添加一些新的数学操作：添加方程，阶乘，算法，三角学。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> 多态的结局方案通常来说是更好的，因为；</p>
<ul>
<li>新功能的添加不需要改动原来的代码</li>
<li>每个操都被放到一个单独的文件中了，这样易于测试和理解，并且易于扩展</li>
</ul>
<p>多用多态而不是条件语句：</p>
<ul>
<li><strong>switch</strong>语句就意味着你应该使用多态</li>
<li><strong>if</strong>更加很精妙，但是有时候一个<strong>if</strong>仅仅是一个<strong>if</strong></li>
</ul>
<h3 id="重复条件"><a href="#重复条件" class="headerlink" title="重复条件"></a>重复条件</h3><pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">Update</span> </span>{
    execute (){
    <span class="keyword">if</span> (FLAG_i18n_ENABLED) {

       <span class="comment">// DO A;</span>
    }<span class="keyword">else</span> {
       <span class="comment">// DO B;</span>
     }
   }
}
</code></pre>
<p>但是后来又有了相似的代码：</p>
<pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">Update</span> </span>{
   render (){
    <span class="keyword">if</span> (FLAG_i18n_ENABLED) {

       <span class="comment">// Render A;</span>
    }<span class="keyword">else</span> {
       <span class="comment">// Render B;</span>
     }
   }
}
</code></pre>
<p>在测试的时候，我们还需要写两套代码，比如：</p>
<pre><code class="java"><span class="keyword">void</span> testExecuteDoA {
    FLAG_i18n_ENABLED = <span class="keyword">true</span>;
    Update u = <span class="keyword">new</span> Update();
    u.execute();
    assertX();
}
<span class="keyword">void</span> testExecuteDoB {
  FLAG_i18n_ENABLED = <span class="keyword">false</span>;
  Update u = <span class="keyword">new</span> Update();
  u.execute();
  assertX();
}
</code></pre>
<p>应该怎样做才好呢？我们应该经条件语句用多态来替代：</p>
<p><em>你有一种条件，这种条件会基于某个对象的类型类选择不同的行为。</em><br>将判断条件一到一个子类的覆盖方法中。将原来类的方法变成抽象方法。</p>
<pre><code class="java">
<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Update</span> </span>{
 <span class="comment">//...</span>
}

<span class="class"><span class="keyword">class</span> <span class="title">I18NUpdate</span> <span class="keyword">extends</span> <span class="title">Update</span> </span>{
   execute() {
    <span class="comment">// Do A;</span>
   }
   render() {
   <span class="comment">// Render A;</span>
   }
}

<span class="class"><span class="keyword">class</span> <span class="title">NoNI18NUpdate</span> <span class="keyword">extends</span> <span class="title">Update</span> </span>{
  execute() {
   <span class="comment">// Do B;</span>
  }
  render() {
   <span class="comment">// Render A;</span>
  }
}
</code></pre>
<p>测试的时候我们就方便多了：</p>
<pre><code class="java"><span class="keyword">void</span> testExecuteDoA {
   Update u = <span class="keyword">new</span> MyI18NUpdate();
   u.execute();
   assertX();
}

<span class="keyword">void</span> testExecuteDoB {
   Update u = <span class="keyword">new</span> MyNonI18NUpdate();
   u.execute();
   assertX();
}
</code></pre>
<p><strong>if</strong>s去哪里了？</p>
<pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>{
  Consumer(Update u){...}
}
</code></pre>
<p>两种方式：</p>
<p>第一种方式：</p>
<p>对象的堆砌</p>
<ul>
<li>业务逻辑</li>
<li>有趣的东西</li>
<li>目的是建造逻辑，主要的抽象</li>
<li>假如需要很多的合作者</li>
</ul>
<p>第二种方式：</p>
<p>构造方法的堆砌</p>
<ul>
<li>工厂</li>
<li>建造者</li>
<li>Provier<t></t></li>
<li>目的是建造对象表</li>
<li>创建和提供合作者（依赖注入）</li>
</ul>
<p>将创建某个具体对象的操作放到工厂方法中去性能会更高，因为我们只需要判断一次就可以对这个对象做一系列的操作。而之前，我们需要尽心一系列的判断。将If else放到工厂中还有一个好处就是便于测试和调试Bug，因为尽管我们有if else，但是这是在创建对象的过程中，具体的业务逻辑我们是放到了子类中去做的，而经常出错的地方往往是业务逻辑，而不是创建对象的过程。举个例子：</p>
<pre><code class="java"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>{
  Consumer(Update u){...}
}

<span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>{
  <span class="function">Consumer <span class="title">build</span><span class="params">()</span> </span>{
    Update u = FLAG_i18n_ENABLED ? <span class="keyword">new</span> I18NUpdate()
                                 : <span class="keyword">new</span> NonI18NUpdate();
    <span class="keyword">return</span> <span class="keyword">new</span> Consumer(u);
  }
}
</code></pre>
<p>使用依赖注入：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-d44fe1f5cbe6fe8f.png" alt="Injection"></p>
<p>这样做的好处是：</p>
<ol>
<li>所有的判断条件都被放到了一个地方</li>
<li>没有很多的重复代码</li>
<li>将责任分离，将全局状态分离</li>
</ol>
<h2 id="总结优势"><a href="#总结优势" class="headerlink" title="总结优势"></a>总结优势</h2><ol>
<li>公用代码放到了一个地方</li>
<li>很容易独立测试和平行测试</li>
<li>关注子类让它更加明白不同点在哪里</li>
</ol>
<p>什么时候用继承？</p>
<p>不同的状态产生不同的行为<br>不同的地方有平行的条件</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/09/05/chat-if-else/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/05/chat-if-else/" itemprop="url">聊聊if else</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-05T07:04:01+08:00">
                2017-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1513759-12027b6db51d7301.png" alt="if else"><br>if else 是我们学习C语言开始用的流程控制语句。还记得大学老师说过一句话，任何复杂的业务逻辑都可以用if else去解决。然而就像面向对象中的继承一样，如果用的过多就会造成代码的腐烂。下面我们就来聊聊if else。</p>
<h2 id="为什么太多的if-else不好？"><a href="#为什么太多的if-else不好？" class="headerlink" title="为什么太多的if else不好？"></a>为什么太多的if else不好？</h2><p>我们先看一个例子：</p>
<pre><code class="swift">   <span class="keyword">public</span> void <span class="type">OnMessage</span>(<span class="type">Push</span>.<span class="type">PushMessage</span> pushMessage) {
    <span class="keyword">try</span> {
        <span class="type">String</span> message = pushMessage.messageContent;
        <span class="type">Log</span>.v(<span class="string">"keyes"</span>, <span class="string">"pushMessage = "</span> + message);
        <span class="keyword">if</span> (message != null) {
            <span class="type">JsonObject</span> data = new <span class="type">JsonParser</span>().parse(message).getAsJsonObject();
            <span class="keyword">if</span> (data.<span class="keyword">get</span>(<span class="string">"type"</span>) != null) {
                <span class="type">String</span> type = data.<span class="keyword">get</span>(<span class="string">"type"</span>).getAsString();
                <span class="keyword">if</span> (<span class="string">"100"</span>.equals(type)) {<span class="comment">//XX消息</span>
                    <span class="type">EventBus</span>.getDefault().post(new <span class="type">GrabActionEvent</span>());
                    <span class="type">PopBean</span> bean = <span class="type">PushUtils</span>.dealPushMessage(mContext, message);
                    <span class="type">IDealWithPush</span> dealWithPush = <span class="type">AppStateUtils</span>.getAppState(mContext);
                    dealWithPush.dealPush(mContext, bean);
                } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"106"</span>.equals(type)) {<span class="comment">// </span>
                    <span class="type">String</span> nick = data.<span class="keyword">get</span>(<span class="string">"nick"</span>).getAsString();
                    <span class="type">WPushNotify</span>.notification(<span class="number">106</span>, nick, <span class="string">"正在访问您的信息，请立即回复"</span>);
                } <span class="keyword">else</span> {
                    <span class="type">Gson</span> temp = new <span class="type">Gson</span>();
                    <span class="keyword">final</span> <span class="type">SystemNotification</span> bean = temp.fromJson(pushMessage.messageContent, <span class="type">SystemNotification</span>.<span class="keyword">class</span>);
                    <span class="keyword">if</span> (bean.getType() == <span class="number">103</span>) {
                        <span class="comment">//应用在后台，不需要刷新UI,通知栏提示新消息</span>
                        <span class="keyword">if</span> (!<span class="type">AppInfoUtils</span>.isRunningForeground(<span class="type">HyApplication</span>.getApplication())) {
                            <span class="type">WPushNotify</span>.notification(bean);
                        }
                        saveDataToDB(bean);
                        <span class="type">EventBus</span>.getDefault().post(bean);
                    } <span class="keyword">else</span> <span class="keyword">if</span> (bean.getType() == <span class="number">104</span>) {
                        <span class="type">List</span>&lt;<span class="type">Activity</span>&gt; list = <span class="type">HyApplication</span>.getInstance().getActivityList();
                        <span class="keyword">if</span> (list != null &amp;&amp; list.size() &gt; <span class="number">0</span>) {
                            <span class="type">Activity</span> activity = list.<span class="keyword">get</span>(list.size() - <span class="number">1</span>);
                            <span class="keyword">if</span> (!<span class="type">TextUtils</span>.isEmpty(bean.getDescribe())) {
                                new <span class="type">LogoutDialog</span>(activity, bean.getDescribe());
                            } <span class="keyword">else</span> {
                                new <span class="type">LogoutDialog</span>(activity, activity.getString(<span class="type">R</span>.string.force_exit));
                            }
                        }
                    } <span class="keyword">else</span> <span class="keyword">if</span> (bean.getType() == <span class="number">108</span>) {<span class="comment">//沉默用户唤醒</span>
                        <span class="type">String</span> title = bean.getTitle();
                        <span class="type">String</span> describe = bean.getDescribe();
                        <span class="type">WPushNotify</span>.notification(<span class="number">108</span>, title, describe);
                    }
                }
            }
        }
    } <span class="keyword">catch</span> (<span class="type">Exception</span> e) {
        <span class="type">LogUtils</span>.e(<span class="string">"push"</span>, e.getMessage());
    }

    <span class="type">Log</span>.i(<span class="string">"song"</span>, pushMessage.messageContent);

}
</code></pre>
<p>这个方法里面仅仅嵌套了好多层if else，看上去会比较复杂难懂，再看一个例子：</p>
<pre><code class="swift"><span class="keyword">if</span>(isSkipPPUForQA &amp;&amp; <span class="type">StringUtils</span>.isNotBlank(request.getParameter(<span class="string">"userId"</span>))){
    <span class="keyword">super</span>.doFilter(request, response, chain);
}<span class="keyword">else</span> {
    <span class="keyword">try</span> {
        <span class="keyword">if</span>(<span class="string">"/app/school/article/share"</span>.equals(request.getRequestURI())){
            <span class="keyword">super</span>.doFilter(request, response, chain);
        }<span class="keyword">else</span>{
            <span class="keyword">if</span>(!filterReqUrl(request)) {
                long ppuUserId = <span class="type">PassportService</span>.passportService.getLoginUserId(<span class="type">RemoteValid</span>.<span class="type">SAPCE_ONE_HOUR</span>, request, response);
                <span class="keyword">if</span> (ppuUserId &lt; <span class="number">2</span>) {
response.getWriter().write(this.generateResponse(<span class="type">AppResultStateEnum</span>.<span class="type">PPU_UNVALID</span>.getCodeStr(), <span class="string">"登录认证信息已过期，请重新登录"</span>));
                    log.error(<span class="string">"ppu返回的userId:"</span> + ppuUserId + <span class="string">",ppu过期,ppu="</span> + <span class="type">PPUCookieUtil</span>.getPpuCookie(request) + <span class="string">",url="</span> + request.getRequestURI());
                    log.error(<span class="string">"imei="</span> + request.getParameter(<span class="string">"imei"</span>) + <span class="string">",version="</span> + request.getParameter(<span class="string">"version"</span>) + <span class="string">",platform="</span> + request.getParameter(<span class="string">"platform"</span>));
                } <span class="keyword">else</span> {
                    boolean flag = isTouchSingleDeviceLimitWithoutLogin(ppuUserId, request);
                    <span class="keyword">if</span> (flag) {
                        <span class="type">String</span> singleDeviceLoginContent = configComp.getValueByConfigTable(<span class="type">ConfigEnum</span>.<span class="type">APP_SINGLE_DEVICE_LOGIN_CONTENT</span>);
                        boolean isH5 = <span class="string">"1"</span>.equals(request.getParameter(<span class="string">"isH5"</span>));
                        <span class="keyword">if</span>(isH5){
                            <span class="type">String</span> jsAjaxHeader = request.getHeader(<span class="string">"X-Requested-With"</span>);
                            <span class="keyword">if</span>(<span class="string">"XMLHttpRequest"</span>.equals(jsAjaxHeader)){response.getWriter().write(this.generateResponse(<span class="type">AppResultStateEnum</span>.<span class="type">SINGLE_DEVICE_LOGIN</span>.getCodeStr(), singleDeviceLoginContent));
                            }<span class="keyword">else</span> {
                             renderSingleDeviceHtml(response,<span class="string">"/single_device_error"</span>);
                            }
                        }<span class="keyword">else</span> {
                            response.getWriter().write(this.generateResponse(<span class="type">AppResultStateEnum</span>.<span class="type">SINGLE_DEVICE_LOGIN</span>.getCodeStr(), singleDeviceLoginContent));
                        }
                        log.error(<span class="string">"触发单设备登录限制错误"</span>);
                    } <span class="keyword">else</span> {
                        request.addParameter(<span class="string">"userId"</span>, new <span class="type">String</span>[]{ppuUserId + <span class="string">""</span>});
                        <span class="keyword">super</span>.doFilter(request, response, chain);
                    }
                }
            }
        }
    } <span class="keyword">catch</span> (<span class="type">Exception</span> e) {
        logger.error(<span class="string">"业务处理异常,url="</span>,e);
    }
}
</code></pre>
<p>第一，这个方法中嵌套了七层的if else，层次太多。第二这个方法太长。嵌套层次过多和方法过长都是Bad Smell。那么究竟很多的if else有哪些弊端呢？</p>
<ul>
<li><p><strong>僵化</strong>：如果再有更多情况的时候，我们需要在原来的地方写更多的if…else if条件。也就是说你需要去改动原来的代码，然后重新编译，重新部署，这是很浪费时间的。并且这违背了面向对象中的<strong>开放封闭原则</strong>：对扩展开放，对修改封闭。同时由于这个类需要处理各种业务，职责太多，所以也违背了<strong>职责单一原则。</strong></p>
</li>
<li><p><strong>效率低下</strong>：很多系统的类，比如<code>HashMaps</code>，<code>Properties</code>等，都非常注意基于数据的条件判断。</p>
</li>
<li><p><strong>难阅读</strong>：像这种层层if else嵌套的情况，如果其他人需要来看，并且维护这份代码，由于难阅读，他们会感觉吃力。试想下，如果段代码很长，一个屏看不完，那肯定是维护的灾难。</p>
</li>
<li><p><strong>难维护</strong>：if else不像switch case，它的每个分支都和其它分支有关系，如果需求变更，在修改某个分支之前要看懂其它所有分支，确保不会对其它分支造成影响。</p>
</li>
<li><p><strong>难调试</strong>：很多if else，调试过程中需要一步步跟进，会影响调试效率。</p>
</li>
<li><p><strong>难测试</strong>：每次我们写测试用例的Case，针对每个有很多if else的方法，我们要对每个分支都写一个测试，这样下来这个测试用例将会变得非常长。</p>
</li>
</ul>
<blockquote>
<p>在任何面向对象语言中，都需要考虑移除分支控制逻辑（<code>if</code>以及<code>switch</code>，<code>case</code>）。移除的常用做法是将这些控制逻辑的方法移到一个类中。 <a href="https://www.quora.com/Why-should-Java-programmers-try-to-avoid-if-statements" target="_blank" rel="external">Quora,Simon Hayes</a></p>
</blockquote>
<p>那么我们怎样来解决这种情况，因为遇到不同的情况需要用不同的解决方案，我们逐个来分析：</p>
<h2 id="常见的嵌套类if-else处理方式"><a href="#常见的嵌套类if-else处理方式" class="headerlink" title="常见的嵌套类if else处理方式"></a>常见的嵌套类if else处理方式</h2><p>比如第一个if else的例子，通常</p>
<h2 id="平行类的if-else处理方式"><a href="#平行类的if-else处理方式" class="headerlink" title="平行类的if else处理方式"></a>平行类的if else处理方式</h2><p><strong>如果我们有几个判断条件是平级if，那么我们可以使用命令模式来解决这种问题。</strong>比如我们现在有如下的if else：</p>
<pre><code class="swift"><span class="keyword">if</span> (value.equals(<span class="string">"A"</span>)) { doCommandA() }
<span class="keyword">else</span> <span class="keyword">if</span> (value.equals(<span class="string">"B"</span>)) { doCommandB() } 
<span class="keyword">else</span> <span class="keyword">if</span> etc.
</code></pre>
<p>这时，我们可以使用<strong>命令模式</strong>来解决，先创建一个接口：</p>
<pre><code class="swift"><span class="keyword">public</span> interface <span class="type">Command</span> {
     void exec();
}
</code></pre>
<p>然后<code>CommandA</code>和<code>CommandB</code>类实现这个接口：</p>
<pre><code class="swift"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandA</span>() <span class="title">implements</span> <span class="title">Command</span> </span>{

     void exec() {
          <span class="comment">// ... </span>
     }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandB</span>() <span class="title">implements</span> <span class="title">Command</span> </span>{

     void exec() {
          <span class="comment">// ...</span>
     }
}
</code></pre>
<p>然后创建一个<code>Map&lt;String,Command&gt;</code>,并且往其中添加Command实例：</p>
<pre><code class="swift">commandMap.put(<span class="string">"A"</span>, new <span class="type">CommandA</span>());
commandMap.put(<span class="string">"B"</span>, new <span class="type">CommandB</span>());
</code></pre>
<p>然后所有的<strong>if/else if</strong>，就都会变成：</p>
<pre><code class="swift">commandMap.<span class="keyword">get</span>(value).exec();
</code></pre>
<p>如果某个Command有任何的改变只需要改动某个具体的类即可，如果有新加的Command，那么只需要添加响应的Command即可。命令模式就是加了一个<strong>中间件：命令容器</strong>(就是这里的Map，根据情况可能会是List或者其它)来实现解耦。</p>
<h2 id="复杂处理算法的if-else"><a href="#复杂处理算法的if-else" class="headerlink" title="复杂处理算法的if else"></a>复杂处理算法的if else</h2><p>如果我们if之后的代码处理的业务逻辑很相似，并且这种处理算法可能会经常变动，比如：</p>
<pre><code class="swift"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfElseDemo</span> </span>{
    <span class="keyword">public</span> double calculateInsurance(double income, <span class="type">InputType</span> type) {
        <span class="keyword">if</span> (type == smallType) {
            <span class="keyword">return</span> income*<span class="number">0.365</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (type == mediumType) {
            <span class="keyword">return</span> (income-<span class="number">10000</span>)*<span class="number">0.2</span>+<span class="number">35600</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (type == bigType) {
            <span class="keyword">return</span> (income-<span class="number">30000</span>)*<span class="number">0.1</span>+<span class="number">76500</span>;
        } <span class="keyword">else</span> {
            <span class="keyword">return</span> (income-<span class="number">60000</span>)*<span class="number">0.02</span>+<span class="number">105600</span>;
        }
    }
}
</code></pre>
<p>那么我们就可以将每个if分支中的代码单独分离到各个类中，然后再抽出一个父类，这样我们每个条件分支中就不会有很多代码了：</p>
<pre><code class="swift"><span class="keyword">public</span> abstract <span class="class"><span class="keyword">class</span> <span class="title">InsuranceStrategy</span> </span>{
    <span class="keyword">public</span> double calculateInsuranceVeryHigh(double income) {
        <span class="keyword">return</span> (income - getAdjustment()) * getWeight() + getConstant();
    }
    <span class="keyword">public</span> abstract int getConstant();
    <span class="keyword">public</span> abstract double getWeight();
    <span class="keyword">public</span> abstract int getAdjustment();
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsuranceStrategyMedium</span> <span class="title">extends</span> <span class="title">InsuranceStrategy</span> </span>{
    @<span class="type">Override</span>
    <span class="keyword">public</span> int getConstant() {
        <span class="keyword">return</span> <span class="number">35600</span>;
    }
    @<span class="type">Override</span>
    <span class="keyword">public</span> double getWeight() {
        <span class="keyword">return</span> <span class="number">0.2</span>;
    }
    @<span class="type">Override</span>
    <span class="keyword">public</span> int getAdjustment() {
        <span class="keyword">return</span> <span class="number">10000</span>;
    }
}

<span class="comment">/*InsuranceStrategyLow和InsuranceStrategyHigh的处理方式相似，此处略去*/</span>
<span class="class"><span class="keyword">class</span> <span class="title">IfElseDemo</span> </span>{
    <span class="keyword">private</span> <span class="type">InsuranceStrategy</span> strategy;
    <span class="keyword">public</span> double calculateInsurance(double income, <span class="type">InputType</span> type) {
        <span class="keyword">if</span> (type == smallType) {
            strategy = new <span class="type">InsuranceStrategyLow</span>();
        } <span class="keyword">else</span> <span class="keyword">if</span> (type == mediumType) {
            strategy = new <span class="type">InsuranceStrategyMedium</span>();
        } <span class="keyword">else</span> <span class="keyword">if</span> (type == bigType) {
            strategy = new <span class="type">InsuranceStrategyHigh</span>();
        } <span class="keyword">else</span> {
            strategy = new <span class="type">InsuranceStrategyVeryHigh</span>();
        }

        <span class="keyword">return</span> strategy.calculate(income);
    }
}
</code></pre>
<p>这样最终不还是有if else吗？是的，最终还是有if else，但是if else的逻辑变得非常清晰，只是用于创建一个新的类。并且我们将经常变化的算法部分封装到了子类中，如果某个子类中的算法变了，只需要变动某个子类（<strong>封装变化</strong>），然后重新编译就可以了，不需要将整个项目重新编译，部署。</p>
<h2 id="区间类的if-else"><a href="#区间类的if-else" class="headerlink" title="区间类的if else"></a>区间类的if else</h2><p>如果客户端的if条件表示的是不同的范围，然后根据不同范围来选择不同的对象来处理，比如：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{

    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>{

        Request request = <span class="keyword">new</span> Request();
        request.addSalaryAmount = <span class="number">9999</span>;
        <span class="keyword">if</span> (request.addSalaryAmount &lt;= <span class="number">100</span>){
            DivisionManager divisionManager = <span class="keyword">new</span> DivisionManager();
            divisionManager.accept();
        }<span class="keyword">else</span> <span class="keyword">if</span> (request.addSalaryAmount &lt;= <span class="number">1000</span>){
            Chief chief = <span class="keyword">new</span> Chief();
            chief.accept();
        }<span class="keyword">else</span> <span class="keyword">if</span> (request.addSalaryAmount &lt;= <span class="number">10000</span>){
            GeneralManager generalManager  = <span class="keyword">new</span> GeneralManager();
            generalManager.accept();
        }<span class="keyword">else</span> {
            System.out.println(<span class="string">"金额太大没人能批准"</span>);
        }
    }
}
</code></pre>
<p>上面这个例子中，不同的条件分支是让不同的对象来处理这种条件。并且以后可能Request对象会添加其他的请求属性，比如offWork（请假），并且这种请求属性同样需要<code>DivisionManager</code>，<code>Chief</code>，<code>GeneralManager</code>。然而其中的处理顺序变了，并不是现在的请求等级。可能是先由<code>Chief</code>处理，再有<code>GeneralManager</code>处理，最后有<code>DivisionManager</code>来处理，那怎么办呢？难道还要写一套if else吗？<br>这时候我们就可以用责任链模式来将这一长串if else嵌套进每一个对象中去，我们可以这样做：</p>
<pre><code class="java"><span class="class"><span class="keyword">interface</span> <span class="title">ManagerCommand</span></span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> requestAmount)</span></span>;
}

<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommManager</span> <span class="keyword">implements</span> <span class="title">ManagerCommand</span> </span>{
    <span class="keyword">public</span> CommManager superior;
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuperior</span><span class="params">(CommManager superior)</span> </span>{
        <span class="keyword">this</span>.superior = superior;
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivisionManager</span> <span class="keyword">extends</span> <span class="title">CommManager</span> </span>{

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> requestAmount)</span> </span>{

        <span class="keyword">if</span> (requestAmount&lt;<span class="number">100</span>){
            System.out.println(<span class="string">"部门经理批准"</span>);
        }<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">this</span>.superior != <span class="keyword">null</span>){
            <span class="keyword">this</span>.superior.accept(requestAmount);
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chief</span> <span class="keyword">extends</span> <span class="title">CommManager</span></span>{

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">accept</span><span class="params">(<span class="keyword">int</span> requestAmount)</span>  </span>{
        <span class="keyword">if</span> (requestAmount &lt; <span class="number">1000</span>){
        System.out.println(<span class="string">"总监同意"</span>);
        }<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.superior != <span class="keyword">null</span>){
            <span class="keyword">this</span>.superior.accept(requestAmount);
        }
    }
}
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralManager</span> <span class="keyword">extends</span> <span class="title">CommManager</span></span>{

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> requestAmount)</span> </span>{

        <span class="keyword">if</span> (requestAmount&lt;<span class="number">10000</span>){
            System.out.println(<span class="string">"总经理批准"</span>);
        }<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.superior != <span class="keyword">null</span>){
            <span class="keyword">this</span>.superior.accept(requestAmount);
        }
    }
}
</code></pre>
<p>最后在Client端调用的时候，我们可以这样写：</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{

    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>{

        Request request = <span class="keyword">new</span> Request();
        request.addSalaryAmount = <span class="number">999</span>;
        DivisionManager divisionManager = <span class="keyword">new</span> DivisionManager();
        Chief chief = <span class="keyword">new</span> Chief();
        GeneralManager generalManager = <span class="keyword">new</span> GeneralManager();
        divisionManager.setSuperior(chief);
        chief.setSuperior(generalManager);
        divisionManager.accept(request.addSalaryAmount);
    }
}
</code></pre>
<p>这种写法的好处是：<strong>将条件和处理该条件的对象解耦，每个处理条件的对象都不知道其他对象，我们可以随时地增加或者修改处理一个请求的结构。这增加了给对象指派职责的灵活性</strong>。</p>
<blockquote>
<p>小结：其实上述的每种方式都是利用<strong>多态</strong>来解决分支带来的僵化，<a href="https://www.youtube.com/watch?v=4F72VULWFvc" target="_blank" rel="external">谷歌有一个视频对这个问题阐述得很好。</a>。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://stackoverflow.com/questions/10175805/how-to-avoid-a-lot-of-if-else-conditions" target="_blank" rel="external">https://stackoverflow.com/questions/10175805/how-to-avoid-a-lot-of-if-else-conditions</a></li>
<li><a href="https://stackoverflow.com/questions/271526/avoiding-null-statements?rq=1" target="_blank" rel="external">https://stackoverflow.com/questions/271526/avoiding-null-statements?rq=1</a></li>
<li><a href="https://stackoverflow.com/questions/14136721/converting-many-if-else-statements-to-a-cleaner-approach" target="_blank" rel="external">https://stackoverflow.com/questions/14136721/converting-many-if-else-statements-to-a-cleaner-approach</a></li>
<li><a href="https://www.youtube.com/watch?v=4F72VULWFvc" target="_blank" rel="external">https://www.youtube.com/watch?v=4F72VULWFvc</a></li>
<li><a href="https://www.quora.com/Why-should-Java-programmers-try-to-avoid-if-statements" target="_blank" rel="external">https://www.quora.com/Why-should-Java-programmers-try-to-avoid-if-statements</a></li>
<li><a href="https://stackoverflow.com/questions/1199646/long-list-of-if-statements-in-swift/1199677#1199677" target="_blank" rel="external">https://stackoverflow.com/questions/1199646/long-list-of-if-statements-in-swift/1199677#1199677</a></li>
<li><a href="https://industriallogic.com/xp/refactoring/conditionalWithStrategy.html" target="_blank" rel="external">https://industriallogic.com/xp/refactoring/conditionalWithStrategy.html</a></li>
<li>大话设计模式</li>
<li>重构改善既有代码的设计</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/09/04/wwdc-understand-foundation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/04/wwdc-understand-foundation/" itemprop="url">理解Foundation框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-04T10:13:00+08:00">
                2017-09-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文源于对WWDC：UnderStanding Foundation的总结。</p>
<h2 id="什么是Foundation"><a href="#什么是Foundation" class="headerlink" title="什么是Foundation?"></a>什么是Foundation?</h2><ul>
<li>Foundation提供了构建基础类的框架<ul>
<li>所有应用都是用的基础类型</li>
<li>它们供软件的更高层来组合使用</li>
</ul>
</li>
</ul>
<h2 id="Dictionry"><a href="#Dictionry" class="headerlink" title="Dictionry"></a>Dictionry</h2><p>Dictionary中提供了<code>objectEnumerator</code>和<code>keyEnumerator</code>两个方法，可以直接取到<code>key</code>或者<code>value</code>的Enumerator，然后就直接可以用while循环了。</p>
<pre><code class="objc"><span class="built_in">NSEnumerator</span> *e = [dictionary keyEnumerator];

<span class="keyword">while</span>(<span class="keyword">id</span> key = [e nextObject]){

 <span class="keyword">id</span> value = [e objectForKey:key];
 ....
}
</code></pre>
<h3 id="Fast-Enumeration"><a href="#Fast-Enumeration" class="headerlink" title="Fast Enumeration"></a>Fast Enumeration</h3><p>如果想获取某个Dictionary中的key，那么直接用Fast Enumeration就可以：</p>
<pre><code class="objc"><span class="built_in">NSDictionary</span> *someDic = @{<span class="string">@"key"</span>:<span class="string">@"value"</span>};
<span class="keyword">for</span> (<span class="keyword">id</span> key <span class="keyword">in</span> someDic) {

    <span class="built_in">NSLog</span>(<span class="string">@"key:%@"</span>,key);   
}
</code></pre>
<p>如果想要获取Key及其对应的Value，那么直接是用Block就可以：</p>
<pre><code class="objc">[someDic enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull obj, <span class="built_in">BOOL</span> * _Nonnull stop) {

}];
</code></pre>
<h3 id="NSArray排序"><a href="#NSArray排序" class="headerlink" title="NSArray排序"></a>NSArray排序</h3><p>对一个NSArray进行排序，有以下几种方法：</p>
<ol>
<li>C function</li>
<li>Objective-C method</li>
<li>NSSortDescriptor</li>
<li>Blocks</li>
</ol>
<p>使用Bock遍历数组的方法：</p>
<pre><code class="objc"><span class="built_in">NSMutableArray</span> *names = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"11"</span>,<span class="string">@"22"</span>, <span class="literal">nil</span>];
    [names sortUsingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span>  _Nonnull obj1, <span class="keyword">id</span>  _Nonnull obj2) {
        <span class="built_in">NSComparisonResult</span> result;
        <span class="built_in">NSUInteger</span> lLen = [obj1 length], rLen = [obj2 length];

        <span class="keyword">if</span> (lLen &lt; rLen) {
            result = <span class="built_in">NSOrderedAscending</span>;
        }<span class="keyword">else</span> <span class="keyword">if</span> (lLen &gt; rLen){   
            result = <span class="built_in">NSOrderedDescending</span>;
        }<span class="keyword">else</span>{
            result = <span class="built_in">NSOrderedSame</span>;
        }        
        <span class="keyword">return</span> result;
    }];
</code></pre>
<h3 id="Collection的过滤"><a href="#Collection的过滤" class="headerlink" title="Collection的过滤"></a>Collection的过滤</h3><p><strong>遍历一个Collection的同时再改变它，会引发异常。</strong><br>Collection的过滤步骤：</p>
<ol>
<li>将要筛选的Collection改为可变类型的</li>
<li>筛选出需要移除的项</li>
<li>调用可变类型的响应方法进行移除</li>
</ol>
<pre><code class="objc"><span class="built_in">NSMutableArray</span> *files = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"file0"</span>,<span class="string">@"file1"</span>, <span class="literal">nil</span>]; <span class="comment">// array of NSString objcects;</span>
<span class="built_in">NSIndexSet</span> *toRemove = [files indexesOfObjectsPassingTest:^<span class="built_in">BOOL</span>(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) {

    <span class="keyword">if</span> ([obj hasPrefix:<span class="string">@"."</span>]) {<span class="keyword">return</span> <span class="literal">YES</span>;}
    <span class="keyword">return</span> <span class="literal">NO</span>;

}];
[files removeObjectsAtIndexes:toRemove];
</code></pre>
<h3 id="Collection更多的特性"><a href="#Collection更多的特性" class="headerlink" title="Collection更多的特性"></a>Collection更多的特性</h3><ul>
<li>查找</li>
<li>对每个元素都调用某个方法</li>
<li><code>NSArray</code>：切开和串联</li>
<li>NSSet：交集，合并和子集</li>
</ul>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p>String其实是一个Unicode字符集的数组，你可以将它看做非透明的容器。对它的常用方法有：</p>
<ul>
<li>比较</li>
<li>查找</li>
<li>转换编码</li>
</ul>
<h3 id="字符串比较的方法："><a href="#字符串比较的方法：" class="headerlink" title="字符串比较的方法："></a>字符串比较的方法：</h3><pre><code class="objc">- (<span class="built_in">NSComparisonResult</span>)compare:(<span class="built_in">NSString</span> *)string; <span class="comment">// 1</span>
- (<span class="built_in">NSComparisonResult</span>)localizedStandardCompare:(<span class="built_in">NSString</span> *)string <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0); <span class="comment">// 2</span>
- (<span class="built_in">NSComparisonResult</span>)localizedCompare:(<span class="built_in">NSString</span> *)string; <span class="comment">// 3</span>
- (<span class="built_in">NSComparisonResult</span>)localizedCaseInsensitiveCompare:(<span class="built_in">NSString</span> *)string; <span class="comment">// 4</span>
- (<span class="built_in">NSComparisonResult</span>)compare:(<span class="built_in">NSString</span> *)string options: (<span class="built_in">NSStringCompareOptions</span>)mask range:(<span class="built_in">NSRange</span>)rangeOfReceiverToCompare locale:(<span class="keyword">nullable</span> <span class="keyword">id</span>)locale; <span class="comment">// 5</span>
</code></pre>
<p>第二个方法和第三个方法是对那些做了本地化的字符串进行比对。第四个可以对字符串的一部分进行比较，并且可以指定是否是大小写敏感等。如果数组中有字符串需要排序，那么我们可以用到上文中提到的，让数组中的元素分别调用其自身的方法。</p>
<pre><code class="objc"><span class="built_in">NSArray</span> *strings = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Larry"</span>,<span class="string">@"Curly"</span>,<span class="string">@"Moe"</span>, <span class="literal">nil</span>];
<span class="built_in">NSArray</span> *sortedArray = [strings sortedArrayUsingSelector:<span class="keyword">@selector</span>(localizedCompare:)];
</code></pre>
<h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><p>字符串查找的方法如下：</p>
<pre><code class="objc">- (<span class="built_in">NSRange</span>)rangeOfString:(<span class="built_in">NSString</span> *)searchString;
- (<span class="built_in">NSRange</span>)rangeOfString:(<span class="built_in">NSString</span> *)searchString options:(<span class="built_in">NSStringCompareOptions</span>)mask range:(<span class="built_in">NSRange</span>)rangeOfReceiverToSearch locale:(<span class="keyword">nullable</span> <span class="built_in">NSLocale</span> *)locale <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);
</code></pre>
<p>*注：如果有特殊字符，比如<code>Ó</code>，那么它在数组中是<code>O</code>，<code>´</code>两个分开存储，是占两个存储单位的，所以它自身rang的length是2。</p>
<p>字符串的查找中还支持正则表达式：</p>
<pre><code class="objc"><span class="built_in">NSString</span> *str = <span class="string">@"Going going gone!"</span>;
<span class="built_in">NSRange</span> found = [str rangeOfString:<span class="string">@"go(\\w*)"</span>
                           options:<span class="built_in">NSRegularExpressionSearch</span>
                             range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, str.length)];
</code></pre>
<p>这样我们就可以得到found的值：found.location = 6, found.length = 5;</p>
<h3 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h3><p>字符串和Data之间编码的相互转换：</p>
<pre><code class="objc"><span class="built_in">NSData</span> *someData = [<span class="built_in">NSData</span> dataWithContentsOfFile:<span class="string">@""</span>];
<span class="built_in">NSString</span> *inString = [[<span class="built_in">NSString</span> alloc]initWithData:someData encoding:<span class="built_in">NSUTF8StringEncoding</span>];
<span class="built_in">NSString</span> *outString = <span class="string">@"For Windows"</span>;
<span class="built_in">NSData</span> *converted = [outString dataUsingEncoding:<span class="built_in">NSUTF16StringEncoding</span>];
</code></pre>
<p>如果要将某个和文件系统相独立的字符串表示成文件系统调用时所指定的字符串表示，可以使用：</p>
<pre><code class="objc"><span class="keyword">const</span> <span class="keyword">char</span> *fileName = [outString fileSystemRepresentation];
</code></pre>
<p>将它表示成一个C类型的字符串，这个字符串在outString销毁的时候也跟着自动销毁。</p>
<p>更多的特性：</p>
<ul>
<li>打印格式</li>
<li>遍历逐个子字符串遍历，逐行遍历，逐段遍历</li>
<li>替换某个子字符串</li>
<li>路径补全</li>
</ul>
<h3 id="NSDateFormatter："><a href="#NSDateFormatter：" class="headerlink" title="NSDateFormatter："></a>NSDateFormatter：</h3><p>如果不想将一个<code>NSDate</code>转换成字符串的时候出现时间，那么可以将<code>timeStyle</code>设置为：<code>NSDateFormatterNoStyle</code>。</p>
<pre><code class="objc"><span class="built_in">NSDateFormatter</span> *fmt = [[<span class="built_in">NSDateFormatter</span> alloc]init];
[fmt setTimeStyle:<span class="built_in">NSDateFormatterNoStyle</span>];
[fmt setDateStyle:<span class="built_in">NSDateFormatterLongStyle</span>];
</code></pre>
<h3 id="Dates和Formatter小结"><a href="#Dates和Formatter小结" class="headerlink" title="Dates和Formatter小结"></a>Dates和Formatter小结</h3><ul>
<li>将NSDate和NSCalendar混合使用来计算时间</li>
<li>当展现日期和数字的时候使用foramtter</li>
</ul>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><h3 id="将数据以Plist的形式存储"><a href="#将数据以Plist的形式存储" class="headerlink" title="将数据以Plist的形式存储"></a>将数据以Plist的形式存储</h3><p>将数据转换成Plist：</p>
<pre><code class="objc"><span class="built_in">NSDictionary</span> *colors = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:<span class="string">@"Verde"</span>,<span class="string">@"Green"</span>,<span class="string">@"Rojo"</span>,<span class="string">@"Red"</span>,<span class="string">@"Amarillo"</span>,<span class="string">@"Yellow"</span>, <span class="literal">nil</span>];
<span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
<span class="built_in">NSData</span> *plist = [<span class="built_in">NSPropertyListSerialization</span> dataWithPropertyList:colors format:<span class="built_in">NSPropertyListXMLFormat_v1_0</span> options:<span class="number">0</span> error:&amp;error];
<span class="keyword">if</span> (!plist) {
    <span class="built_in">NSLog</span>(<span class="string">@"本地化失败"</span>);
}
[plist writeToFile:<span class="string">@"filePath"</span> atomically:<span class="literal">YES</span>];
</code></pre>
<p>将Plist转化成NSData：</p>
<pre><code class="objc"><span class="built_in">NSData</span> *readData = [<span class="built_in">NSData</span> dataWithContentsOfURL:urlOfFile];
<span class="built_in">NSDictionary</span> *newColors = [<span class="built_in">NSPropertyListSerialization</span> propertyListWithData:readData options:<span class="number">0</span> format:<span class="literal">nil</span> error:&amp;error];
</code></pre>
<h3 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h3><p>NSFileManager支持文件的复制，移动，链接，删除等。</p>
<pre><code class="objc"><span class="built_in">NSFileManager</span> *mgr = [[<span class="built_in">NSFileManager</span> alloc]init];
<span class="built_in">BOOL</span> res;
res = [mgr copyItemAtURL:src toURL:des error:&amp;error];
res = [mgr moveItemAtURL:src toURL:des error:&amp;error];
res = [mgr linkItemAtURL:src toURL:des error:&amp;error];
res = [mgr removeItemAtURL:src error:&amp;error];
</code></pre>
<p><code>linkItemAtURL</code>就是创建一个硬链接，硬链接就是给一个已经存在的文件重新创建另外一个名字，如果原来文件被删除了，那么硬链接的名字就会失效了。</p>
<p>NSFileManager还可以遍历某个目录下所有的内容：</p>
<pre><code class="objc"><span class="built_in">NSArray</span> *stuff = [mgr contentsOfDirectoryAtURL:dirURL includingPropertiesForKeys:[<span class="built_in">NSArray</span> array] options:<span class="number">0</span> error:&amp;error];
</code></pre>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/27/chat-nsdateformatter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/27/chat-nsdateformatter/" itemprop="url">如何优雅地使用DateFormatter？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-27T09:48:45+08:00">
                2017-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>之所以要聊<code>DateFormatter</code>是因为某次给项目做性能检测，发现创建DateFormatter太消耗性能，我们来做个对比，新建100000个日期。我们使用两种方式：第一种每次创建日期的时候新建一个NSDateFormatter，第二种共用一个NSDateFormatter，来生成日期：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">testWithMultipleInstantiation</span><span class="params">()</span></span> -&gt;<span class="type">CFTimeInterval</span> &#123;</div><div class="line">    </div><div class="line">        <span class="keyword">var</span> dateStrings:[<span class="type">String</span>] = []</div><div class="line">        dateStrings.reserveCapacity(<span class="number">100000</span>)</div><div class="line">        <span class="keyword">let</span> startTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">100000</span> &#123;</div><div class="line">            <span class="keyword">let</span> df = <span class="type">DateFormatter</span>()</div><div class="line">            df.dateStyle = .medium</div><div class="line">            df.timeStyle = .full</div><div class="line">            dateStrings.append(df.string(from: <span class="type">Date</span>()))</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">let</span> endTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">        <span class="keyword">return</span> endTime - startTime</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">testWithSingleInstance</span><span class="params">()</span></span> -&gt;<span class="type">CFTimeInterval</span> &#123;</div><div class="line">    </div><div class="line">        <span class="keyword">var</span> dateStrings: [<span class="type">String</span>] = []</div><div class="line">        dateStrings.reserveCapacity(<span class="number">100000</span>)</div><div class="line">        <span class="keyword">let</span> startTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">        <span class="keyword">let</span> df = <span class="type">DateFormatter</span>()</div><div class="line">        df.dateStyle = .medium</div><div class="line">        df.timeStyle = .full</div><div class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">100000</span> &#123;</div><div class="line">            dateStrings.append(df.string(from: <span class="type">Date</span>()))   </div><div class="line">        &#125;   </div><div class="line">        <span class="keyword">let</span> endTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">        <span class="keyword">return</span> endTime - startTime</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们调用这两个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"testWithMultipleInstantiation--<span class="subst">\(testWithMultipleInstantiation()</span>)"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"testWithSingleInstance--<span class="subst">\(testWithSingleInstance()</span>)"</span>)</div></pre></td></tr></table></figure>
<p>打印结果是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">testWithMultipleInstantiation--<span class="number">7.83139349098201</span></div><div class="line">testWithSingleInstance--<span class="number">0.742719032976311</span></div></pre></td></tr></table></figure>
<p>从中可以明显看到创建<code>DateFormatter</code>是很消耗性能的，多次创建DateFormatter比单次创建大约要慢11倍。如果我们要用DateFormatter，那么尽量创建一次，然后多次使用。</p>
<p>然后我们再做进一步的实验：创建一次<code>DateFormatter</code>，但是改变这个NSDateFormatter的<code>dateStyle</code>和<code>timeStyle</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">testWithSingleInstanceChangeFormatter</span><span class="params">()</span></span> -&gt;<span class="type">CFTimeInterval</span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">var</span> dateStrings: [<span class="type">String</span>] = []</div><div class="line">        dateStrings.reserveCapacity(<span class="number">100000</span>)</div><div class="line">        <span class="keyword">let</span> startTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">        <span class="keyword">let</span> df = <span class="type">DateFormatter</span>()</div><div class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">100000</span> &#123;</div><div class="line">            </div><div class="line">            df.dateStyle = .medium</div><div class="line">            df.timeStyle = .full</div><div class="line">            df.dateStyle = .full</div><div class="line">            df.timeStyle = .medium</div><div class="line">            dateStrings.append(df.string(from: <span class="type">Date</span>()))</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> endTime = <span class="type">CACurrentMediaTime</span>()</div><div class="line">        <span class="keyword">return</span> endTime - startTime</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>然后调用这个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"ChangeFormatter--<span class="subst">\(testWithSingleInstanceChangeFormatter()</span>)"</span>)</div></pre></td></tr></table></figure>
<p>这时输出的结果是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">ChangeFormatter</span>--<span class="number">5.77827541399165</span></div></pre></td></tr></table></figure>
<p>从中我们可以看到，其对性能的消耗和多次创建DateFormatter相差并不多。最后我们得到这样一个结论：</p>
<blockquote>
<ol>
<li>每次使用DateFormatter时都新建是最消耗性能的</li>
<li>创建一个DateFormatter然后改变其<code>dateStyle</code>和<code>timeStyle</code>等和1中的性能消耗差不多</li>
<li>为每一种日期类型创建一种DateFormatter并且不改变其<code>dateStyle</code>和<code>timeStyle</code>等属性是性能最优的</li>
</ol>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过上面的结论，我们发现如果对DateFormatter做成单例，那么就必须保证每个DateFormatter的格式是相同的，因为改变DateFormatter的格式也是很消耗性能的。我们要做多个单例，每种单例是一种formatter，然后分别使用吗？显然太过于麻烦。<strong>我们可以使用缓存策略，将每种格式的DateFormatter缓存一份，下次如果有相同格式的Formatter，直接从缓存中取就可以了，这就避免了多次创建和多次改变格式的问题。</strong>为了解决这个问题，我使用NSCache做了一个DateFormatter的缓存池：<a href="https://github.com/MikeFighting/MFDateFormatterPool" target="_blank" rel="external">MFDateFormatterPool</a>，已经上传到了GitHub上，分为OC和Swift两个版本，如有问题可以联系我（Swift版稍后会加上）。</p>
<p><em>其它：NSDateFormatter在IOS7之前是非线程安全的，多线程可能引起崩溃，</em></p>
<h3 id="延伸阅读："><a href="#延伸阅读：" class="headerlink" title="延伸阅读："></a>延伸阅读：</h3><p><a href="https://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks#reuseobjects" target="_blank" rel="external">https://www.raywenderlich.com/31166/25-ios-app-performance-tips-tricks#reuseobjects</a><br><a href="http://www.chibicode.org/?p=41" target="_blank" rel="external">http://www.chibicode.org/?p=41</a><br><a href="https://stackoverflow.com/questions/18195051/crash-in-nsdateformatter-setdateformat-method" target="_blank" rel="external">https://stackoverflow.com/questions/18195051/crash-in-nsdateformatter-setdateformat-method</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/26/why-java-popular/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/why-java-popular/" itemprop="url">Java为什么会流行？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-26T09:17:48+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>下面是TIOBE对计算机语言流行度的最新排名：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-d7123c8e5701f435.png" alt="Language Rate"></p>
<p>我们可以看到Java名列第一，并且Java一直排名很靠前。为什么Java会如此流行呢？要了解Java为什么这么流行，我们先从它的起源说起。</p>
<h3 id="Java诞生的前奏"><a href="#Java诞生的前奏" class="headerlink" title="Java诞生的前奏"></a>Java诞生的前奏</h3><p>计算机业内一般认为：B语言导致了C语言的诞生，C语言演变出了C++，而C++会被Java语言所打败。是什么导致了Java的诞生？想要解决这个问题，我们先来看看Java的前辈们。</p>
<h4 id="C语言的诞生"><a href="#C语言的诞生" class="headerlink" title="C语言的诞生"></a>C语言的诞生</h4><p>C语言的产生是人们追求结构化、高效率、高级语言的结果，它可以替代汇编进行开发，它的出现改变了人们之前的编程方法和思路。</p>
<p>C语言的出现解决了之前语言的各种不足，比如：FORTRAN高效但不适用于编写系统程序。BASIC虽然容易学习，但是功能不够强大。汇编高效，但是学习成本很大，且很难调试。</p>
<p>另外，C语言之前的语言没有考虑结构化设计。它们大量使用<code>GOTO</code>语句来对程序进行控制。这样做的结果是<strong>程序极其混乱</strong>，各种跳转和条件分支交织在一起极大地影响了程序的可读性。人们解决该问题的愿望非常强烈，且日益迫切。20世界70年代初，计算机革命开始，人们对于软件的需求日益增加，使用当时的语言开发软件已经无法满足需求。人们在此期间进行了很多的尝试，但是没有发明出更好的语言。直到一个新机遇的到来：<strong>计算机硬件资源的富余</strong>。由于计算机硬件的增多，程序员可以随意的使用计算机，随意进行各种尝试，这就给了他们开发自己工具的机会。后来Ken Thompson发明了B语言，B语言演化到了C语言。1989年美国国家标准化组织制定了C语言的标准，C语言被正式标准化。C语言是由程序员对编程实践的总结而发明出来的，它能够解决早期语言的种种缺陷。</p>
<h4 id="C-的诞生"><a href="#C-的诞生" class="headerlink" title="C++的诞生"></a>C++的诞生</h4><p>C语言被用的好好的，为何出现了C++呢？原因是C语言太复杂了。当一个工程项目达到一定规模之后，使用结构化编程方法，编程人员就无法对它的复杂性进行有效管理。20世纪80年代初期，许多工程项目的复杂性都超过了结构化方法的极限。为了解决这个问题，面向对象诞生了。面向对象的特性：继承，封装，多态是用来帮助组织复杂程序的编程方法。因此出现了C++，C++的产生是基于C的，它包含了C的所有特征，属性和优点。</p>
<h4 id="Java出现的时机到了"><a href="#Java出现的时机到了" class="headerlink" title="Java出现的时机到了"></a>Java出现的时机到了</h4><p>在20世纪80年代末到90年代初，使用面向对象的C++语言占主导地位。然而，推动计算机语言进化的力量正在酝酿。万维网（WWW）和Internet在随后的几年达到了临界状态，这就促成了编程的另一场革命。</p>
<h3 id="Java诞生"><a href="#Java诞生" class="headerlink" title="Java诞生"></a>Java诞生</h3><p>由于嵌入式系统的发展，人们对一种独立于平台的语言更加渴望，这种语言可以嵌入微波炉，遥控器等各种家用电器设备的软件。用作控制器芯片的CPU是多种多样的，但是C和C++只能对特定目标进行编译。比如某个CPU要编译C++代码，那么就要创建一个针对该CPU的C++编译器，而创建编译器是一项耗时耗长，耗资大的工作。为了解决这个问题，Gosling和其他人一直在开发一种可移植，跨平台的语言。该语言能够生成运行于不同环境，不同CPU芯片上的代码。经过不懈的努力，在1991年被James Gosling，Patrick Naughton，Chris Warth，Ed Frank和Mike Sheridan发明出来。第一版花了18个月。刚开始叫Oak，于1995年更名为Java。</p>
<h3 id="Java流行"><a href="#Java流行" class="headerlink" title="Java流行"></a>Java流行</h3><p>在万维网（WWW）出现之前Java处于有用、摸摸无闻的用于电子消费品编程的状态。然而由于万维网的出现，Java被推到了计算机语言的设计的最前沿，<strong>因为万维网也需要可移植的程序。</strong></p>
<p>因特网是由不同的、分布式的系统组成，其中包含各种类型的计算机，操作系统和CPU。尽管许多类型的平台都可以与因特网连接，但是用户仍然希望他们能够运行同样的程序。</p>
<p>1993年，Java设计小组的成员发现解决嵌入式控制器可移植性的方法，也可以用来解决因特网的代码的可移植性问题。也就是Java不仅可以用来解决小范围的问题，也可以用来解决大范围的问题。这样他们将Java的重心由电子消费品，转移到Internet编程上。</p>
<h3 id="Java对Internet为什么重要"><a href="#Java对Internet为什么重要" class="headerlink" title="Java对Internet为什么重要"></a>Java对Internet为什么重要</h3><p>在网路中，在服务器和个人计算机间传递的信息有两大对象：被动的信息和动态的、主动运行的程序。比如阅读电子邮件是被动的数据，被服务器用来正确的显示服务器传递数据的程序是动态的。这中动态性是好的，但是其安全性和可移植行有严重的缺陷。在Java产生以前，赛百空间有一半的对象实体无法进入网络世界，是Java为它们打开了便利之门，而且在这个过程中定义了一种全新的程序形式:applet(小应用程序)。 </p>
<h4 id="Java小应用程序"><a href="#Java小应用程序" class="headerlink" title="Java小应用程序"></a>Java小应用程序</h4><p>Java可以用来生成两类程序：应用程序（Application）和小应用程序(Java applet)。应用程序不必说，小应用程序是可以再Internet中传输并在兼容Java的Web浏览器中运行的应用程序。小应用程序实际上就是小型的Java程序，它能够像图像文件、声音文件和视频片段那样通过网络动态下载。小程序的特点是，它是动态的智能的程序，可以对用户的输入作出反应，并变化。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>每次当你下载一个程序的时候，你都要冒着被病毒入侵的危险。Java出现之前，很多用户不经常下载可执行的程序文件。即使下载了，在运行它之前也要进行病毒检查。经管如此，很多用户还是担心他们的系统被病毒感染，除此之外，有些恶意程序可以搜索你计算机本地文件系统内容来收集你的私人信息，比如信用卡号码、银行账号和密码等。Java在网络程序和你的计算机之间提供了一道防火墙，消除了用户的顾虑。这道防火墙就是Java运行环境。Java程序被限制在了运行环境中，不允许它访问计算机的其他部分。</p>
<h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><p>链接到Internet上的计算机和操作系统不尽相同，要使它们都能动态地下载同一个程序，就需要有能够生成可移植性执行代码的方法。这个方法就是：Java编译器的输出并不是可执行的代码，而是字节码（bytecode）。字节码是一套设计用来在Java运行时环境下执行的高度优化的指令集，该Java运行时系统成为Java虚拟机（JavaVirtual Machine, JVM）。在标准形式下，JVM就是一个字节码解释器。只要某个平台安装了Java虚拟机，它就可以解释Java代码。当然对Java程序进行解释也有助于它的安全性。因为每个Java程序的运行都在Java虚拟机的控制之下，Java虚拟机可以包含这个程序，并且不让它在系统之外产生副作用。</p>
<h4 id="Java虚拟机的增强"><a href="#Java虚拟机的增强" class="headerlink" title="Java虚拟机的增强"></a>Java虚拟机的增强</h4><p>尽管Java被设计为解释执行的程序，但是这没有妨碍它将动态字节码编译为本机代码。SUN公司在Java 2发行版中提供了一个字节码编译器–JIT(Just In Time)。它可以根据需要，一部分一部分地将字节码实时编译为可执行代码。它不能将整个Java程序一次性全部编译为可执行的代码，因为Java要执行各种检查，而这些检查只有在运行时才执行。这种编译执行的方法使性能得到较大的提高。</p>
<p>经过上面的探讨我们发现，推动计算机语言发展的因素有两个：</p>
<blockquote>
<ul>
<li>适应正在变化的环境和需求</li>
<li>实现编程艺术的完善和提高</li>
</ul>
</blockquote>
<p>Java之所以流行主要因为万维网的发展和其自身安全性和可移植性的特点。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/24/avfoundation-capture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/avfoundation-capture/" itemprop="url">AVFoundation--媒体捕获</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-24T10:27:12+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了管理设备(比如摄像头或者麦克风)捕获的信息，你需要组合一些对象来代表输入和输出，并且使用<code>AVCaptureSession</code>对象来调节它们之间的数据。你最少需要如下步骤：</p>
<ul>
<li><code>AVCaptureDevice</code>对象来代表输入设备，比如：摄像头或者麦克风</li>
<li>具体的<code>AVCaptureInput</code>子类实例来配置输入设备的<code>port</code></li>
<li>具体<code>AVCaptureOutput</code>子类实例来输入一个视频文件或者静态图片</li>
<li>一个<code>AVCaptureSession</code>实例来协调输入到输入的数据流</li>
</ul>
<p>为了给用户预览正在录制的视频，你可以使用<code>AVCaptureVideoPreviewLayer</code>实例来实现。你可以通过一个单一的session来配置各种输入输出：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-c534307e74f3784f.png" alt="session work"></p>
<p>对于很多应用来说，这就已经够用了。然而对于某些操作来说，比如，你要检测音频频道的power level，你需要考虑某个输入设备的各种端口，以及这些端口是怎样和输出相连接的。<br>捕获输入和捕获输入之间的关联可以用<code>AVCaptureConnection</code>对象来表示。捕获输入（<code>AVCaptureInput</code>实例）有一到多个输入端口（<code>AVCaptureInputPort</code>实例）。捕获输出（<code>AVCaptureOutPut</code>实例）可以接受一到多个数据源（比如，一个<code>AVCaptureMovieFileOutput</code>对象可以接收视频或音频数据）。</p>
<p>当你往一个session中加入一个输入或者一个输出的时候，这个session可以形成针对所有捕获输入端口和捕获输出的连接。一个捕获输入和捕获输出之间的连接可以被一个<code>AVCaptureConnection</code>对象来表示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-5fc693a0e896e075.png" alt="Capture Connection"></p>
<p>对于指定的输入或者输出，你可以使用一个capture connection来使能或者关闭其数据流。你也可以使用connection来检测一个音频频道的平均及最高的power level。</p>
<p><em>注：媒体捕获不支持同时捕获IOS设备的前置和后置摄像头。</em></p>
<h2 id="使用捕获Session来调节数据流"><a href="#使用捕获Session来调节数据流" class="headerlink" title="使用捕获Session来调节数据流"></a>使用捕获Session来调节数据流</h2><p>一个<code>AVCaptureSessin</code>对象是你用来管理数据捕获的关键调节对象。你可以使用一个实例来调节视频音频输入到输出的数据。你可以给这个session添加捕获设备，然后通过调用session的<code>startRuning</code>方法来开始这个数据流，并且通过调用<code>stopRunning</code>方法来结束数据流。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</div><div class="line"><span class="comment">// Add inputs and outputs.</span></div><div class="line">[session startRunning];</div></pre></td></tr></table></figure>
<h3 id="配置Session"><a href="#配置Session" class="headerlink" title="配置Session"></a>配置Session</h3><p>使用<code>preset</code>来对session配置你所喜欢的图片质量和分辨率。一个preset是一个常量，它表明了很多种可选配置方案中的一种；在某些情况下实际的配置和具体的设备是相关的。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-7fb0bd8bbe4ae251.png" alt="prest"></p>
<p>如果你要对针对某个屏幕大小做配置，你需要在设置前检测其是否支持：</p>
<pre><code>if ([session canSetSessionPreset:AVCaptureSessionPreset1280x720]) {
    session.sessionPreset = AVCaptureSessionPreset1280x720;
} else { 
    // Handle the failure.
}
</code></pre><p>如果你要使用preset，以便在一个更加细粒度得调整session的参数，或者你要对一个执行中的session做某些改动，那么你需要你需要将你的方法添加在<code>beginConfiguration</code>和<code>commitConfiguration</code>方法中间。<code>beginConfiguration</code>和<code>commitConfiguration</code>可以确保设备的改变作为一组，最小的能见度或者状态的不兼容行。在调用<code>beginConfiguration</code>之后，你可以添加或者移除输出，改变<code>sessionPreset</code>属性，或者单独配置捕捉输入属性。只有在触发了<code>commitConfiguration</code>之后所有的改变才会生效，并且这些改变将会同时生效。</p>
<pre><code class="objc">session beginConfiguration];
<span class="comment">// Remove an existing capture device.</span>
<span class="comment">// Add a new capture device.</span>
<span class="comment">// Reset the preset.</span>
[session commitConfiguration];
</code></pre>
<h3 id="检测Capture-Session的状态"><a href="#检测Capture-Session的状态" class="headerlink" title="检测Capture Session的状态"></a>检测Capture Session的状态</h3><p>Capture session会在它开始，停止运行或者被打断的时候发出通知，你可以观察这些通知一遍被告知。你可以通过注册<code>AVCaptureSessionRuntimeErrorNotification</code>来观察一个运行时错误。你也可以通过查询session的<code>running</code>属性来判断其是否正在运行，以及其<code>interrupted</code>属性来判断其是否被打断了。除此之外，<code>running</code>属性和<code>interrupted</code>属性都支持KVO，这个会在主线程中被触发。</p>
<h2 id="AVCaptureDevice对象代表一个输入设备"><a href="#AVCaptureDevice对象代表一个输入设备" class="headerlink" title="AVCaptureDevice对象代表一个输入设备"></a>AVCaptureDevice对象代表一个输入设备</h2><p>一个<code>AVCaptureDevice</code>对象时对一个物理捕获设备的抽象，该对象可以给<code>AVCaptureSession</code>对象提供输入数据（比如，音频或者视频）。每个对象代表了一种输入设备，比如两个视频输入（前置后置摄像头），一个音频输入（麦克风）。<br>你可以通过使用<code>AVCaptureDevice</code>类方法<code>devices</code>和<code>devicesWithMediaType</code>来找出当前可用的捕获设备。并且，如果有必要的话你可以找出某个iPhone，iPad或者iPod所提供的特性。尽管如此，可用设备的列表是可以变化的。当前的输入设备可能变得不可用（如果它们被另外的应用所使用），新的输入设备变得可用（如果它们被另外的设备所放弃）。你可以注册<code>AVCaptureDeviceWasConnectedNotification</code>和<code>AVCaptureDeviceWasDisconnectedNotification</code>通知，以便在可用设备变化时候被通知到。你可以使用一个capture input来讲一个输入设备添加到<code>capture session</code>中。</p>
<h2 id="设备属性"><a href="#设备属性" class="headerlink" title="设备属性"></a>设备属性</h2><p>你可以查询某个设备的不同属性。使用<code>hasMediaType:</code>和<code>supportsAVCaptureSessionPreset:</code>方法，你可以检测某个设备是否提供某种媒体类型或者支持一种给定的capture session preset。为了给用户提供有用的信息，你可以找出捕获设备的位置(它在检测单元的前面还是后面)，以及它本地化后的名字。如果你要给用户展示一个捕获列表来让其选择，那么这种方式是很有用的。</p>
<p>下图展示了后置（AVCaptureDevicePositionBack）和前置（AVCaptureDevicePositionFront）摄像头。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-b1a87fc70f2f3de3.png" alt="front and back facing camera position"></p>
<p>下面的例子遍历了所有的可用设备并且打印出它们的名字（对于视频设备来说，还有它们的位置）。</p>
<pre><code class="objc"><span class="built_in">NSArray</span> *devices = [<span class="built_in">AVCaptureDevice</span> devices];
  <span class="keyword">for</span> (<span class="built_in">AVCaptureDevice</span> *device <span class="keyword">in</span> devices) {
      <span class="built_in">NSLog</span>(<span class="string">@"Device name: %@"</span>, [device localizedName]);
      <span class="keyword">if</span> ([device hasMediaType:<span class="built_in">AVMediaTypeVideo</span>]) {
          <span class="keyword">if</span> ([device position] == <span class="built_in">AVCaptureDevicePositionBack</span>) {
              <span class="built_in">NSLog</span>(<span class="string">@"Device position : back"</span>);

} <span class="keyword">else</span> { 
<span class="built_in">NSLog</span>(<span class="string">@"Device position : front"</span>);
          }
} }
</code></pre>
<p>除此之外，你可以找出设备的模型ID以及其唯一标示。</p>
<h3 id="设备捕获设置"><a href="#设备捕获设置" class="headerlink" title="设备捕获设置"></a>设备捕获设置</h3><p>不同的设备有不同的功能，比如，某些设备支持聚焦和flash模式，某些可以支持聚焦到某个兴趣点。<br>下面的代码段展说明了怎样找到有手电筒模式的视频输入设备，并且它支持一个给定的capture session preset：</p>
<pre><code class="objc"><span class="built_in">NSArray</span> *devices = [<span class="built_in">AVCaptureDevice</span> devicesWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];
<span class="built_in">NSMutableArray</span> *torchDevices = [[<span class="built_in">NSMutableArray</span> alloc] init];
<span class="keyword">for</span> (<span class="built_in">AVCaptureDevice</span> *device <span class="keyword">in</span> devices) {
    [<span class="keyword">if</span> ([device hasTorch] &amp;&amp;
         [device supportsAVCaptureSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>]) {
        [torchDevices addObject:device];
} }
</code></pre>
<p>如果你发现很多设备满足你的标准，那么你可以让用户从中选择他们喜欢的来使用。为了给用户描述这个设备，你可以使用它的<code>localizedName</code>属性。<br>你可以用相似的方式来使用不同的特性。指明一种特定的模式方法是固定的，并且你可以查看设备是否支持某种特定模式。在某些情况下，你可以观察一个属性以便属性改变时候得到通知。任何情况下，在某种特定的特性下更改模式前要锁住设备，这在下文的<code>配置设备</code>小结中会有提及。</p>
<p><em>注：聚焦兴趣点和曝光兴趣点是彼此独立的，它们分别是focus mode和exposure mode。</em></p>
<h4 id="聚焦模式"><a href="#聚焦模式" class="headerlink" title="聚焦模式"></a>聚焦模式</h4><p>有三种聚焦模式：</p>
<ul>
<li><code>AVCaptureFocusModeLocked</code>：聚焦位置是固定的。当你想在锁住聚焦的情况下，让用户来组成场景那么这是很有用的。</li>
<li><code>AVCaptureFocusModeAutoFocus</code>：摄像头做一次扫描聚焦，然后返回到被锁住的状态。如果你想聚焦选中某个特定的物体，并且对那个物体保持聚焦（尽管那个物体可能不在拍摄场景中心），那么这种模式是很合适的。</li>
<li><code>AVCaptureFocusModeContinuousAutoFocus:</code>在这种模式下摄像头在需要的情况下持续地进行自动对焦。</li>
</ul>
<p>在利用<code>focusMode</code>属性来设置聚焦模式前，你可以使用<code>isFocusModeSupported:</code>方法来决定某个设备是否支持给定的聚焦模式。<br>除此之外，某种设备可能会支持对某个兴趣点的聚焦。你可以使用<code>focusPointOfInterestSupported</code>属性来做判断。如果支持的话，你可以使用<code>focusPointOfInterest</code>属性来设置聚焦点。你可以传递一个CGPoint值来指定聚焦的点，其中{0,0}代表左上角，{1,1}在水平模式home键在右侧的情况下。如果设备在竖直模式下，那么这种坐标关系也是适用的。</p>
<p>使用<code>adjustingFocus</code>属性来决定是否某个设备当前正在聚焦。使用KVO的形式，你可以再设备开始和停止聚焦的时候收到通知。</p>
<p>如果你改变了聚焦模式的设置，你可以像下面一样，将它们返回到默认设置：</p>
<pre><code class="objc"><span class="keyword">if</span> ([currentDevice isFocusModeSupported:<span class="built_in">AVCaptureFocusModeContinuousAutoFocus</span>]) {
    <span class="built_in">CGPoint</span> autofocusPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);
    [currentDevice setFocusPointOfInterest:autofocusPoint];
    [currentDevice setFocusMode:<span class="built_in">AVCaptureFocusModeContinuousAutoFocus</span>];
}
</code></pre>
<h4 id="曝光模式（Exposure-Modes）"><a href="#曝光模式（Exposure-Modes）" class="headerlink" title="曝光模式（Exposure Modes）"></a>曝光模式（Exposure Modes）</h4><p>曝光模式有以下两种：</p>
<ul>
<li><code>AVCaptureExposureModeContinuousAutoExposure：</code>在需要的情况下设备自动调整曝光水平。</li>
<li><code>AVCaptureExposureModeLocked：</code>在当前水平曝光水平是固定的。</li>
</ul>
<p>使用<code>isExposureModeSupported:</code>方法来决定是否某个设备支持某种给定的曝光模式，然后使用<code>exposureMode</code>属性来进行设定。</p>
<p>除此之外，某个设备可能会支持兴趣点的曝光。你可以使用<code>exposurePointOfInterestSupported</code>来特使其是否支持。如果支持的话，你可以使用<code>exposurePointOfInterest</code>属性来进行设置。你可以传递一个CGPoint值来指定聚焦的点，其中{0,0}代表左上角，{1,1}在水平模式home键在右侧的情况下。如果设备在竖直模式下，那么这种坐标关系也是适用的。<br>使用<code>adjustingExposure</code>属性来决定是否某个设备当前正在改变其曝光设置。使用KVO的形式，你可以再设备开始和停止曝光设置的时候收到通知。</p>
<p>如果你改变了曝光设置，那么你可以返回默认设置：</p>
<pre><code class="objc"><span class="keyword">if</span> ([currentDevice
isExposureModeSupported:<span class="built_in">AVCaptureExposureModeContinuousAutoExposure</span>]) {
    <span class="built_in">CGPoint</span> exposurePoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);
    [currentDevice setExposurePointOfInterest:exposurePoint];
    [currentDevice setExposureMode:<span class="built_in">AVCaptureExposureModeContinuousAutoExposure</span>];
}
</code></pre>
<h4 id="闪光灯模式"><a href="#闪光灯模式" class="headerlink" title="闪光灯模式"></a>闪光灯模式</h4><p>闪光灯模式又以下三种：</p>
<ul>
<li><code>AVCaptureFlashModeOff</code>：闪光灯不会开启</li>
<li><code>AVCaptureFlashModeOn</code>：闪光灯总是开启</li>
<li><code>AVCaptureFlashModeAuto</code>：设备会根据周围的光线环境来决定是否开启闪光灯</li>
</ul>
<p>使用<code>hasFlash</code>方法可以确定某个设备是否有闪光灯。如果返回是<code>YES</code>，然后你可以使用<code>isFlashModeSupported：</code>方法来判断其是否支持某种给定的闪光灯模式，最后使用<code>flashMode</code>属性来对其进行配置。</p>
<h4 id="手电筒模式"><a href="#手电筒模式" class="headerlink" title="手电筒模式"></a>手电筒模式</h4><p>在手电筒模式下，为了照亮视频捕捉，闪光灯是在低电耗的情况下持续打开的。一共有三种手电筒模式：</p>
<ul>
<li><code>AVCaptureTorchModeOff</code>：手电筒关闭</li>
<li><code>AVCaptureTorchModeOn</code>：手电筒总是打开</li>
<li><code>AVCaptureTorchModeAuto</code>：根据需要手电筒选择打开或者关闭</li>
</ul>
<p>你可以使用<code>hasTorch</code>属性来检测一个设备是否有手电筒。然后你可以使用<code>isTorchModeSupported:</code>方法来检测一个设备是否有给定的手电筒模式，然后通过<code>torchMode</code>属性来设置手电筒模式。<br>对于有手电筒的设备，如果设备和一个执行中的capture session相连接，那么这个手电筒就会被打开。</p>
<h4 id="视频防抖"><a href="#视频防抖" class="headerlink" title="视频防抖"></a>视频防抖</h4><p>依赖于具体的硬件设备，对于操作视频的连接，视频防抖是用的。尽管如此，并非所有的源格式和视频分辨率都支持视频防抖。</p>
<p>使能视频防抖可能会给视频捕捉Pipeline引入多余的延迟。可以使用<code>videoStabilizationEnabled</code>属性来检测视频防抖是否正在使用。<code>enablesVideoStabilizationWhenAvailable</code>属性可以在摄像头支持的情况下让应用自动的使能视频防抖。由于以上的限制，默认情况下视频防抖是被关闭的。</p>
<h4 id="白色平衡"><a href="#白色平衡" class="headerlink" title="白色平衡"></a>白色平衡</h4><p>有两种白色平衡模式：</p>
<ul>
<li><code>AVCaptureWhiteBalanceModeLocked</code>：白平衡模式是固定的。</li>
<li><code>AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance</code>：在需要的情况下，摄像头持续调整白平衡。</li>
</ul>
<p>你可以使用<code>isWhiteBalanceModeSupported:</code>方法来确定某个设备是否支持一种给定的白平衡，然后使用<code>whiteBalanceMode</code>属性来设置白屏模式。</p>
<p>你可以使用<code>adjustingWhiteBalance</code>属性来决定某个设备是否正在改变其白光模式的设定。你可以通过KVO来观察一个设备开始或者终止其白光设定。</p>
<h4 id="设置设备方向"><a href="#设置设备方向" class="headerlink" title="设置设备方向"></a>设置设备方向</h4><p>对于一个<code>AVCaptureConnection</code>，你可以给它设定指定的方向来指明你在<code>AVCaptureOutput</code>（AVCaptureMovieFileOutput，AVCaptureStillImageOutput 以及AVCaptureVideoDataOutput）中图片的朝向。</p>
<p>使用<code>AVCaptureConnectionsupportsVideoOrientation</code>属性来确定设备是否支持改变视频的方向，也可以使用<code>videoOrientation</code>属性来指明你想在输出端口中的指向。下面的代码指明了如何将一个<code>AVCaptureConnection</code>属性设定为<code>AVCaptureVideoOrientationLandscapeLeft:</code></p>
<pre><code class="objc"><span class="built_in">AVCaptureConnection</span> *captureConnection = &lt;<span class="meta">#A capture connection#&gt;;</span>
<span class="keyword">if</span> ([captureConnection isVideoOrientationSupported])
{
<span class="built_in">AVCaptureVideoOrientation</span> orientation = <span class="built_in">AVCaptureVideoOrientationLandscapeLeft</span>; [captureConnection setVideoOrientation:orientation]; 
}
</code></pre>
<h4 id="设置设备"><a href="#设置设备" class="headerlink" title="设置设备"></a>设置设备</h4><p>为了给设备设置一个捕获属性，你必须使用<code>lockForConfiguration：</code>属性来获取该设备的锁。这会避免其它应用对该属性做出不能兼容的改变。下面的代码片段说明了怎样在一个设备上改变其聚焦模式（首先确定是否该模式是被支持的），然后尝试锁住该设备来重新配置。如果这个锁是可获取的，那么聚焦模式就被改变，随后这个锁会被立即释放掉。</p>
<pre><code class="objc"><span class="keyword">if</span> ([device isFocusModeSupported:<span class="built_in">AVCaptureFocusModeLocked</span>]) {
    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
    <span class="keyword">if</span> ([device lockForConfiguration:&amp;error]) {
        device.focusMode = <span class="built_in">AVCaptureFocusModeLocked</span>;
        [device unlockForConfiguration];
    }
    <span class="keyword">else</span> {
        <span class="comment">// Respond to the failure as appropriate.</span>
}
</code></pre>
<p>只要你需要这个可设置的设备属性保持不变，那么你就应该持有这把设备锁。在非必要的情况下持有设备锁可能会降低其它应用的捕获质量。</p>
<h4 id="转换设备"><a href="#转换设备" class="headerlink" title="转换设备"></a>转换设备</h4><p>有时你可能想让用户在不同的输入设备间进行切换，比如，从使用前置摄像头到使用后置摄像头。为了避免暂停或者卡顿，你可以在运行状态下配置一个session，然而你需要将你的配置改变放在<code>beginConfiguration</code>和<code>commitConfiguration</code>之间。</p>
<pre><code class="objc"><span class="built_in">AVCaptureSession</span> *session = &lt;<span class="meta">#A capture session#&gt;;</span>
[session beginConfiguration];
[session removeInput:frontFacingCameraDeviceInput];
[session addInput:backFacingCameraDeviceInput];
[session commitConfiguration];
</code></pre>
<p>当最外面的<code>commitConfiguration</code>被触发时候，所有的改变会同时被执行。这就确保了平滑的转变。</p>
<h3 id="使用Capture-Inputs来给一个Session添加捕获设备"><a href="#使用Capture-Inputs来给一个Session添加捕获设备" class="headerlink" title="使用Capture Inputs来给一个Session添加捕获设备"></a>使用Capture Inputs来给一个Session添加捕获设备</h3><p>你可以使用一个<code>AVCaptureDeviceInput</code>（一个抽象<code>AVCaptureInput</code>类的子类）实例来给一个capture session添加一个捕获设备。</p>
<pre><code class="objc"><span class="built_in">NSError</span> *error;
<span class="built_in">AVCaptureDeviceInput</span> *input =
        [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];
<span class="keyword">if</span> (!input) {
    <span class="comment">// Handle the error appropriately.</span>
}
</code></pre>
<p>你可以使用<code>addInput:</code>来个一个session添加输入。如果合适的话，你可以使用<code>canAddInput</code>来确定某个捕获输入是否和现存的session是兼容的。</p>
<pre><code class="objc"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;<span class="meta">#Get a capture session#&gt;;</span>
  <span class="built_in">AVCaptureDeviceInput</span> *captureDeviceInput = &lt;<span class="meta">#Get a capture device input#&gt;;</span>
  <span class="keyword">if</span> ([captureSession canAddInput:captureDeviceInput]) {
      [captureSession addInput:captureDeviceInput];
  }
  <span class="keyword">else</span> {
      <span class="comment">// Handle the failure.</span>
}
</code></pre>
<p>如果想知道如何重新配置一个运行中的session，你可以查看上文中的<strong>Configuring a session</strong>中的细节。</p>
<p>一个<code>AVCaptureInput</code>可以给媒体数据提供多个流。比如，一个输入设备可以提供视频或者音频数据。每个输入提供的媒体流都是用AVCaptureInputPort来表示的。一个捕获session使用一个<code>AVCaptureConnection</code>对象来决定一组<code>AVCaptureInputPort</code>对象和一个<code>AVCaptureOutput</code>之间的映射。</p>
<h3 id="使用捕获输出来获取一个Session的输出"><a href="#使用捕获输出来获取一个Session的输出" class="headerlink" title="使用捕获输出来获取一个Session的输出"></a>使用捕获输出来获取一个Session的输出</h3><p>为了从一个捕获session中获取输出，你需要添加一个或者多个output。一个output是一个<code>AVCaptureOutput</code>子类的实例。你使用：</p>
<ul>
<li><code>AVCaptureMovieFileOutput</code>来输出一个视频文件</li>
<li>如果你想处理正在被捕获的视频的frame，比如，你要创建你自己的ViewLayer，那么你可以使用<code>AVCaptureVideoDataOutput</code></li>
<li>如果你要处理正在被捕获的音频你可以使用<code>AVCaptureAudioDataOutput</code></li>
<li>如果你要捕获静态图片以及元数据你可以使用<code>AVCaptureStillImageOutput</code></li>
</ul>
<p>使用<code>addOutput：</code>你可以给某个捕获session添加outputs。通过使用<code>canAddOutput</code>，你可以检测是否某个捕获输出和现存session相兼容。在某个session运行的过程中，你可以根据需要添加或者移除输出。</p>
<pre><code class="objc"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;<span class="meta">#Get a capture session#&gt;;</span>
<span class="built_in">AVCaptureMovieFileOutput</span> *movieOutput = &lt;<span class="meta">#Create and configure a movie output#&gt;;</span>
<span class="keyword">if</span> ([captureSession canAddOutput:movieOutput]) {
    [captureSession addOutput:movieOutput];
}
<span class="keyword">else</span> {
    <span class="comment">// Handle the failure.</span>
}
</code></pre>
<h4 id="保存视频文件"><a href="#保存视频文件" class="headerlink" title="保存视频文件"></a>保存视频文件</h4><p>你可以使用<code>AVCaptureMovieFileOutput</code>对象来将某个视频数据保存到文件中。（<code>AVCaptureMovieFileOutput</code>是<code>AVCaptureFileOutput</code>的子类，它定义了很多基本操作）。你可以对一个视频文件输出的很多方面做以配置，比如录制的最大时长，文件大小。如果可用的磁盘空间小于指定的值你可以禁止视频的录制。</p>
<pre><code class="objc"><span class="built_in">AVCaptureMovieFileOutput</span> *aMovieFileOutput = [[<span class="built_in">AVCaptureMovieFileOutput</span> alloc]
init];
<span class="built_in">CMTime</span> maxDuration = &lt;<span class="meta">#Create a CMTime to represent the maximum duration#&gt;;</span>
aMovieFileOutput.maxRecordedDuration = maxDuration;
aMovieFileOutput.minFreeDiskSpaceLimit = &lt;<span class="meta">#An appropriate minimum given the quality of the movie format and the duration#&gt;;</span>
</code></pre>
<p>视频输出的分辨率和比特率取决于一个捕获session的<code>sessionPreset</code>值。视频编码通常是H.264格式，音频编码通常是AAC格式。实际的数值可能根据设备的不同而改变。</p>
<h4 id="开始录制"><a href="#开始录制" class="headerlink" title="开始录制"></a>开始录制</h4><p>使用<code>startRecordingToOutputFileURL:recordingDelegate:</code>你可以开始录制一个QuickTime视频。你需要提供一个基于文件的URL以及一个代理。这个URL一定不能和已存在文件相同，因为视频文件输出不会覆盖已存在的资源。同时，你也需要获得往某个指定的路径下写文件的权限。代理必须遵守<code>AVCaptureFileOutputRecordingDelegate</code>协议，并且必须要实现<code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code>方法。</p>
<pre><code class="objc"><span class="built_in">AVCaptureMovieFileOutput</span> *aMovieFileOutput = &lt;<span class="meta">#Get a movie file output#&gt;;</span>
<span class="built_in">NSURL</span> *fileURL = &lt;<span class="meta">#A file URL that identifies the output location#&gt;;</span>
[aMovieFileOutput startRecordingToOutputFileURL:fileURL recordingDelegate:&lt;<span class="meta">#The</span>
delegate<span class="meta">#&gt;];</span>
</code></pre>
<p>在实现<code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code>代理方法的时候，代理可以往相册中写入录制的视频。这也可以检测可能出现的错误。</p>
<h4 id="确保文件被成功写入"><a href="#确保文件被成功写入" class="headerlink" title="确保文件被成功写入"></a>确保文件被成功写入</h4><p>在实现<code>captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:</code>方法的时候，为了确保文件是否被成功的写入了，你不仅仅需要检查error，还需要检查error的user info字典中<code>AVErrorRecordingSuccessfullyFinishedKey</code>的值：</p>
<pre><code class="objc">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)captureOutput
        didFinishRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)outputFileURL
        fromConnections:(<span class="built_in">NSArray</span> *)connections
        error:(<span class="built_in">NSError</span> *)error {
    <span class="built_in">BOOL</span> recordedSuccessfully = <span class="literal">YES</span>;
    <span class="keyword">if</span> ([error code] != noErr) {
        <span class="comment">// A problem occurred: Find out if the recording was successful.</span>
        <span class="keyword">id</span> value = [[error userInfo]
objectForKey:<span class="built_in">AVErrorRecordingSuccessfullyFinishedKey</span>];
        <span class="keyword">if</span> (value) {
            recordedSuccessfully = [value boolValue];
} } 
    <span class="comment">// Continue as appropriate...</span>
</code></pre>
<p>你需要检测user info字典中的key<code>AVErrorRecordingSuccessfullyFinishedKeykey</code>的值，因为尽管有错误，文件还是可以被存储成功。这个错误可能标志着你达到了某个视频录制的限制，比如，<code>AVErrorMaximumDurationReached</code>或者<code>AVErrorMaximumFileSizeReached</code>。其它可能导致录制停止的原因有：</p>
<ul>
<li>磁盘占满了：AVErrorDiskFull</li>
<li>录制设备断开连接了：AVErrorDeviceWasDisconnected</li>
<li>session被中止了（比如，收到了一个电话）：AVErrorSessionWasInterrupted </li>
</ul>
<h4 id="给文件添加元数据"><a href="#给文件添加元数据" class="headerlink" title="给文件添加元数据"></a>给文件添加元数据</h4><p>任何时候你都可以给一个视频文件设置元数据，甚至是在录制的时候。在某些场景下这时很有用的，比如当视频录制开始的时候信息不可以拿到，这可能因为位置信息造成的。某个输出文件的元数据是由一组<code>AVMetaDataItem</code>对象来表示的；你使用它可变子类的一个实例，<code>AVMutableMetadataItem</code>来创建一个你自己的元数据。</p>
<pre><code class="objc">VCaptureMovieFileOutput *aMovieFileOutput = &lt;<span class="meta">#Get a movie file output#&gt;;</span>
<span class="built_in">NSArray</span> *existingMetadataArray = aMovieFileOutput.metadata;
<span class="built_in">NSMutableArray</span> *newMetadataArray = <span class="literal">nil</span>;
<span class="keyword">if</span> (existingMetadataArray) {
    newMetadataArray = [existingMetadataArray mutableCopy];
}
<span class="keyword">else</span> {
    newMetadataArray = [[<span class="built_in">NSMutableArray</span> alloc] init];
} 
<span class="built_in">AVMutableMetadataItem</span> *item = [[<span class="built_in">AVMutableMetadataItem</span> alloc] init];
item.keySpace = <span class="built_in">AVMetadataKeySpaceCommon</span>;
item.key = <span class="built_in">AVMetadataCommonKeyLocation</span>;
<span class="built_in">CLLocation</span> *location - &lt;<span class="meta">#The location to set#&gt;;</span>
item.value = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%+08.4lf%+09.4lf/"</span>
    location.coordinate.latitude, location.coordinate.longitude];
[newMetadataArray addObject:item];
aMovieFileOutput.metadata = newMetadataArray;
</code></pre>
<h4 id="处理视频帧"><a href="#处理视频帧" class="headerlink" title="处理视频帧"></a>处理视频帧</h4><p>一个<code>AVCaptureVideoDataOutput</code>对象使用代理来处理视频帧。你可以通过<code>setSampleBufferDelegate:queue:</code>方法来设置代理。除了设置代理，你还可以指定该代理方法被调用的队列。你必须使用一个串行队列来确保传递给代理的帧是按照合适顺序进行的。你可以使用队列来改变既定的调度和处理视频帧的优先权。参考<code>SquareCam</code>来作为一个实现的例子。</p>
<p>在代理方法里，帧作为一个<code>CMSampleBufferRef</code>类型的实例来被表示<code>captureOutput:didOutputSampleBuffer:fromConnection:</code>。默认情况下，缓冲是以视频最有效的格式被发发出的。你可以使用<code>videoSettings</code>属性来指明一种定制的输出格式。视频的设定属性是一个字典；目前为止，唯一支持的key是<code>kCVPixelBufferPixelFormatTypeKey</code>。</p>
<p>推荐的像素格式是通过<code>availableVideoCVPixelFormatTypes</code>属性来返回的，同时<code>availableVideoCodecTypes</code>属性返回支持的数值。Core Graphics和OpenGL都和BGRA格式配合的很好。</p>
<pre><code class="objc"><span class="built_in">AVCaptureVideoDataOutput</span> *videoDataOutput = [<span class="built_in">AVCaptureVideoDataOutput</span> new];
<span class="built_in">NSDictionary</span> *newSettings =
                @{ (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey :
@(kCVPixelFormatType_32BGRA) };
videoDataOutput.videoSettings = newSettings;
 <span class="comment">// discard if the data output queue is blocked (as we process the still image</span>
[videoDataOutput setAlwaysDiscardsLateVideoFrames:<span class="literal">YES</span>];)
<span class="comment">// create a serial dispatch queue used for the sample buffer delegate as well as</span>
when a still image is captured
<span class="comment">// a serial dispatch queue must be used to guarantee that video frames will be</span>
delivered <span class="keyword">in</span> order
<span class="comment">// see the header doc for setSampleBufferDelegate:queue: for more information</span>
videoDataOutputQueue = dispatch_queue_create(<span class="string">"VideoDataOutputQueue"</span>,
DISPATCH_QUEUE_SERIAL);
[videoDataOutput setSampleBufferDelegate:<span class="keyword">self</span> queue:videoDataOutputQueue];
<span class="built_in">AVCaptureSession</span> *captureSession = &lt;<span class="meta">#The Capture Session#&gt;;</span>
<span class="keyword">if</span> ( [captureSession canAddOutput:videoDataOutput] )
     [captureSession addOutput:videoDataOutput];
</code></pre>
<h4 id="处理视频时考虑的性能因素"><a href="#处理视频时考虑的性能因素" class="headerlink" title="处理视频时考虑的性能因素"></a>处理视频时考虑的性能因素</h4><p>对于你的应用来说，你应该给这个session设置最低的可用分辨率。将输出设定到一个比需求更高的分辨率会浪费处理循环以及消耗更多的电量。<br>你必须确保你实现了<code>captureOutput:didOutputSampleBuffer:fromConnection</code>方法，以便在创建一帧的时候可以处理一个采样缓冲。如果这耗费过长的时间，并且你保持了这个视频帧率，那么AV Foundation对象就会停止传送帧，不尽停止给你的代理传递帧，还会停止向其它的输出传递帧，比如preview layer。<br>你可以使用捕获视频数据输出的<code>minFrameDuration</code>属性来确定你在没有被停止的情况下消耗更少的帧率，以便你有足够的时间来处理这一帧。你也许也要确保<code>alwaysDiscardsLateVideoFrames</code>属性也被设置成<code>YES</code>（默认情况下也是YES）。这个属性确保了任何延迟了的帧都会被丢弃而不是移交给你进行处理。换句话说，如果你正在录制视频，并且如果输出帧有些延迟不会造成影响，并且你想获取所有的帧，那么你可以将这个属性的值设定为NO。这并不意味这不会掉帧（也就是说，帧仍然会掉），但是它不会掉的那么早或者由于效率原因掉帧。</p>
<h3 id="捕获静态图片"><a href="#捕获静态图片" class="headerlink" title="捕获静态图片"></a>捕获静态图片</h3><p>如果你想捕获静态图片以及元数据，那么你可以使用<code>AVCaptureStillImageOutput</code>来输出。这个图片的分辨率取决于这个session的preset以及这个设备。</p>
<h4 id="像素和编码格式"><a href="#像素和编码格式" class="headerlink" title="像素和编码格式"></a>像素和编码格式</h4><p>不同的设备支持不同的图片格式。分别使用<code>availableImageDataCVPixelFormatTypes</code>和<code>availableImageDataCodecTypes</code>你可以找出某个设备支持的pixel和codec类型。每个方法会返回指定设备所支持数据的数组。你可以设置<code>outputSettings</code>字典来设置你所想要的图片格式，比如：</p>
<pre><code class="objc"><span class="built_in">AVCaptureStillImageOutput</span> *stillImageOutput = [[<span class="built_in">AVCaptureStillImageOutput</span> alloc]
init];
<span class="built_in">NSDictionary</span> *outputSettings = @{ <span class="built_in">AVVideoCodecKey</span> : <span class="built_in">AVVideoCodecJPEG</span>};
[stillImageOutput setOutputSettings:outputSettings];
</code></pre>
<p>如果你要获取一张JPEG格式的图片，那么你通常不需要指定你自己的压缩格式。相反，因为它的压缩格式是硬件驱动的，所以你应该让静态图片输出来给你压缩。尽管你改变了图片的元数据，如果你要得到一张图片的数据表示，那么你可以使用<code>jpegStillImageNSDataRepresentation:</code>来得到没有被再次压缩数据的<code>NSData</code>对象。</p>
<h4 id="捕获一张图片"><a href="#捕获一张图片" class="headerlink" title="捕获一张图片"></a>捕获一张图片</h4><p>当你想捕获一张图片的时候，你可以调用输出的captureStillImageAsynchronouslyFromConnection:completionHandler:方法。第一个参数是你为了捕获要用的连接。你需要找到这个连接，它的输入端是一个，它的输入端口正在搜集视频：</p>
<pre><code> AVCaptureConnection *videoConnection = nil;
  for (AVCaptureConnection *connection in stillImageOutput.connections) {
       for (AVCaptureInputPort *port in [connection inputPorts]) {
          if ([[port mediaType] isEqual:AVMediaTypeVideo] ) {
              videoConnection = connection;
break; } 
} 
      if (videoConnection) { break; }
     }
</code></pre><p><code>captureStillImageAsynchronouslyFromConnection:completionHandler:</code>方法的第二个参数是一个具有两个参数的block：一个包含了图片数据的<code>CMSampleBuffer</code>类和一个error。采样缓冲自身包含了比如EXIF字典等元数据作为其附属。如果你想你可以改变这个附属，但是要注意在<strong>像素和编码格式</strong>中提到的对JPEG图片的优化。</p>
<pre><code class="objc">[stillImageOutput captureStillImageAsynchronouslyFromConnection:videoConnection
completionHandler:
    ^(<span class="built_in">CMSampleBufferRef</span> imageSampleBuffer, <span class="built_in">NSError</span> *error) {
        <span class="built_in">CFDictionaryRef</span> exifAttachments =
            <span class="built_in">CMGetAttachment</span>(imageSampleBuffer, kCGImagePropertyExifDictionary,
<span class="literal">NULL</span>);
        <span class="keyword">if</span> (exifAttachments) {
            <span class="comment">// Do something with the attachments.</span>
        }
        <span class="comment">// Continue as appropriate.</span>
    }];
</code></pre>
<h3 id="展示录制的内容"><a href="#展示录制的内容" class="headerlink" title="展示录制的内容"></a>展示录制的内容</h3><p>你可以给用户提供视频录制的预览（利用preview layer）,或者音频录制的预览（通过监听音频channel）。</p>
<h4 id="视频预览"><a href="#视频预览" class="headerlink" title="视频预览"></a>视频预览</h4><p>使用<code>AVCaptureVideoPreviewLayer</code>对象，你可以给用户提供一个录制内容的预览。<code>AVCaptureVideoPreviewLayer</code>是<code>CALayer</code>的子类。为了展示预览，你不需要输出任何东西。</p>
<p>在视频展示给用户之前，使用<code>AVCaptureVideoDataOutput</code>类可以让客户端程序具有获取视频像素的能力。</p>
<p>和捕获输出不一样，一个视频预览layer保持一个对其关联session的一个强引用。这就确保了在该layer试图播放视频的时候session不会被释放。下面的代码展示了初始化一个预览layer的方式。</p>
<pre><code class="objc"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;<span class="meta">#Get a capture session#&gt;;</span>
<span class="built_in">CALayer</span> *viewLayer = &lt;<span class="meta">#Get a layer from the view in which you want to present the</span>
 preview<span class="meta">#&gt;;</span>
<span class="built_in">AVCaptureVideoPreviewLayer</span> *captureVideoPreviewLayer = [[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc] initWithSession:captureSession]; 
[viewLayer addSublayer:captureVideoPreviewLayer];
</code></pre>
<p>一般来说，这个preview layer在渲染树中和其它的CALayer对象是一样的。你可以像处理其它layer一样对图片进行伸缩，旋转等。其中有一个不同点是：为了指明来自摄像头的图片怎样旋转，你需要设置layer的<code>orientation</code>属性。除此之外，你可以通过查询<code>supportsVideoMirroring</code>属性来决定某个设备是否支持视频镜像。如果有需要你可以设置<code>videoMirrored</code>属性，尽管当<code>automaticallyAdjustsVideoMirroring</code>属性默认情况下是YES，这个镜像值基于session的配置而自动被设定的。</p>
<h4 id="视频重力模式"><a href="#视频重力模式" class="headerlink" title="视频重力模式"></a>视频重力模式</h4><p>这个preview layer支持三种重力模式，你可以通过<code>videoGravity</code>属性来设置：</p>
<ul>
<li><code>AVLayerVideoGravityResizeAspect</code>：这会按照固定的比例保存视频，当视频不能铺满整个可用屏幕大小的时候会留下黑条。</li>
<li><code>AVLayerVideoGravityResizeAspectFill</code>：这会保质视频的比例，但是会铺满整个屏幕，并且在需要的时候剪裁视频。</li>
<li><code>AVLayerVideoGravityResize</code>：这会拉伸视频来铺满整个可用的屏幕空间，尽管这样可能让图片扭曲。</li>
</ul>
<h4 id="给预览添加点击捕获功能"><a href="#给预览添加点击捕获功能" class="headerlink" title="给预览添加点击捕获功能"></a>给预览添加<code>点击捕获</code>功能</h4><p>在视频连接的时候，使用preview layer来实现点击捕获，你需要小心。你必须要考虑预览方向和layer的重力，以及这个预览可能被镜像的可能性。参考示例代码中IOS的<code>AVCam</code>项目来实现这个功能。</p>
<h3 id="展示音频等级（Audio-Level）"><a href="#展示音频等级（Audio-Level）" class="headerlink" title="展示音频等级（Audio Level）"></a>展示音频等级（Audio Level）</h3><p>为了在一个捕获连接中的音频通道中检测平均power和峰值power峰值，你可以使用<code>AVCaptureAudioChannel</code>对象。因为音频等级不是KVO的，所以你必须按照你需要的频率来访问其数值来更新UI（比如，每秒钟10次）。</p>
<pre><code class="objc"><span class="built_in">AVCaptureAudioDataOutput</span> *audioDataOutput = &lt;<span class="meta">#Get the audio data output#&gt;;</span>
<span class="built_in">NSArray</span> *connections = audioDataOutput.connections;
<span class="keyword">if</span> ([connections count] &gt; <span class="number">0</span>) {
    <span class="comment">// There should be only one connection to an AVCaptureAudioDataOutput.</span>
    <span class="built_in">AVCaptureConnection</span> *connection = [connections objectAtIndex:<span class="number">0</span>];
    <span class="built_in">NSArray</span> *audioChannels = connection.audioChannels;
    <span class="keyword">for</span> (<span class="built_in">AVCaptureAudioChannel</span> *channel <span class="keyword">in</span> audioChannels) {
        <span class="keyword">float</span> avg = channel.averagePowerLevel;
        <span class="keyword">float</span> peak = channel.peakHoldLevel;
        <span class="comment">// Update the level meter user interface.</span>
} }
</code></pre>
<h2 id="综合：像UIImage对象一样捕获视频帧"><a href="#综合：像UIImage对象一样捕获视频帧" class="headerlink" title="综合：像UIImage对象一样捕获视频帧"></a>综合：像UIImage对象一样捕获视频帧</h2><p>下面简明的代码实例向你展示了怎样捕获一个视频并且将你得到的视频帧转换成UIImage对象。它有以下的功能：</p>
<ul>
<li>创建一个<code>AVCaptureSession</code>对象来协调一个AV输入的数据流到一个输出</li>
<li>对你想要的输入类型找到<code>AVCaptureDevice</code>对象</li>
<li>给该设备创建一个<code>AVCaptureDeviceInput</code>对象</li>
<li>创建一个<code>AVCaptureVideoDataOutput</code>对象来产生视频帧</li>
<li>对<code>AVCaptureVideoDataOutput</code>对象实现一个代理对象来处理视频帧</li>
<li>实现一个方法来将该代理收到的<code>CMSampleBuffer</code>转换成一个UIImage对象</li>
</ul>
<h3 id="创建并且配置一个捕获Session"><a href="#创建并且配置一个捕获Session" class="headerlink" title="创建并且配置一个捕获Session"></a>创建并且配置一个捕获Session</h3><p>你可以使用<code>AVCaptureSession</code>对象来把来自一个AV输入设备的数据流来转换为一个输出。创建一个session，并且配置它来生成中等分辨率的视频帧：</p>
<pre><code class="objc"><span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];
session.sessionPreset = <span class="built_in">AVCaptureSessionPresetMedium</span>;
</code></pre>
<h3 id="创建配置设备及设备输入"><a href="#创建配置设备及设备输入" class="headerlink" title="创建配置设备及设备输入"></a>创建配置设备及设备输入</h3><p>捕获设备是由<code>AVCaptureDevice</code>对象表示的，该类提供了获取你想要的输入类型的方法。一个设备有一个或者多个端口，这些端口使用<code>AVCaptureInput</code>对象来配置。通常情况下，在它的默认配置上，你使用捕获输入。</p>
<p>找到一个视频捕获设备，然后利用该设备创建一个设备输入并且将其添加到session里面。如果一个合适的设备不能够被加载，那么<code>deviceInputWithDevice:error:</code>方法将会返回一个引用的错误。</p>
<pre><code class="objc"><span class="built_in">AVCaptureDevice</span> *device =
        [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];
<span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
<span class="built_in">AVCaptureDeviceInput</span> *input =
        [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];
<span class="keyword">if</span> (!input) {
    <span class="comment">// Handle the error appropriately.</span>
}
[session addInput:input];
</code></pre>
<h3 id="创建和配置视频输出数据"><a href="#创建和配置视频输出数据" class="headerlink" title="创建和配置视频输出数据"></a>创建和配置视频输出数据</h3><p>你使用一个<code>AVCaptureVideoDataOutput</code>对象来处理正在被捕获而未被压缩的帧。通常情况下，你可以配置一个输出的很多方面。比如，对于视频来说，你可以通过<code>videoSettings</code>属性来表明像素格式以及通过设置<code>minFrameDuration</code>属性来设置帧率的峰值。</p>
<p>创建和配置一个视频数据的输出并将其添加到session中，通过将<code>minFrameDuration</code>属性值设置为1/15来将帧率峰值设置为15fps：</p>
<pre><code class="objc"><span class="built_in">AVCaptureVideoDataOutput</span> *output = [[<span class="built_in">AVCaptureVideoDataOutput</span> alloc] init];
[session addOutput:output];
output.videoSettings =
                @{ (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey :
@(kCVPixelFormatType_32BGRA) };
output.minFrameDuration = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">15</span>);=
</code></pre>
<p>数据输出对象使用代理来提视频帧。这个代理必须遵守<code>AVCaptureVideoDataOutputSampleBufferDelegate</code>协议。当你设置数据输出代理的时候，你也必须提供一个回调将要被触发的队列。</p>
<pre><code class="objc"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"MyQueue"</span>, <span class="literal">NULL</span>);
[output setSampleBufferDelegate:<span class="keyword">self</span> queue:queue];
dispatch_release(queue);
</code></pre>
<p>你使用该队列改变给定的优先权来传递和处理视频帧。</p>
<h3 id="实现帧缓存的代理方法"><a href="#实现帧缓存的代理方法" class="headerlink" title="实现帧缓存的代理方法"></a>实现帧缓存的代理方法</h3><p>在该代理类里，实现<code>captureOutput:didOutputSampleBuffer:fromConnection:</code>方法，这个方法会在一个采样缓存被写入的时候被调用。视频数据的输出对象以<code>CMSampleBuffer</code>类型的形式来传递帧，因此，你需要将一个<code>CMSampleBuffer</code>对象转换为一个UIImage对象。这个转换的方法会在<code>Converting CMSampleBuffer to UIImage Object</code>中说明。</p>
<pre><code class="objc">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput
          didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer
          fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection {

      <span class="built_in">UIImage</span> *image = imageFromSampleBuffer(sampleBuffer);
     <span class="comment">// Add your code here that uses the image.</span>
 }
</code></pre>
<p>这个代理方法被触发的队列就是你在<code>setSampleBufferDelegate:queue:</code>中指明的队列；如果你要更新UI，那么你必须在主线程中执行相关的代码。</p>
<h3 id="开始和终止录制"><a href="#开始和终止录制" class="headerlink" title="开始和终止录制"></a>开始和终止录制</h3><p>在配置完capture session之后，你应该确保根据用户的偏好设置里你有录制视频的权限。</p>
<pre><code class="objc"><span class="built_in">NSString</span> *mediaType = <span class="built_in">AVMediaTypeVideo</span>
[<span class="built_in">AVCaptureDevice</span> requestAccessForMediaType:mediaType completionHandler:^(<span class="built_in">BOOL</span>
granted) {
    <span class="keyword">if</span> (granted)
    {
        <span class="comment">//Granted access to mediaType</span>
        [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">YES</span>];
    }
<span class="keyword">else</span> { 
        <span class="comment">//Not granted access to mediaType</span>
        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
        [[[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"AVCam!"</span>
message:<span class="string">@"AVCam doesn't have permission to use Camera, please change privacy settings"</span> 
}); } 
}]; 
                   delegate:<span class="keyword">self</span>
          cancelButtonTitle:<span class="string">@"OK"</span>
          otherButtonTitles:<span class="literal">nil</span>] show];
[<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">NO</span>];
</code></pre>
<p>如果摄像头的session被配置完成并且用户隐私设定允许使用摄像头，你可以调用<code>startRunning</code>方法来执行session在串行队列上的启动，以便主队列不会被阻塞（这可以让UI更加快速的被响应）。看iOS的AVCam作为一个实现的例子。</p>
<pre><code class="objc">[session startRunning];
</code></pre>
<p>通过调用<code>stopRunning</code>方法，你可以停止录制视频。</p>
<h3 id="高帧率的视频捕获"><a href="#高帧率的视频捕获" class="headerlink" title="高帧率的视频捕获"></a>高帧率的视频捕获</h3><p>在选中的硬件上，iOS7.0引入了高帧率的视频捕获（也称作”SloMo”视频）。所有的AV Foundation框架都支持高帧率的内容。<br>你可以使用<code>AVCaptureDeviceFormat</code>类来确定某个设备的捕获能力。该类也有返回诸如：所支持的媒体类型，帧率，视图的field，最大放大倍数以及视频防抖是否被支持等参数。</p>
<ul>
<li>捕获支持在60fps下全720p分辨率，其中包括视频防抖，可掉P帧（H264编码视频的特性，这种特性可以让视频播放很流畅，及时在老设备上也可以这样。）</li>
<li>视频播放可以提高音频对慢速和快速播放的支持，这就让音频的捕获时间（time pitch）可以在更低或者更高的速度下被保存。</li>
<li>在可变合成的中，可以支持缩放编辑。</li>
<li>在支持60fps视频的时候，输出提供了两种选择。可变的帧率，慢速或快速的移动，都会被保存或者视频帧率将会变得更小，比如30fps。</li>
</ul>
<h4 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h4><p>一个<code>AVPlayer</code>实例可以通过<code>setRate：</code>方法来自动设置大多数的播放速度。该数值会作为播放速度的一个放大倍数。1.0数值表示正常的播放，0.5数值表示以一半的速度播放，5.0数值表示以正常速度5倍的速度来播放。</p>
<p><code>AVPlayerItem</code>对象支持<code>audioTimePitchAlgorithm</code>属性。使用<code>Time Pitch Algorithm Settings</code>常量，该属性让你可以指明音频在不同帧率下的播放方式。<br>下表展示了所支持的time pitch算法，数量，该算法是否会造成音频在某个指定帧率下停止，以及每个算法支持的帧率范围。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-f751221f7dba579d.png" alt="Time Pitch Algorithm"></p>
<h4 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h4><p>编辑的时候，你可以使用<code>AVMutableComposition</code>类来建立临时的编辑。</p>
<ul>
<li>使用<code>composition</code>类方法来创建一个新的<code>AVMutableComposition</code>实例</li>
<li>使用<code>insertTimeRange:ofAsset:atTime:error</code>方法来插入你的视频asset</li>
<li>使用<code>scaleTimeRange:toDuration</code>来设定某个合成中某个部分的时间比例</li>
</ul>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>使用<code>AVAssetExportSession</code>类来导出60fps的视频输出一个asset。该内容可以用以下两种方式输出：</p>
<ul>
<li>使用<code>AVAssetExportPresetPassthrough</code>preset来避免视频的重编码。通过对标志为60fps的媒体片段进行时间重置，这些媒体片段就会减速或者加速。</li>
<li>为了最大播放兼容，使用恒定帧率输出。设定视频合成的<code>frameDuration</code>属性为30fps。你也可以通过设定导出session的<code>audioTimePitchAlgorithm</code>属性来指定捕获时间(time pitch)。</li>
</ul>
<h4 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h4><p>使用<code>AVCaptureMovieFileOutput</code>类，你可以捕获高帧率的视频，它自动支持高帧率捕获。它会自动选择正确的H264捕获水平。</p>
<p>为了使用定制的录制，你必须使用<code>AVAssetWriter</code>类，这需要额外的设置。</p>
<pre><code class="objc">assetWriterInput.expectsMediaDataInRealTime=<span class="literal">YES</span>;
</code></pre>
<p>该设置可以确保捕获可以和输入的数据保持同步。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="击水湘江" />
          <p class="site-author-name" itemprop="name">击水湘江</p>
           
              <p class="site-description motion-element" itemprop="description">努力让明天的自己爱上今天的自己！</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">击水湘江</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script>


  

</body>
</html>
