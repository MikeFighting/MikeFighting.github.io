<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.3">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT">


<meta name="description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:type" content="website">
<meta property="og:title" content="击水湘江">
<meta property="og:url" content="https://mikefighting.github.io/page/2/index.html">
<meta property="og:site_name" content="击水湘江">
<meta property="og:description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="击水湘江">
<meta name="twitter:description" content="努力让明天的自己爱上今天的自己！">






  <link rel="canonical" href="https://mikefighting.github.io/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>击水湘江</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">击水湘江</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Born To Fight!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/12/16/note-concurrency-in-practice-advance-3-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/16/note-concurrency-in-practice-advance-3-0/" itemprop="url">显式锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-16T10:59:57+08:00">2017-12-16</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="内置锁和显示锁"><a href="#内置锁和显示锁" class="headerlink" title="内置锁和显示锁"></a>内置锁和显示锁</h2><p>在Java5中<code>ReentrantLock</code>相比内置锁有很大的性能提升，但是在Java6中内置锁的性能有了很大的提升，他们的性能相差不大。并且由于<code>synchronized</code>是JVM的内置属性，所以它在未来可以进行更深层次的优化。<br>内置锁相比显式锁拥有以下的优势：</p>
<ul>
<li>结构更加紧凑</li>
<li>使用内置锁不用手动进行解锁，所以具有更低的危险性</li>
<li>在线程转储(thread dumps)过程中能给出哪些帧获取了哪些锁(<code>ReentrantLock</code>在Java6之后也支持)</li>
<li>可以检测和识别反生死锁的线程</li>
</ul>
<blockquote>
<p>当使用某些内置锁不能满足的高级功能时，比如：可定时的，可轮询的，可中断的锁，公平队列，以及非结构的锁时。则需要考虑使用<code>ReentrantLock</code>。</p>
</blockquote>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><p>公平锁就是说每个请求锁的线程按照先到先得的顺序获得锁，后到的线程在它前一个线程没有释放锁时是不能获取锁的，没有获取的锁的线程就被放到队列里挂起。非公平锁就是说每个请求锁的线程，如果发现该锁没有被占用就去请求锁，而不管其前面有没有线程在等待，这将提升吞吐量。由于线程的挂起和重新唤醒，线程的调度会带来很大的性能损耗，所以，如果请求锁的平均时间间隔非常短，那么最好使用非公平锁。反之，如果持有锁的时间较长，或者请求锁的时间间隔较长，那么性能的瓶颈就不在切换线程上了，这时就应该使用公平锁，使用非公平锁”插队”的方式所带来吞吐量的提升将会是非常微弱的。内置锁和<code>ReentrantLock</code>都没有提供确定的公平性保证，因为一般来说实现总体的公平性已经足够了。</p>
<h2 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h2><p>首先为什么会出现条件队列呢？我们知道要保证某个多线程的方法被调用成功可以使用线程休眠的方式，但是这种方式会有问题：如果休眠的时间过短，那么会导致CPU的资源消耗过高，如果休眠的时间很长，这时如果其它某个线程修改了判断条件，这时休眠的线程不能及时响应，只有在休眠之后才会响应。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepyBoundedBuffer</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SleepyBoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isFull()) &#123;</span><br><span class="line">            doPut(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     Thread.sleep( SLEEP_GRANULARITY );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty())</span><br><span class="line">            <span class="keyword">return</span> doTake();</span><br><span class="line">    &#125;</span><br><span class="line">     Thread.sleep( SLEEP_GRANULARITY ); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>使用条件队列就可以解决这种问题：条件队列就是说在条件不满足时候线程休眠(调用wait方法)，当条件满足的时候线程会收到通知并且被唤醒(调用notify方法)，这样就不会产生多余的开销。<br><br>调用<code>wait</code>方法之后会发生以下事情：</p>
<ol>
<li>释放锁</li>
<li>阻塞当前线程并等待直到超时</li>
<li>线程被终端或者被一个通知唤醒</li>
<li>唤醒后，wait在返回前还要重新获取锁</li>
</ol>
<p>在步骤3和步骤4之间可能有另外一个线程获取了锁，并且改变了对象的标志，这个时候其实条件已经变成假的了。或者这个被唤醒的原因并不是条件变成了真，而是其它的线程的某个条件变成了真，那个线程调用了notify或者notifyAll方法。所以说即使线程被notify唤醒了，并不一定是因为条件满足了，所以在唤醒之后还要继续检查条件，这时要将wati放在一个。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stateDependentMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// condition predicate must be guarded by lock</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line"><span class="keyword">while</span> (!conditionPredicate())&#123;</span><br><span class="line">    lock.wait();</span><br><span class="line">    <span class="comment">// object is now in desired state</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/12/14/note-java-concurrency-in-practice-2-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/14/note-java-concurrency-in-practice-2-2/" itemprop="url">Java并发编程-性能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-14T16:52:07+08:00">2017-12-14</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>并发的目的就是提高系统的性能和响应速度，但是这些都要建立在安全性的基础之上的，也就是说先要保证系统能够正常的运行，满足现有的业务需求，然后再考虑性能。并且在提升性能的同时往往会增加系统的复杂性，因为很多性能的优化需要牺牲掉代码的可理解性和面向对象的原则（同时可能会出现活跃性的问题），增加系统的维护成本，并且有时不会增加系统的性能反而会降低系统的性能。</p>
<h2 id="多线程带来的开销"><a href="#多线程带来的开销" class="headerlink" title="多线程带来的开销"></a>多线程带来的开销</h2><p>多线程的引入会造成一些额外的开销，比如：线程的创建和销毁，线程的调度，上下文的切换，线程之间的协调（例如加锁，触发信号以及内存同步）。如果这些性能开销大于吞吐量，响应性所带来的性能提升那么就会得不偿失。</p>
<h2 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h2><p>什么是可伸缩性？可伸缩性指的是通过增加计算机的资源（例如CPU，内存，存储容量或IO带宽），程序的吞吐量或者处理能力能相应的增加。但是这种伸缩性往往是有极限的，比如下面提到的Amdahl定律。</p>
<h2 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h2><p>增加CPU的个数也不能一直提高性能。Amdahl定律就指明了这一点：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-d38318f874db2020.png" alt="Amdahl公式"><br>在这个公式中：<em>F表示串行执行的部分占所有部分的比重，N代处理器的个数，最后的结果代表和单一处理器时速度的比例。</em>我们假设两个极限：</p>
<ul>
<li>在处理器个数等于一时，其数值是1，也就是说它的速度没有提升。</li>
<li>在处理器个数为正无穷的时候，其数值为1/F。</li>
</ul>
<p>所以只提高处理器的个数是不不能一直提高执行速度的。我们来举个例子：</p>
<p>放假了班主任给小明同学布置了两份作业：</p>
<p>一、9张英语作业：将英语单词第一单元抄写九遍<br>二、数学第二单元的课后习题做完</p>
<p>假设做数学习题所用的时间是1小时，写英语单词的时间为每单元1小时，所以说如果有小明一个人来做需要10个小时才能完成。小明很贪玩，到了周日晚上才发现自己作业没有写，小明急了，于是就找同学帮他写英语单词，因为英语单词是抄写9份，所以他找了9个小伙伴给他抄，他自己做数学习题（假设数学题不能多个人来做），这样本来是个小时完成的任务，小明最后用了2小时完成了，按照Amdahl定律，其F是0.1，N是10，所以最后的数值是5.26倍。然后我们假设小明有无数个小伙伴都来帮他抄写英语单词，那么最后他需要的时间就接近于1小时，做以按照Amdahl定律，其F实0.1，N是正无穷，所以最后数值是10，也就是说他的速度是原来的10倍。也就是说无论他找多少个小伙伴都不能突破一小时的时间，<strong>因为这一小时只能是串行执行的，不能由其他的处理器来协助完成。</strong></p>
<p>然而要能够使用Amdahl定律需要首先估算出串行执行的部分所占的比例。<br>同时如果增加了处理器的个数，那么每个处理器的利用率都会下降，其中串行所占比例越重的系统，其利用率下降的越厉害。</p>
<h2 id="内存的同步"><a href="#内存的同步" class="headerlink" title="内存的同步"></a>内存的同步</h2><p>在使用<code>synchronized</code>和<code>volatile</code>以提供可见性的同时也引入了需要内存同步的问题，因为其使用了内存栅栏（Memory Barrier），使用内存栅栏是可以刷新缓存，使得缓存无效的。某个线程的同步会影响到其它线程的性能，因为同不会增加内存总线上的通信量，总线的带宽是有限的，并且所有处理器都共享这个带宽。但是现在的JVM会对代码做相应的优化，比如下面两段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">new</span> Object()) &#123;</span><br><span class="line">           <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里永远不会有任何两个线程会去竞争这个锁的，因为每次进入这个方法都会新建一把锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getStoogeNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; stooges = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">stooges.add(<span class="string">"Moe"</span>);</span><br><span class="line">stooges.add(<span class="string">"Larry"</span>);</span><br><span class="line">stooges.add(<span class="string">"Curly"</span>);</span><br><span class="line"><span class="keyword">return</span> stooges.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用<code>Vector</code>可能会进行四次获取锁和释放锁的操作，但是由于这个<code>stooges</code>是一个局部变量，局部变量是属于线程栈的，每个线程中的不一样，所以没有必要加锁。在这两种情况下，如果编译器够智能，就会进行优化从而去掉锁。并且如果编译器没有进行逸出分析，那么也可能进行锁的粒度粗化。也就是说将原来需要加四次锁的地方改为加一次锁。也就是说再非竞争同步的时候，我们就不必担心，JVM已经帮我们做了优化，我们需要关心的就是可能引发竞争的地方。</p>
<blockquote>
<p>在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。</p>
</blockquote>
<h2 id="锁分段和减少锁的粒度"><a href="#锁分段和减少锁的粒度" class="headerlink" title="锁分段和减少锁的粒度"></a>锁分段和减少锁的粒度</h2><p>锁分段的意思是有一个数据集合A,B,C,D,那么线程T1和线程T2一般情况不会同时访问A，而是访问不同的数据，所以在T1和T2访问不同的数据时就是没有必要加锁的，这时可以根据数据集合的量配置若干个锁，比如ConcurrentHashMap中使用的是16个锁来增大吞吐量。而减少锁的粒度是如果之前很多个资源都用同一个锁，并且各个资源之间没有相互的依赖，那么可以将原来的一个锁变为多个锁。锁分段往往将锁放入Collection中，而减少锁的粒度往往是声明若干个锁。<em>其实锁分段也是一种减少锁粒度的方式。</em></p>
<h2 id="不能滥用对象池"><a href="#不能滥用对象池" class="headerlink" title="不能滥用对象池"></a>不能滥用对象池</h2><p>有时候某个对象会重复的使用，我们为了不重新new对象（事实上Java的分配操作要比C语言的malloc的调用速度还要快）以及垃圾回收带来的开销，常常会建一个池子将已经创建的对象保存进池子以备后用。但是这样做需要考虑以下几点：对象池的大小很重要，如果对象池很小，那么将不会起到相应的作用；如果对象池很大，那么将会占用很多内存资源，这会对垃圾回收器带来压力。如果用在多线程，那么会造成更加严重的性能问题，因为如果不用线程池，那么每个新建的对象就会在线程本地的内存块中。如果使用多线程，那么情况会更加糟糕，因为需要协调每个线程之间的调用，在协调的过程中可能导致某个线程的死锁。并且多个线程之间的同步，如果使用锁，那么及时没有竞争，只是加锁和解锁所带来的性能损耗要比new对象带来的损耗大得多。这看似一个性能优化的技术点，但实际上会导致可伸缩性的问题。</p>
<blockquote>
<p>同步的开销要比new对象的开销少的得多。</p>
</blockquote>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>上下文切换是什么？<br>锁竞争的过程中会发生上下文切换，越多的上下文切换将会造成越低的吞吐量。如果某个执行IO操作的线程被阻塞了，同时这个线程还持有一把锁，那么如果有越来越多的线程来请求这个锁，也将被阻塞而挂起，这就会增加上下文切换的次数。所以要尽量减少持有锁的时间来减少上下文切换。</p>
<p>参考资料：</p>
<ol>
<li><p><a href="https://stackoverflow.com/questions/5440128/thread-context-switch-vs-process-context-switch" target="_blank" rel="noopener">线程上下文切换和进程上下文</a></p>
</li>
<li><p><a href="http://www.linfo.org/context_switch.html" target="_blank" rel="noopener">上下文切换的定义</a></p>
</li>
<li></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/12/12/note-java-concurrency-in-practice-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/12/note-java-concurrency-in-practice-2/" itemprop="url">Java中的活跃性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-12T13:15:34+08:00">2017-12-12</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在多线程开发中，我们往往为了安全性而去加锁，如果锁过多，就可能出现<strong>顺序死锁</strong>。如果不适用锁，使用信号量和线程池来限制对资源的访问，那么又可能出现<strong>资源死锁</strong>。那么究竟怎样判断死锁？死锁的种类都有哪些？怎样避免死锁呢?</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>我们如果把每个线程都想像成有向图中的一个点，如果线程A等待线程B所占用的资源，那么就从A向B画一条直线，如果最终这个图形成了一个环形，那么就出现了资源的相互依赖，就造成了死锁。</p>
<h2 id="死锁之后的处理形式"><a href="#死锁之后的处理形式" class="headerlink" title="死锁之后的处理形式"></a>死锁之后的处理形式</h2><p>死锁之后该怎么处理分为两种方式，第一种方式就是什么都不做不了，应用程序将到此结束（也可能是某个子系统停止或者性能降低），直到重新启动，才会解除本次死锁。第二种方式就是干涉死锁。比如数据库操作在两个事务之间出现了死锁，那么数据库服务器会选择一个牺牲者并且放弃这个事务。作为牺牲者的事务将放弃它的所有资源，从而使其它事务继续进行。让后等待其它任务执行完成之后再去执行这个被牺牲了的任务。</p>
<h2 id="顺序死锁"><a href="#顺序死锁" class="headerlink" title="顺序死锁"></a>顺序死锁</h2><p>如果有left和right两把锁，同时有A线程和B线程去访问，如果按照下面的顺序就可能造成死锁。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-56118e0094e4a64d.png" alt="order_dead_lock"></p>
<p>线程A持有了left锁，再获取了right锁的时候才可以进行下一步的执行，并且只有获得了right锁才可以释放掉left锁。线程B已经获取了right锁，在获取了left锁的时候才可以进行下一步的执行，也只有获取了right锁才可能释放掉right锁。所以就造成了最后的死锁。这个死锁引起的原因就是锁的顺序不一致，也就是说在使用锁进行同步的过程中如果有两把锁，那么锁的顺序需要保持一致，否则就可能造成死锁。代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftRightDeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object left = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object right = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(left) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(right) &#123;</span><br><span class="line">                doSomething();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(right) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(left) &#123;</span><br><span class="line">                doSomethingElse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态的锁顺序死锁"><a href="#动态的锁顺序死锁" class="headerlink" title="动态的锁顺序死锁"></a>动态的锁顺序死锁</h2><p>有些时候我们没有很明确的在两个不同的方法中使用两把锁，但是仍然可能造成死锁，这种死锁往往不容易被发现，比如我们要给将账户A的钱转给账户B，那么我们可以使用下面的方法来确保转账的原子性，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account fromAccount, Account toAccount,</span></span></span><br><span class="line"><span class="function"><span class="params">DollarAmount amount)</span> <span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (fromAccount) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (toAccount) &#123;</span><br><span class="line"><span class="keyword">if</span> (fromAccount.getBalance().compareTo(amount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    fromAccount.debit(amount); toAccount.credit(amount);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个死锁的原因就是可能调用方在两个线程中使用的参数顺序可能相反，这就造成死锁，因为我们不能确定调用方是怎么调用我们写的接口的。比如下面的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: transferMoney(myAccount, yourAccount,<span class="number">10</span>);</span><br><span class="line">B: transferMoney(yourAccount, myAccount,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>这时就造成了死锁，并且这种死锁是在一般情况下是不会发生的，这就造成了难以排查的错误。这时该如何去做呢？我们的目的是想让外界两个参数的改变不会影响到内部锁的顺序，所以，我们可以拿两个入参的<code>identityHashCode</code>去作为判断条件，根据hash值的大小来改变加锁的顺序。当然，这里面可能有哈希碰撞的情况（这种情况发生的几率是非常低的），如果有这种情况的出现，那么就给这两个同步操作外部再加一个锁，这样来确保这个操作的原子性，就不会有死锁的情况了。这里面如果加锁的两个对象有唯一的键值，那么就可以直接用其键值，这样就不必再使用额外的锁了。</p>
<h2 id="协作对象之间发生的死锁"><a href="#协作对象之间发生的死锁" class="headerlink" title="协作对象之间发生的死锁"></a>协作对象之间发生的死锁</h2><p>比如下面的Taxi和Dispatcher对象都使用了锁，并且它们之前是相互协作的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> Point location, destination; <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Taxi</span><span class="params">(Dispatcher dispatcher)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> location;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.location = location;</span><br><span class="line"><span class="keyword">if</span> (location.equals(destination)) &#123;</span><br><span class="line">    dispatcher .notifyAvailable (<span class="keyword">this</span> );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis; <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;(); availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">        availableTaxis .add(taxi);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Image image = <span class="keyword">new</span> Image();</span><br><span class="line">    <span class="keyword">for</span> (Taxi t : taxis) &#123;</span><br><span class="line">     image.drawMarker(t.getLocation()); <span class="keyword">return</span> image;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里面<code>setLocation</code>方法需要先获取<code>Taxi</code>的锁，再获取<code>Dispatcher</code>的锁。而<code>getImage</code>方法需要先获取<code>Dispatcher</code>的锁，然后再获取<code>Taxi</code>的锁，这样就可能造成上文中所说的顺序锁的问题。并且这种锁是更加难以排查的。所以最好不要使用<code>synchronize</code>(管程)。</p>
<blockquote>
<p>在持有锁的过程中调用某个外部方法，那么将可能会出现活跃性的问题。</p>
</blockquote>
<h2 id="丢失信号死锁"><a href="#丢失信号死锁" class="headerlink" title="丢失信号死锁"></a>丢失信号死锁</h2><p>多线程访问某个资源，在有条件谓词作为前置条件，如果条件为假，那么我们会调用wait方法将线程阻塞。如果某个线程将条件变为了真，并且这个wait的线程没有收到这个信号。那么原来wait的线程将会永远等待下去，进而导致死锁。也就是说，线程A通知了一个条件队列，而线程B随后进入这个条件队列，但是线程B将被阻塞而不能执行，因为其需要等待另外一个通知的到来。</p>
<h2 id="开放调用"><a href="#开放调用" class="headerlink" title="开放调用"></a>开放调用</h2><p>之所以出现上述协作对象之间发生的死锁，是因为在调用另外一个对象的方法的过程中，已经持有了一把锁。这种调用称作不开放，所谓的开放调用就是指：在调用某个方法的时候不需要持有锁。通常来说开放调用要比非开放调用更加安全，更加不容易产生死锁，所以我们要尽可能地使用开放调用。我们可以使用开放调用的方法来解决上述遇到的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="keyword">private</span> Point location, destination; <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> location;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(Point location)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> reachedDestination; <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">this</span>.location = location;</span><br><span class="line">    reachedDestination = location.equals(destination);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (reachedDestination) &#123;</span><br><span class="line">    dispatcher .notifyAvailable (<span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; taxis;</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>) <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">availableTaxis .add(taxi); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Image <span class="title">getImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;Taxi&gt; copy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">copy = <span class="keyword">new</span> HashSet&lt;Taxi&gt;(taxis);</span><br><span class="line">&#125;</span><br><span class="line">Image image = <span class="keyword">new</span> Image(); <span class="keyword">for</span> (Taxi t : copy)</span><br><span class="line">image.drawMarker(t.getLocation()); <span class="keyword">return</span> image;</span><br></pre></td></tr></table></figure>

<p>这样就可以将多个锁区分开来，从而在多个对象调用的时候就不会死锁了。</p>
<h2 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h2><p>资源死锁的起因也是由于访问资源的原子性和访问资源的顺序所造成的互相牵制。比如：线程A已经建立了和数据库D1的链接，正在尝试连接数据库D2；与此同时，线程B已经建立了和数据库D2的连接，正在尝试连接数据库D1。这时就造成了资源死锁。（当然这和数据库同时连接的个数，以及资源的大小有关。资源越大，连接的个数越多，那么出现死锁的可能性就越少。）<br>在资源死锁中，还有一种线程饥饿死锁的情况，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDeadlock</span> </span>&#123;</span><br><span class="line">ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderPageTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Future&lt;String&gt; header, footer;</span><br><span class="line">        header = exec.submit(<span class="keyword">new</span> LoadFileTask(<span class="string">"header.html"</span>));</span><br><span class="line">        footer = exec.submit(<span class="keyword">new</span> LoadFileTask(<span class="string">"footer.html"</span>));</span><br><span class="line">        String page = renderBody();</span><br><span class="line">        <span class="comment">// Will deadlock -- task waiting for result of subtask</span></span><br><span class="line">        <span class="keyword">return</span> header.get() + page + footer.get();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会出现死锁，因为<code>header.get()</code>和<code>fotter.get()</code>是阻塞的，它将会等待exec执行完毕，而exec想要执行必须要等到<code>header.get() + page + footer.get();</code>执行完毕，这样就造成了线程饥饿死锁。(RenderPageTask是任务1，header.get() + page + footer.get()是任务2)。</p>
<h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>饥饿就是指某个线程始终不能获取其所需要的资源，导致它不能继续执行，引起饥饿的最常见资源就是CPU的时钟周期。Java中提供了10中线程的优先级，然而对应到操作系统中，可能某些优先级会重合（因为操作系统可能没有这么多的优先级）。并且设置线程的优先级可能不会起到明显的效果，反而可能因为优先级翻转而造成死锁，所以我们尽量不要去改动线程的优先级。但是这种情况也不是绝对的，比如有一个CPU密集的后台任务在执行，那么这个任务很可能会和主线程去抢占CPU资源，从而导致主线程响应性降低，为了解决这个问题，我们可以将后台线程的优先级降低，从而提高主线程的响应性。</p>
<blockquote>
<p>尽量避免使用线程优先级，因为这会增加平台依赖性，并且可能会导致活跃性问题。在大多数并发应用程序中，都应该使用默认的线程优先级。</p>
</blockquote>
<h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>活锁是指没有发生死锁，但是程序一直在重试，并且重试一直错误，导致程序不能正常往下执行。（产生这种情况的原因是对错误的估计不对：本来是不能解决的错误，却以为可以通过重试解决）。<br>同时，多个线程之间的协作也可能造成死锁，因为可能两个协作的线程都对彼此进行响应，响应完之后使得任何一个线程都不能继续执行，解决这种活锁的问题可以通过在重试机制中引入随机性，也就是说某个重试完之后，另一个线程在随机的时间段之后再进行重试，从而避免了和之前线程的碰撞。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/12/01/note-java-concurrency-in-practice-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/01/note-java-concurrency-in-practice-1/" itemprop="url">Java结构化并发应用程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-01T20:50:39+08:00">2017-12-01</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java结构化并发应用程序"><a href="#Java结构化并发应用程序" class="headerlink" title="Java结构化并发应用程序"></a>Java结构化并发应用程序</h1><h2 id="线程池和队列的关系"><a href="#线程池和队列的关系" class="headerlink" title="线程池和队列的关系"></a>线程池和队列的关系</h2><p>线程池和队列之间的关系是很紧密的。队列是用来放任务的，它有并行和串行之分。其中并行队列中的任务可以并发的执行；串行队列中的任务只能按照顺序一个一个执行，正是因为这个原因，串行队列也可以实现线程安全，也可以作为锁来用。而线程池就是很多的线程的容器，这些线程负责从队列中取出任务执行任务并且返回线程池以等待下个任务的到来。<br>在Java中通常会有如下几种创建线程池的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> <span class="comment">// 创建的线程数量是固定的</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> <span class="comment">// 利用所有可用的处理器资源创建一个'工作密取'的线程池</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> <span class="comment">// 创建一个单线程的线程池，放入线程池中的任务顺序执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> <span class="comment">// 创建一个缓存的线程池，如果之前有可用的线程就用，如果没有就重新创建，如果执行的任务量小并且多的时候用这个线程池会提高性能。如果一个线程在60s之内没有被使用，那么这个线程将会被中断并且被移除线程池。所以说如果这个线程池如果一直是idel状态的时候，那么它不会消耗任何的资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledExecutor</span><span class="params">()</span> <span class="comment">// 创建一个具有定时功能的线程池</span></span></span><br><span class="line"><span class="function"><span class="comment">//...</span></span></span><br></pre></td></tr></table></figure>

<p>在IOS开发中GCD就是典型的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>

<p>这个函数调用时候是这样子的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> concruntQueue = dispatch_queue_create(<span class="string">"come.mike.fighting0.com"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(concruntQueue, ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"我正在做一项耗时的任务"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>这段代码就是说吧一个耗时的任务放到了一个并行的队列中，然后调用<code>dispatch_async</code>，在调用这个方法时系统会自动的给我们创建好一个线程池并且从其中取出一个线程，来执行我们的任务。这样，我们就不用自己再去创建并管理线程了，避免了不必要的错误并且避免了频繁创建线程所带来的开销，同时避免了任务到来的时候再去创建线程从而造成一定程度的响应延迟。</p>
<h2 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h2><p><code>Executor</code>的创建在上文中已经说明了，下面说下它的关闭。<code>Executor</code>的终止方式有以下两种：</p>
<ul>
<li>缓慢关闭，让已经执行的任务执行完毕，然后不再接受正在等待的任务或者新来的其它任务(<code>shutdown</code>方法)</li>
<li>暴力关闭，直接关闭线程池，不管已经执行的任务(<code>shutdownNow</code>方法)</li>
</ul>
<h2 id="Timer和SecheduledThreadPoolExecutor的对比"><a href="#Timer和SecheduledThreadPoolExecutor的对比" class="headerlink" title="Timer和SecheduledThreadPoolExecutor的对比"></a>Timer和SecheduledThreadPoolExecutor的对比</h2><blockquote>
<p>因为Timer的调度机制是基于绝对时间而不是相对时间的，因此任务的执行对系统的时钟很敏感，而<code>SecheduledThreadPoolExecutor</code>是基于相对时间调度的，所以更加准确。<br></p>
</blockquote>
<ul>
<li>Timer会将所有的定时任务都放到一个线程中去执行，所以如果某个任务的执行时间长于所设定的时间间隔那么这个Timer就会不准确。而线程池就能很好的解决这个问题，因为它是在多个线程中执行不同的任务的，所以各个任务之间彼此没有影响。</li>
<li>TimerTask如果抛出一个异常，那么Timer不会处理它，反而会终止所有的任务，包括正在执行的任务和将要执行的任务。在这之后也没有可以恢复Timer的方式。</li>
</ul>
<p>那么问题来了，在Java中如果要实现自己的调度任务不使用Timer，该使用什么呢？应该使用<code>DelayQueue</code>，它内部的每个对象都有一个延迟时间的方法。</p>
<h2 id="任务和线程处理中断的方式"><a href="#任务和线程处理中断的方式" class="headerlink" title="任务和线程处理中断的方式"></a>任务和线程处理中断的方式</h2><p>虽然每个任务都在一个线程中执行，但是这个线程并不被这个任务所拥有。拥有这个线程和管理这个线程的<em>主人</em>是线程池，所以在遇到中断的时候，通常会将其抛出，然后让上层的代码来处理中断。举个例子：你在一个朋友家玩耍，这时忽然来了一个收租金的人大吵大闹要交房租（中断），这时你不应该处理，而是应该保留这个现场，并且把问题抛给你的朋友，因为这是他的家。这也就是什么很多阻塞库框架都会在遇到中断的时候抛出来<code>InterruptedException</code>，以便上层代码进行处理（尽快的退出，并且将中断尽快的传递给上层也是最温和的响应策略）。也就是说任务本身对中断不应该做任何的处理，不应该对中断策略做任何的假想，除非这个框架的中断处理策略已经定了，不需要再将中断抛给上层代码了。除了将中断传递给上层的调用者之外，任务还需要保存中断的状态，以备后续上层代码的处理，保存状态的方式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().interrupt();</span><br></pre></td></tr></table></figure>

<p>调用之后就会保持线程的中断状态，恢复中断状态的目的就是让调用栈中更高层的代码看到引发了一个中断，并且这个线程的状态是<code>interrupted</code>的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread myThread =  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span>  <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    System.out.println(<span class="string">"thread status:"</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">myThread.run();</span><br></pre></td></tr></table></figure>

<p>这段代码如果不加<code>Thread.currentThread().interrupt();</code>，那么下面的<code>Thread.currentThread().isInterrupted()</code>就将会返回<code>false</code>。如果没有确定上层代码是否要处理异常，那么切记不能catch中这个中止的异常而不做任何的事情。</p>
<h2 id="Executor的作用"><a href="#Executor的作用" class="headerlink" title="Executor的作用"></a>Executor的作用</h2><p>既然已经有了线程，那么Executor的作用是什么呢？它是将任务的提交和任务的执行分离开了。也就是说把复杂的业务过程分割开了，这样就更加便于我们修改执行策略。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/11/21/note-concurrency-in-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/21/note-concurrency-in-practice/" itemprop="url">Java多线程基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-21T14:09:19+08:00">2017-11-21</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多个线程安全类的方法在一起一定是线程安全的吗？"><a href="#多个线程安全类的方法在一起一定是线程安全的吗？" class="headerlink" title="多个线程安全类的方法在一起一定是线程安全的吗？"></a>多个线程安全类的方法在一起一定是线程安全的吗？</h2><p>  尽管线程安全类的每个方法都是原子的，但是当很多原子操作合并为一个复合操作的时候，需要额外加锁，否则就会出现竞态条件（race condition）造成线程不安全。但是这里额外的加锁可能会导致性能损耗并且可能引起死锁。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!vector.contains(element))</span><br><span class="line">    vector.add(element);</span><br></pre></td></tr></table></figure>

<p>这里<code>contains</code>方法和<code>add</code>方法都是线程安全的，但是综合起来就是非线程安全的了。</p>
<h2 id="方法的局部变量无需加锁"><a href="#方法的局部变量无需加锁" class="headerlink" title="方法的局部变量无需加锁"></a>方法的局部变量无需加锁</h2><p>   某个线程进入一个方法就会创建一个栈，这个栈中存储了某个局部变量，这个局部变量是每个线程所独有，不是共享的，他们之间互不影响，没有必要加锁。</p>
<h2 id="加锁时所发生的事情"><a href="#加锁时所发生的事情" class="headerlink" title="加锁时所发生的事情"></a>加锁时所发生的事情</h2><ul>
<li>操作互斥，很多个线程不能同时对一个代码块进行操作</li>
<li>加锁之后可以保证变量的可见性</li>
<li>抑制了编译器优化，导致指令不会被重排序</li>
<li>使用内存栅栏（Memory Barrier）从而使缓存无效</li>
<li>由于锁竞争而导致阻塞时，持有锁的线程在释放锁的时候需要告诉操作系统，这个锁可以用了，进而操作系统会唤醒其它被挂起的线程</li>
</ul>
<h2 id="锁的粒度该怎样控制"><a href="#锁的粒度该怎样控制" class="headerlink" title="锁的粒度该怎样控制"></a>锁的粒度该怎样控制</h2><p>代码块加锁的粒度应该越小越好，但是如果代码块中加锁的粒度很小（代码中相互竞争的临界资源没有相互的依赖性，可以将每种资源加一把锁），频繁的加锁和开锁也会造成性能的开销，降低CPU的利用率，所以并不是加锁越多越好。同时加锁也会造成代码的复杂性，这就是简单性和性能之间存在的互相制约。当我们实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性。</p>
<h2 id="可见性和原子性"><a href="#可见性和原子性" class="headerlink" title="可见性和原子性"></a>可见性和原子性</h2><p>   <code>volatile</code>保证了属性的可见性，但是不能保证某个操作的原子性。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> number;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> number++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里的<code>number</code>就是可见的，但是<code>addMethod</code>这个方法不是线程安全的，也就是说<code>number++</code>这个操作不是原子操作，因为它只是保证了，线程<code>A</code>对<code>number</code>的操作对线程<code>B</code>是可见的，但是不能保证在线程<code>A</code>对<code>number</code>操作的时候，线程<code>B</code>也可以对<code>number</code>进行操作。比如线程<code>A</code>和<code>B</code>同时读取了<code>number</code>的数值，发现它是<code>12</code>，这时线程A和线程B</p>
<blockquote>
<p>当执行时间较长的计算或者可能无法快速完成的操作时一定不要加锁，比如：网络IO或者控制台IO。</p>
</blockquote>
<h2 id="如何正确地发布对象"><a href="#如何正确地发布对象" class="headerlink" title="如何正确地发布对象"></a>如何正确地发布对象</h2><p> 这里的发布指的是将某个类的属性值公开。这里如果没有正确的公开，那么就会造成线程不安全。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Holder</span> <span class="params">(<span class="keyword">int</span> n )</span> </span>&#123;<span class="keyword">this</span>.n = n;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertSanity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n != n)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"This statement is false."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里如果在线程A中创建对象，这时线程B调用这个对象的<code>assertSanity</code>方法，那么这个方法就可能会触发断言，也就是说在对象的创建过程中，它的属性n的值可能还没有确定，<code>this.n = n;</code>。这个代码还没有被执行，而在执行<code>n != n</code>的过程中执行了。</p>
<h2 id="对象的可见性"><a href="#对象的可见性" class="headerlink" title="对象的可见性"></a>对象的可见性</h2><p>   对象的引用对另外的线程可见，并不意味着对象的状态对另外的线程可见。<br>   As we’ve seen, that an object reference becomes visible to another thread does not necessarily mean that the state of that object is visible to the consuming thread。</p>
<h2 id="不可变对象的线程安全性"><a href="#不可变对象的线程安全性" class="headerlink" title="不可变对象的线程安全性"></a>不可变对象的线程安全性</h2><p>   不可变对象在正确的初始化之后是线程安全的，所以发布的时候就不必使用锁机制。但是如果某个引用是不可见的，并且引用的对象是可变的，那么在这个不可变的引用在发布的时候也需要加锁。</p>
<h2 id="哪些操作必须是原子的？"><a href="#哪些操作必须是原子的？" class="headerlink" title="哪些操作必须是原子的？"></a>哪些操作必须是原子的？</h2><p>   如果有两个变量，其中一个变量值的更改会影响另外一个变量的，那么如果要同时改变这两个变量，那么它们需要是原子的，否则其中一个变量改变，而另外的一个变量没有变，那么从这个没有变化的变量中取到的值就有可能是过期的值。比如：</p>
<ul>
<li>我们给每个请求都做一个<strong>标记</strong>，如果某个请求和上一个请求的标记相同，那么就从<strong>缓存</strong>去取这个结果。在这里，这个标记和这个结果是一体的，所以对它们两个的操作必须是原子操作，否则就不能保证取出的结果就是正确的。因为有可能<strong>标记变了，但是缓存还没有变。</strong></li>
<li>我们有一个Range这样的对象，它有一个<strong>下界</strong>和一个<strong>上界</strong>，上界要大于下界，所以对上下界的操作就必须保证是原子的，否则如果一个线程改变了下界，这时上界没有跟着变化，就可能会造成下界大于上界的情况。</li>
</ul>
<p>也就是说：</p>
<blockquote>
<p>是规则和限制产生了必须要原子操作的需要，这就是线程安全的需要。</p>
</blockquote>
<h2 id="线程安全是有粒度的"><a href="#线程安全是有粒度的" class="headerlink" title="线程安全是有粒度的"></a>线程安全是有粒度的</h2><p>某个类不是线程安全的，但是如果封装它的类做了线程安全的处理，那么使用它的时候也就是线程安全的了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSet</span> </span>&#123;</span><br><span class="line">   <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Person&gt; mySet = <span class="keyword">new</span> HashSet&lt;Person&gt;();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addPerson</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        mySet.add(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsPerson</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mySet.contains(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如果某个类包含了一个线程安全的类，那么它不一定是线程安全，比如："><a href="#如果某个类包含了一个线程安全的类，那么它不一定是线程安全，比如：" class="headerlink" title="如果某个类包含了一个线程安全的类，那么它不一定是线程安全，比如："></a>如果某个类包含了一个线程安全的类，那么它不一定是线程安全，比如：</h2><p>两个<code>AtomicLong</code>类型的变量，这两个变量有关联，那么就必须让对这两个变量的操作变为原子化之后才可以是线程安全的，否则仍然不是线程安全的。</p>
<h2 id="给线程安全的类添加线程安全的方法"><a href="#给线程安全的类添加线程安全的方法" class="headerlink" title="给线程安全的类添加线程安全的方法"></a>给线程安全的类添加线程安全的方法</h2><p>如果要给线程安全的类添加线程安全的方法，那么最好不要使用类扩展，因为如果使用类扩展，那么原来类的线程安全策略做了改动，那么被扩展的类就失效了，比如改了线程安全所用的锁，有些时候这些错误还很难被发现。同时需要特别注意多个线程对线程安全类的同时操作，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">list.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两个方法都是针对于线程安全的<code>Vector</code>所做的，那么它们是线程安全的吗？答案是否定的。<br>比如在<code>getLast</code>方法中，如果线程A在执行完<code>int lastIndex = list.size() - 1;</code>之后恰巧有线程B也对这个Vector做了<code>deleteLast</code>操作，那么就可能引起<code>list.get</code>越界的情况。也就是说，所有针对同一个Vector的操作都应该是原子的。所以正确的做法应该是这样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line"><span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> list.get(lastIndex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line"><span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">list.remove(lastIndex);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样通过给<code>Vector</code>加锁就确保了这些方法的操作是线程安全的。下面还有个很类似的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">    doSomething(vector.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也是非线程安全的，因为不能保证在执行<code>vector.size()</code>和<code>vector.get(i)</code>之间不会有另外一个线程对<code>vector</code>做其它的操作。这个问题的解决思路和上面是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(vector) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">doSomething(vector.get(i));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁之后，就可以保证<code>vector.size()</code>和<code>vector.get(i)</code>的操作是原子的，中间不会有其它的线程会对<code>Vector</code>做响应的操作。</p>
<h2 id="某个方法加了同步锁就一定是线程安全的吗？"><a href="#某个方法加了同步锁就一定是线程安全的吗？" class="headerlink" title="某个方法加了同步锁就一定是线程安全的吗？"></a>某个方法加了同步锁就一定是线程安全的吗？</h2><p>答案是否定的。因为<strong>加锁实现的互斥是基于锁的，多个线程必须使用同一把锁才可以实现互斥。</strong>，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span>   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;E&gt;());</span><br><span class="line">...  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> absent = !list.contains(x); <span class="keyword">if</span>(absent)</span><br><span class="line">    list.add(x);</span><br><span class="line">    <span class="keyword">return</span> absent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>putIfAbsent</code>中的加锁并不能保证<code>ListHelper</code>的线程安全，因为这个锁是对象锁，锁住的是<code>ListHelper</code>，而并没有锁住真正需要锁的<code>list</code>上。客户端如果有多个线程同时对list做其它的操作，那么就不能保证线程的安全性。这时争取的做法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;E&gt; list = Collections.synchronizedList(newArrayList&lt;E&gt;()); </span><br><span class="line">...<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> absent = !list.contains(x);</span><br><span class="line">       <span class="keyword">if</span> (absent) &#123;</span><br><span class="line">          list.add(x);</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">return</span> absent;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就保证了putIfAbsent的线程安全性。但是这种通过客户端加锁的方法不是很可靠，因为你不能确定客户端做怎样的操作，有时候会造成死锁。</p>
<h2 id="最理想的并发是什么样的？"><a href="#最理想的并发是什么样的？" class="headerlink" title="最理想的并发是什么样的？"></a>最理想的并发是什么样的？</h2><p>   The best way to implement concurrency is to reduce the interactions and inter-dependencies between your concurrent tasks。实现并发最好的方式就是避免并发任务之间的交互和相互之间的依赖。</p>
<h2 id="容易被忽略的线程安全问题"><a href="#容易被忽略的线程安全问题" class="headerlink" title="容易被忽略的线程安全问题"></a>容易被忽略的线程安全问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenIterator</span> </span>&#123;</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">    set.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">    set.remove(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTenThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    add(r.nextInt());</span><br><span class="line">    System.out.println(<span class="string">"DEBUG: added ten elements to "</span> + set);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>这里同样是非线程安全的，因为在执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"DEBUG: added ten elements to "</span> + set);</span><br></pre></td></tr></table></figure>

<p>的时候，系统会默认调用<code>StringBuilder.append(Object)</code>方法，在这个方法里面会再次调用Object的<code>toString</code>方法，在这个<code>toString</code>方法内部将会调用迭代器方法并且生成相应的字符串（容器的hashCode和equals方法也有相似的问题）。所以这里是非线程安全的，可能会抛出<code>ConcurrentModificationException</code>方法。也就是说如果一个状态和保护这个状态的同步代码之间相隔越远，那么开发人员就越容易忘记在访问这个状态时使用正确的同步。这时如果将HashSet用<code>synchronizedSet</code>来封装一下，那么就不会忘记了。</p>
<blockquote>
<p>封装对象的状态有助于维持不变形条件；封装对象的同步机制有助于确保实施同步策略。</p>
</blockquote>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><code>ConcurrentHashMap</code>的出现就是为了解决同步容器性能差的问题。在一些操作中，比如HashMap.get或者List.contains，可能会包含大量的工作，在执行这些大量工作的时间段内，其它的线程都是被阻塞的，这极大的影响了并发的性能。虽然<code>ConcurrentHashMap</code>和<code>HashMap</code>一样是基于散列的Map，但是它们使用不同的加锁策略来提供更高的并发性和伸缩性，从而使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制成为分段锁（Lock Striping）。</p>
<h2 id="什么是工作密取-work-stealing-方法，它有什么优点？"><a href="#什么是工作密取-work-stealing-方法，它有什么优点？" class="headerlink" title="什么是工作密取(work stealing)方法，它有什么优点？"></a>什么是工作密取(work stealing)方法，它有什么优点？</h2><p>在生产者-消费者模型中所有的消费者有一个共享的工作队列。工作密取的每个消费者都含有一个双端队列。如果一个消费者完成了自己工作队列中的所有问题，那么其它就可以从其它的队列<strong>末尾</strong>秘密的获取工作。密取的工作模式比传统的消费者-生产者模式具有更好的可伸缩性，因为工作者线程不会在单个共享的任务队列上发生竞争。在大多数情况下他们都只访问自己的双端队列，从而极大地减少了竞争。当工作者线程要访问另外一个工作者线程的队列时它将从队列的末尾获取工作，因此进一步降低了队列的竞争程度。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/10/17/java-generic-details/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/17/java-generic-details/" itemprop="url">Java泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-17T21:18:59+08:00">2017-10-17</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么需要泛型？"><a href="#为什么需要泛型？" class="headerlink" title="为什么需要泛型？"></a>为什么需要泛型？</h2><p>在Java1.5版本之前是没有泛型的。这时如果我们要实现一个Array类，它里面可以存储任何的对象，我们该怎样做呢？显然，我们可以通过多态来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object e)</span></span>;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Java中的对象都继承自Object，所以就可以往这个Array中添加任何的对象，并且取出任何的对象了。但是这样做会有很大的风险：</p>
<ul>
<li>我们取出的对象都是Object类型的，所以如果要使用这个对象就必须做一次强制转换，因为我们使用Collection框架的频率是很高的，所以这种转换就显得比较麻烦</li>
<li>不安全，因为是Object，所以我们可以往里面放任何的对象，比如Animal对象，Plant对象，Plane对象，这样如果我们在调用Array中对象的方法时就可能Crash</li>
</ul>
<p>第二点对于Java这种追求安全性的语言来说，显然是不可以接受的，所以就出现了泛型。</p>
<h2 id="泛型的基本用法"><a href="#泛型的基本用法" class="headerlink" title="泛型的基本用法"></a>泛型的基本用法</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>我们可以定义一个泛型的类，具体的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   T first;</span><br><span class="line">   T second;</span><br><span class="line">   <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在我们创建对象的时候就可以使用<code>Pair&lt;Integer&gt; pair = new Pair&lt;Integer&gt;()</code>，这样我们就可以明确的指出这里的<code>Pair</code>中存放的就是<code>Integer</code>类型的对象，其它对象如果要放到Pair中编译器就会报错，这样就在很大程度上增加了安全性。并且在取出的时候也不必再进行一次强制转换了。<br>如果某个类中有多个泛型，那么这些泛型用<code>,</code>好分割开就好了。<code>public class Pair&lt;T, U&gt; { . . . }</code>。<em>一般我们会用大写字母来表示泛型的元素，在Java框架中<code>E</code>用来表示一个元素，<code>K</code>和<code>V</code>用来表示一个table的key value值。</em></p>
<p>同样，我们可以定义一个泛型的方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这个泛型的方法并不是在泛型类中的，而是在普通的Java类中的，当然，它也可以被定义在泛型类中。<br></p>
<p>调用的时候不需要进行强制转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String middle = ArrayAlg.getMiddle(<span class="string">"John"</span>, <span class="string">"Q."</span>, <span class="string">"Public"</span>);</span><br><span class="line"><span class="keyword">double</span> middle = ArrayAlg.getMiddle(<span class="number">3.14</span>, <span class="number">1729</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在第二个例子中我们传入的参数是原始数据类型，这时编译器会给我们自动打包，在从类中取出的时候编译器会给我们自动的拆包。</p>
<h2 id="泛型的界"><a href="#泛型的界" class="headerlink" title="泛型的界"></a>泛型的界</h2><p>有时候我们需要对输入的参数做一些限制，比如说要好处两个数值中较小的一个，那么我们就要求进入方法的参数是实现了<code>Comparable</code>接口的，或者是某个类的子类，这样我们就可以做如下的限制，来让泛型有界：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span> . . .</span></span><br></pre></td></tr></table></figure>

<p>如果某个类型没有实现<code>Comparable</code>接口的话，让它作为参数会产生一个编译期的警告，在运行时就会Crash。如果一个泛型需要限制很多个接口的话，那么很多个接口之间用<code>,</code>隔开（但是这其中只能有一个是对类的限制，并且如果有对类的限制，那么这个限制一定要写在第一个的位置）。</p>
<h2 id="泛型和JVM"><a href="#泛型和JVM" class="headerlink" title="泛型和JVM"></a>泛型和JVM</h2><p>在Java虚拟机中是没有任何泛型类的，所有的对象都是普通的Java类。其实泛型只是一种给程序员的一个假象，用来方便程序员写出安全语言的一种手段，在编译完之后编译器会对泛型实行一次擦除的过程。也就是说，当你定义一个泛型的时候，系统会自动给你创建一个原始类型给你。原始类型变量的名字和泛型时候取的名字是一样的，但是泛型类型的参数类型被移除了。这些类型被移除之后，取而代之的是它们的边界类型（如果没有边界，那么它的边界就是Object，这也是为了和Java之前的版本做兼容。这也就是上文提到的，为什么对于原始数据类型有一个装包和拆包的过程）。比如，如果你创建上文中的<code>Pair&lt;T&gt;</code>，在编译之后Pair类就成了下面的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object first; <span class="keyword">private</span> Object second;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object second)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.first = first;</span><br><span class="line"><span class="keyword">this</span>.second = second; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> first; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> second; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(Object newValue)</span> </span>&#123; first = newValue; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object newValue)</span> </span>&#123; second = newValue; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>这其实和没有泛型时候创建的类是一样的了。</p>
<p>这里有一个特殊情况，如果有两个限制，那么会以第一个限制为准：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T lower;</span><br><span class="line"><span class="keyword">private</span> T upper;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (first.compareTo(second) &lt;= <span class="number">0</span>) &#123; lower = first; upper = second; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; lower = second; upper = first; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时<code>Interval</code>的基本类型就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Comparable lower;</span><br><span class="line"><span class="keyword">private</span> Comparable upper;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(Comparable first, Comparable second)</span> </span>&#123; . . . &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，如果第一种类型要转化为第二种类型的时候编译器会自动的加上强制转换。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies = . . .;</span><br><span class="line">Employee buddy = buddies.getFirst();</span><br></pre></td></tr></table></figure>

<p>因为在编译期进行了类型擦除，所以在调用<code>buddies.getFirst()</code>的时候返回的是一个Object，所以编译器就自动添加了一层强制转换。</p>
<h2 id="泛型方法的翻译"><a href="#泛型方法的翻译" class="headerlink" title="泛型方法的翻译"></a>泛型方法的翻译</h2><p>上文提到过泛型会被编译器在编译的阶段进行擦除，并且将边界替换为泛型的类型。这种泛型的擦除同时也带来了复杂性，比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">LocalDate</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (second.compareTo(getFirst()) &gt;= <span class="number">0</span>) <span class="keyword">super</span>.setSecond(second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们要保证<code>Pair</code>中的第二个元素要始终不小于第一个元素，所以我们就继承了<code>Pair</code>，并且重写了其<code>setSecond</code>方法，这样经过泛型的擦除，最后将会变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInterval</span> <span class="keyword">extends</span> <span class="title">Pair</span> // <span class="title">after</span> <span class="title">erasure</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(LocalDate second)</span> </span>&#123; . . . &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而原来的<code>Pair</code>类中的<code>setSecond</code>方法是这样子的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span></span></span><br></pre></td></tr></table></figure>

<p>很显然，这是两个不同的方法，然而我们不想让它们是不同的方法，我们想让它走我们新写的方法，因为我们在这里面新增加了我们自己的业务逻辑，比如下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateInterval interval = <span class="keyword">new</span> DateInterval(. . .); Pair&lt;LocalDate&gt; pair = interval; <span class="comment">// OK--assignment to superclass</span></span><br><span class="line">pair.setSecond(aDate);</span><br></pre></td></tr></table></figure>

<p>在这里很显然，我们想走我们新的方法，这时编译器其实会在我们的参数为<code>Object</code>的方法里面重新调用我们新写的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(Object second)</span> </span>&#123;</span><br><span class="line">    setSecond((Date) second);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>也就是这种转换让系统调用到了我们新写的方法。这样就可以始终调用到我们自己的方法里面了。</p>
<h2 id="Java泛型中需要注意的问题"><a href="#Java泛型中需要注意的问题" class="headerlink" title="Java泛型中需要注意的问题"></a>Java泛型中需要注意的问题</h2><h3 id="不能使用基本数据类型作为泛型类的初始化参数"><a href="#不能使用基本数据类型作为泛型类的初始化参数" class="headerlink" title="不能使用基本数据类型作为泛型类的初始化参数"></a>不能使用基本数据类型作为泛型类的初始化参数</h3><p>因为Java泛型在编译完之后就被擦除了，泛型类的属性都会变成Object类型，所以就不能传入基本数据类型作为参数，必须使用与基本数据类型所对应的Java类。还好Java中只有八中类型的基本数据类型。</p>
<h3 id="Runtime类型检查不起作用"><a href="#Runtime类型检查不起作用" class="headerlink" title="Runtime类型检查不起作用"></a>Runtime类型检查不起作用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stringPair <span class="keyword">instanceof</span> Pair&lt;String&gt;)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (stringPair <span class="keyword">instanceof</span> Pair&lt;T&gt;)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的两种运行时的类型检查会报错，因为在编译完之后<code>Pair&lt;String&gt;</code>就不存在了，Pair就变成了属性为String类型的类，所以这种判断错误的，也不能通过编译。但是如果使用泛型类创建了一个对象，然后再判断对象的类型，那么就是可行的。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; stringPair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">Pair&lt;Double&gt; doublePair = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (stringPair.getClass() == doublePair.getClass())&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"StringPair and DoublePair is equal"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时是可以判断成功的，他们都是一个Pair类，只不过这个类属性的类型不一样。</p>
<h3 id="不能使用参数类型来创建Array"><a href="#不能使用参数类型来创建Array" class="headerlink" title="不能使用参数类型来创建Array"></a>不能使用参数类型来创建Array</h3><p>泛型引入就是为了增加语言的安全性，如果没有泛型，那么对于Collection框架，在进行类型转化的时候很容易出现<code>java.lang.ClassCastException</code>这种类型的异常。泛型在设计的时候有一条原则：</p>
<blockquote>
<p>如果一段代码在编译时没有提出“[unchecked] 未经检查的转换”警告，则程序在运行时不会引发ClasscastException异常</p>
</blockquote>
<p>所以，如果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] p=<span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//1 这段代码实际是不能通过编译的</span></span><br><span class="line">Object[] objs=p; <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>这里，如果第一行的代码被允许，那么根据数组的特性，第二行的代码也是被允许的，并且不会有警告。这样一来我们就可以给<code>objs</code>数组里面添加任意的对象了，并且不会有任何警告，这显然是与泛型的设计原则相违背的。如果这时非要使用数组来存储泛型，那么可以使用ArrayList：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Pair&lt;String&gt;&gt; myArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>为什么ArrayList可以呢？因为将<code>Pair&lt;String&gt;</code>类型的ArrayList转换为Object类型的ArrayList在编译期就会报错，这就保证了安全性。</p>
<h3 id="可变参数警告"><a href="#可变参数警告" class="headerlink" title="可变参数警告"></a>可变参数警告</h3><p>如果一个方法是可变参数的，并且其类型是泛型，那么Java虚拟机就不得不创建一个泛型数组，这与上一条约定是矛盾的，但这时JVM会放松对泛型的限制，只不过会抛出一个警告<code>uncheck</code>的警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFour</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      Collection&lt;Pair&lt;String&gt;&gt; table = <span class="keyword">null</span>;</span><br><span class="line">      Pair&lt;String&gt; pair1 = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">      Pair&lt;String&gt; pair2 = <span class="keyword">new</span> Pair&lt;&gt;();</span><br><span class="line">      addAll(table,pair1,pair2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; collection, T... ts)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(T t:ts) &#123;</span><br><span class="line">          collection.add(t);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这时会抛出一个<code>Unchecked generics array creation for varargs parameters</code> 这个警告，这时有两种解决方案。首先可以再<code>addAll</code>方法的上面加上<code>@SafeVarargs</code>的注解或者在调用方<code>testFour</code>的上面加上<code>@SuppressWarnings(&#39;unchecked&#39;)</code>注解。</p>
<h3 id="不能初始化泛型变量"><a href="#不能初始化泛型变量" class="headerlink" title="不能初始化泛型变量"></a>不能初始化泛型变量</h3><p>也就是说在泛型类中，如果一个变量是泛型的，那么不能直接对其进行初始化，比如在构造方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    first = <span class="keyword">new</span> T();</span><br><span class="line">    second = <span class="keyword">new</span> T();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的写法是通不过编译的，因为泛型在编译完成之后泛型就被擦除了，就变成了Object，如果真的可以初始化，那么这个Pair类在初始化之后它的first和second的初始值就是Object了。这显然不是我们期望的，所以不能对泛型属性进行实例化。如果真的想在初始化时候就实例化，那么可以提供一个静态初始化方法，然后将属性的类传进来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; cl)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(cl.newInstance(),cl.newInstance());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型类中的静态环境中不允许使用类型变量"><a href="#泛型类中的静态环境中不允许使用类型变量" class="headerlink" title="泛型类中的静态环境中不允许使用类型变量"></a>泛型类中的静态环境中不允许使用类型变量</h3><p>比如下面的泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T singleInstance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">getSingleInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(singleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 初始化singleInstance</span></span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> singleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的公用泛型类是不能通过编译的，因为在泛型被擦除之后就变成了Object，那么这个即使这个Singleton可以使static变量，那么也只能创建一个对象，而不能作为单例的公用方法。为什么不能将泛型声明为stati呢？因为泛型是要在对象创建的时候才知道是什么类型的，而对象创建的代码执行先后顺序是：static的部分，然后才是构造函数等等。所以在对象初始化之前static的部分已经执行了，如果你在静态部分引用的泛型，那么毫无疑问虚拟机根本不知道是什么东西，因为这个时候类还没有初始化。</p>
<h3 id="不能抛出或者捕获泛型类对象"><a href="#不能抛出或者捕获泛型类对象" class="headerlink" title="不能抛出或者捕获泛型类对象"></a>不能抛出或者捕获泛型类对象</h3><p>泛型类不能extend Throwable，同时不能Catch住泛型，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以及：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">            doWork();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (T e)&#123;</span><br><span class="line">            Logger.global.info(...);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些都是不能通过编译的。之所以要这样设计，我猜测是不利于异常的处理，因为我们在泛型类里已经捕获到了异常，当我们调用泛型类的时候，即使报错了，我们也不知道，因为底层的泛型类已经将错误吞掉了，这样不利于对具体的业务做相应的处理。所以，如果我们把错误抛出来，那么就会好很多，比如下面这种做法就是可行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> throw T </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        doWork();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable realCause)&#123;</span><br><span class="line">      t.initCause(realCause);</span><br><span class="line">      <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样使用泛型类的Client端就可以根据业务的需要做相应的处理了。</p>
<h3 id="泛型擦除之后可能引起冲突"><a href="#泛型擦除之后可能引起冲突" class="headerlink" title="泛型擦除之后可能引起冲突"></a>泛型擦除之后可能引起冲突</h3><p>泛型在擦除之后是Object，所以在定义某些泛型方法的时候要注意，在泛型变为Object的时候是不是会引起和原来的方法引起冲突。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> first.equals(value) &amp;&amp; second.equals(value);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在泛型被擦除之后<code>boolean equals(T)</code>就变为了<code>boolean equals(Object)</code>，这个方法其实和Object的<code>equals(Object)</code>方法是一样的，所以就引起了冲突。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>在遗留代码中往往有非泛型的类，这时，如果用一个泛型类去接，那么往往会产生一个警告，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dictionary&lt;Integer, Components&gt; labelTable = slider.getLabelTable(); <span class="comment">// Warning</span></span><br></pre></td></tr></table></figure>

<p>这时如果你检查了<code>labelTable</code>中数据的类型，并且确定了其中的key value为<code>Integer</code>和<code>Components</code>，那么就可以使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>来忽略这个警告。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">Dictionary&lt;Integer, Components&gt; labelTable = slider.getLabelTable(); <span class="comment">// No warning</span></span><br></pre></td></tr></table></figure>

<p>当然也可以在外层的方法上添加。</p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ol>
<li><a href="https://www.zhihu.com/question/20400700" target="_blank" rel="noopener">https://www.zhihu.com/question/20400700</a></li>
<li><a href="http://blog.csdn.net/claram/article/details/51943742" target="_blank" rel="noopener">http://blog.csdn.net/claram/article/details/51943742</a></li>
<li><a href="http://blog.csdn.net/yj_fq/article/details/44590285" target="_blank" rel="noopener">http://blog.csdn.net/yj_fq/article/details/44590285</a></li>
<li>Java核心卷1</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/10/12/data-structure-linear-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/12/data-structure-linear-list/" itemprop="url">数据结构--线性表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-12T09:36:56+08:00">2017-10-12</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1513759-17638d16cc8b3161.png" alt="LinearList"><br><strong>线性表的定义：零个或者多个具有相同的特性的数据元素的有限序列。</strong>注意这里的连续不是指存储地址上的连续而是指存取逻辑上的连续。从线性表的存储结构上可以将线性表分为顺序存储和链式存储两种形式。在实际中常以<em>栈，队列，字符串</em>等特殊的形式来使用。</p>
<h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>线性表的顺序存储结构是指用一段连续的存储单元依次存储线性表中的元素。它的存储形式如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-c333242edadd24c3.png" alt="线性表的顺序存储"></p>
<blockquote>
<p>这种顺序的存储结构必须有要有一个长度，并且这个长度是不能改变的。</p>
</blockquote>
<p>为什么会这样？因为计算机内存中的存储空间是连续的，要分配一段连续的存储空间，如果没有限制大小，那么很可能其后面的空间被其它对象占用了。举个例子，会议室有100个连续的位置，这时来了A组人来了5个人（一共20个人），做到了0，1，2，3，4这五个位置。过了一段时间之后B组来了20人，他们坐到了10…19这10个位置。然后A组的其它15个人来了，这15个人不能被放到5…9这五个位置上，这样就不满足顺序存储结构的定义了。</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>这种存储结构的存储位置很容易被计算出来，比如要计算下标为i元素的位置，这时候只需要利用下面的公式即可：<br>LOC(a<sub>i</sub>) = LOC(a<sub>1</sub>) + (i - 1) * c</p>
<p>其中c是每个元素所占存储单元的个数。所以根据大O阶记法，这个时间复杂度是O(1)(这种时间复杂度为1的存储结构称为随机存取结构或者直接存取结构)。</p>
<h3 id="插入删除"><a href="#插入删除" class="headerlink" title="插入删除"></a>插入删除</h3><p>这种顺序存储结构的插入需要将插入点之后的所有元素都向后移（如果插入点在最后一个元素之后则不需要后移）。所以比较消耗性能，其时间复杂度是O(n)，如果在某个位置同时插入1000个元素，那么它需要循环移动1000次。这种性能消耗是比较大的，Java中的ArrayList在插入大量数据的时候就会有较大的性能消耗。</p>
<h3 id="顺序存储结构的优缺点"><a href="#顺序存储结构的优缺点" class="headerlink" title="顺序存储结构的优缺点"></a>顺序存储结构的优缺点</h3><p>从上面的讨论中我们就可以看出来顺序存储结构的优点和缺点。</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>无需为表示表中元素之间的逻辑关系而增加额外的存储空间</td>
<td>插入插入和删除元素需要移动大量元素</td>
</tr>
<tr>
<td>可以快速地存取表中任一位置的元素</td>
<td>当线性表的长度变化较大时，难以确定存储空间的容量</td>
</tr>
<tr>
<td></td>
<td>造成存储空间的“碎片”</td>
</tr>
</tbody></table>
<h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p>为了解决线性存储结构不容易扩展，难以插入和删除的缺点。出现了链式存储的线性表，这种表的每一个元素中都有一个标识用来记录下一个元素地址。这样就不需要在内存中开辟连续的空间。它的存储形式是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-5076d727f47a9f05.png" alt="LinkedList"><br>它需要两个存储空间，一个数据域用来存储数据元素的信息，一个指针域用来存贮下个元素的地址，其中的每个元素又叫做结点（Node）。每个线性表都有一个指针指向它，这个指针叫做头指针（<em>这个指针是每个链表所必须的，即使这个链表为空</em>），这个指针指向头结点（如果存在的话），头结点的数据域是空或者可以存储表的长度等附加信息。最后一个结点是的指针域是NULL或者”^”符号。那么为啥要有这个头结点呢?不要头结点可以吗？那为啥链表的结尾不需要特殊处理呢？因为链表结尾的指针域为NULL或者”^”所以其插入操作是相同的。<br>答案是可以的，但是这会让链表对第一个结点之前的插入操作变得和其它元素不统一，为了解决这种不便，人为地加入了头结点。</p>
<h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><p>单链表的查询需要一个个遍历，因为它的存储空间不连续所以不能根据第一个元素的地址推断出第i个元素的地址，必须一个个查找，直到查找到第i个元素。因此它的时间复杂度是O(n)。</p>
<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>单链表的插入操作就比较简单，只需要改变插入点的前结点以及插入结点的指针即可。如下图所示<br><img src="http://upload-images.jianshu.io/upload_images/1513759-f5a638c6e223b1b7.png" alt="Insert Linked List"><br>关键的步骤为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next = p-&gt;next; </span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure>

<p>这样就可以插入结点了，注意这里的。<br>单链表删除元素的操作也是比较简单，只要将要删除结点之前的结点跳过删除结点，然后指向删除结点之后的结点即可。如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-ad3a75e5ce4399f9.png" alt="Delete Node"><br>关键的步骤为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = p-&gt;next-&gt;next</span><br></pre></td></tr></table></figure>

<h3 id="单链表和顺序存储结构的优缺点"><a href="#单链表和顺序存储结构的优缺点" class="headerlink" title="单链表和顺序存储结构的优缺点"></a>单链表和顺序存储结构的优缺点</h3><p>一、时间性能</p>
<ul>
<li>查找<ul>
<li>顺序存储结构为O(1)</li>
<li>单链表O(n)</li>
</ul>
</li>
<li>插入和删除<ul>
<li>顺序存储结构需要平均移动表长一半的元素，时间复杂度为O(n)</li>
<li>单链表在找出插入点的位置之后（这个过程的时间复杂度为O(n)），插入和删除的时间复杂度为O(1)</li>
</ul>
</li>
</ul>
<p>二、空间性能</p>
<ul>
<li>顺序存储结构需要预先分配存储空间的大小，分大了，浪费，分小了容易发生上溢。</li>
<li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。</li>
</ul>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>上文中提到的链表的实现是基于内存地址的，这是C语言或者其它可以操作内存的语言所容易实现。然而，对于不能操作内存的语言可以实现链表的存储结构吗？答案是可以的。实现的原理是：利用数组来代替指针，以此来描述单链表。这时数组的元素由两部分内容组成，data和cur。也就是说数组的每个元素对应一个data和cur。其中data用来存储数据，cur用来存储指针(相当于单链表中的next指针，它用来存放其后继元素在数组中的下标，我们把cur叫做游标)。<strong>这种用数组来描述的链表称为静态链表</strong>，为啥叫静态呢？因为其存储空间是顺序的，所以这也是一种顺序的存储结构，它的存储空间还是需要提前分配好的。它的结构如下所示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-90418e892596cf08.png" alt="static liner"><br>静态链表的第一个和最后一个元素做了特殊处理里面不存储数据，只存储cur值。链表中申请了但是没有被利用的空间是空闲空间。第一个元素中的cur存放的是第一个空闲空间元素的下标；最后一个元素的cur值为第一个元素的下表。</p>
<h3 id="静态链表的插入操作和删除操作"><a href="#静态链表的插入操作和删除操作" class="headerlink" title="静态链表的插入操作和删除操作"></a>静态链表的插入操作和删除操作</h3><p>动态链表在插入和删除的时候需要调用malloc()和free()这两个函数来实现。但是在静态链表中操作的是存储空间已经提前申请好的数组，所以只需要利用相关的策略就可以实现。比如我们要在上述的“乙”和“丁”之间插入“丙”元素，那我们该怎么做呢？我们只需要把“丙”放到下标为7的位置，然后“乙”的cur值改为7，丙的cur值改为3即可。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-32dceff8441401f0.png" alt="insert into static liner"><br>静态链表的删除操作和动态链表的删除有些不太一样，被删除之后相当于并入到了空闲链表，那么我们就把第一个元素的cur值标为要删除元素的下标（表明它是第一个空闲元素），然后让被删除元素的cur值指向之前第一个空闲元素的下标。这样之后该被删除的元素就并入了空闲元素之中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-cfb09c3fcb5f4c73.png" alt="delete from static liner"></p>
<p>静态链表的查询操作和动态链表的几乎相同，就不赘述了。</p>
<h3 id="静态链表的优缺点"><a href="#静态链表的优缺点" class="headerlink" title="静态链表的优缺点"></a>静态链表的优缺点</h3><table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>插入和删除操作，只需修改游标，不用移动元素，<br>从而改进了顺序存储结构中的插入和删除<br>需要移动大量元素的缺点</td>
<td>没有解决连续存储带来的长度难以确定的问题</td>
</tr>
<tr>
<td></td>
<td>失去了顺序存储结构随机存取的特性</td>
</tr>
</tbody></table>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>单链表有一个非常严重的问题：从链表中的一个结点出发，访问到链表中的所有结点，比如当从尾结点出发，要访问到所有的结点，必须先把指针移动头结点，然后从头开始遍历。为了解决这个问题，又引入了一种新的数据结构：循环链表。循环链表也就是说把原来单链表中终端结点的指针端由空改为指向头结点，这就使整个链表形成一个环，这种头尾相接的单链表成为单循环链表，简称循环链表（circular linked list）。这样虽然可以解决遍历其中任何一个结点的目的，但是还有一个问题：从头结点查找尾结点的时间复杂度为O(n)。我们可以通过将头指针移动位置来解决这个问题：<em>不用头指针，而是用指向终端结点的尾指针来表示循环链表，此时查找开始结点和终端结点都很方便了（时间复杂度都是O(1)）。</em><br><img src="http://upload-images.jianshu.io/upload_images/1513759-144be4c25748578e.png" alt="rear point circular linked list"><br>关于循环链表的其它操作和单链表的几乎是一样的，不再赘述。</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>循环链表是解决了单链表中查找所有结点的难题，但是它还存在一个问题：如果要查找某个结点的前驱结点，那么需要的时间复杂度是O(n)，因为我们要按照单向的指针遍历一遍。为了解决这个问题提出了双向链表的概念：双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。它的结构如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-48340e06fb86b26b.png" alt="structure of double linked list"></p>
<h3 id="双向链表的插入和删除"><a href="#双向链表的插入和删除" class="headerlink" title="双向链表的插入和删除"></a>双向链表的插入和删除</h3><p>双向链表的插入相对于单链表的插入要复杂一些，因为它涉及到两个指针的操作。如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-d028f13fa949a3e7.png" alt="insert into double linked list"><br>其中的关键步骤为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;prior = p;  // 把p赋值给s的前驱，如①</span><br><span class="line">s-&gt;next = p-&gt;next; // 把p的后继赋值给s的后继，如②</span><br><span class="line">p-&gt;next-&gt;prior = s; // 把s赋值给p的后继的前驱，如③</span><br><span class="line">p-&gt;next = s; // 把s赋值给p的后继，如④</span><br></pre></td></tr></table></figure>

<p>相对于插入操作，删除操作相对比较简单，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-c899193e34b4442d.png" alt="delete from double linked list"><br>其中的关键步骤为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p-&gt;next; // 将p的后继赋值给其前驱的后继，如①</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior; // 将p的前驱赋值给p的后继的前驱，如②</span><br><span class="line">free(p); // 释放p</span><br></pre></td></tr></table></figure>

<p>相对于单链表其查找速度更快了，但是它多出了一位来存储指向其前继结点的指针，因此是典型的用空间换取时间的做法。另外循环链表的插入相对来说比较复杂，需要把握好每一步的顺序，否则会出错。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/09/10/java-detials/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/java-detials/" itemprop="url">可能被遗漏的Java细节</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-10T16:15:27+08:00">2017-09-10</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Java中的类型转换"><a href="#Java中的类型转换" class="headerlink" title="Java中的类型转换"></a>Java中的类型转换</h3><h4 id="兼容的自动转换"><a href="#兼容的自动转换" class="headerlink" title="兼容的自动转换"></a>兼容的自动转换</h4><p>在编程中把一种类型的值赋给另一种类型的变量是合法的。如果这两种类型是兼容的，那么Java会自动对其进行类型转换。例如：把int类型的值赋给long类型的变量就可以。然而如果两种类型不兼容，那么就不会发生这种隐式的类型转换。例如，没有将double类型转化为byte类型的定义。这种不兼容的转化只能自己强制进行。<br>满足以下两个条件时，Java会自动给你进行类型转换：</p>
<ul>
<li>这两种类型是兼容的。</li>
<li>目的类型的范围要比源类型的范围大。</li>
</ul>
<p>数字类型，包括整数和浮点类型都是彼此兼容的，但是，数字类型和字符类型（char）或布尔类型（bollean）是不兼容的。</p>
<h4 id="不兼容的强制转换"><a href="#不兼容的强制转换" class="headerlink" title="不兼容的强制转换"></a>不兼容的强制转换</h4><p>虽然自动转换很好，但是它不能满足所有的需求。例如，你需要将一个int类型的变量付给一个byte类型的变量，你就需要使用(target-type)value这种转换了。下面演示将int转换为byte，如果整数超出了byte类型的取值范围，那么它的值将会因为对byte类型的值取%而减少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">byte</span> b;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">b = (<span class="keyword">byte</span>)a;</span><br></pre></td></tr></table></figure>

<p>当把浮点数转换为整数类型时会发生一种不同的转换：截断。你知道整数没有小数部分，当你把浮点数转化为整数的时候，其小数部分将会被舍弃。例如，如果将值1.23赋给一个整数，那么其结果是1，0.23被舍弃了。如果浮点数值太而不能适合目标整数类型，那么它的值将会因为对目标类型值域取模而减少。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">// Demonstrate casts.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Conversion</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       <span class="keyword">byte</span> b;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">257</span>;</span><br><span class="line">       <span class="keyword">double</span> d = <span class="number">323.142</span>;</span><br><span class="line">       System.out.println(<span class="string">"\nConversion of int to byte."</span>);</span><br><span class="line">       b = (<span class="keyword">byte</span>) i;</span><br><span class="line">       System.out.println(<span class="string">"i and b "</span> + i + <span class="string">" "</span> + b);</span><br><span class="line">       System.out.println(<span class="string">"\nConversion of double to int."</span>);</span><br><span class="line">       i = (<span class="keyword">int</span>) d;</span><br><span class="line">       System.out.println(<span class="string">"d and i "</span> + d + <span class="string">" "</span> + i);</span><br><span class="line">       System.out.println(<span class="string">"\nConversion of double to byte."</span>);</span><br><span class="line">       b = (<span class="keyword">byte</span>) d;</span><br><span class="line">       System.out.println(<span class="string">"d and b "</span> + d + <span class="string">" "</span> + b);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>该程序的输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Conversion of <span class="keyword">int</span> to <span class="keyword">byte</span>.</span><br><span class="line">i and b <span class="number">257</span> <span class="number">1</span></span><br><span class="line">Conversion of <span class="keyword">double</span> to <span class="keyword">int</span>.</span><br><span class="line">d and i <span class="number">323.142</span> <span class="number">323</span></span><br><span class="line">Conversion of <span class="keyword">double</span> to <span class="keyword">byte</span>.</span><br><span class="line">d and b <span class="number">323.142</span> <span class="number">67</span></span><br></pre></td></tr></table></figure>

<p>当值257被强制转换为byte变量时，其结果是257除以256(256是byte类型的变化范围)的余数。当把变量d转换为int类型时，它的小数部分被舍弃了。当吧变量d转换为byte类型时，它的小数部分被舍弃了，而且它的值减少为256的模，即67。</p>
<h4 id="表达式中的类型提升"><a href="#表达式中的类型提升" class="headerlink" title="表达式中的类型提升"></a>表达式中的类型提升</h4><p>在表达式中，有时候中间值的精度会比较高，它有可能超过任何一个操作数的范围。例如，考虑下面的表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> a = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">byte</span> c = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> d = a * b / c;</span><br></pre></td></tr></table></figure>

<p>其中间结果<code>a*b</code>很容易超出它的任何一个byte型操作数的范围。为了处理这种问题，当分析表达式时，Java会自动提升各个byte或者short型的操作数为int型。这意味着表达式<code>a*b</code>是使用整数而不是字节型来运算的。这样，尽管变量a和b都被指定为byte型，50*40的中间表达式的结果2000是合法的。</p>
<p>自动类型提升很好，但是有时候会引起令人疑惑的编译错误。例如，这个看起来正确的程序却会引起问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">50</span>;</span><br><span class="line">b = b * <span class="number">2</span>; <span class="comment">// Error! Cannot assign an int to a byte!</span></span><br></pre></td></tr></table></figure>

<p>这里看上去完全合法，但由于当表达式求值的时候，操作数被自动提升为了int型，所以需要强制转换才可以赋值（但是你必须考虑好溢出的情况）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">50</span>;</span><br><span class="line">b = (<span class="keyword">byte</span>)(b * <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>这样就不会有编译器错误了。</p>
<h4 id="类型提升的约定"><a href="#类型提升的约定" class="headerlink" title="类型提升的约定"></a>类型提升的约定</h4><p>除了将byte型和short型提升到int型以外，Java还定义了其它的类型提升规则。如果一个操作数是long型，那么整个表达式将被提升到long型；如果一个操作数是float型，整个表达式将被提升到float型；如果一个操作数是double型，计算结构就是double型。我们用个例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promote</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       <span class="keyword">byte</span> b = <span class="number">42</span>;</span><br><span class="line">       <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line">       <span class="keyword">short</span> s = <span class="number">1024</span>;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">50000</span>;</span><br><span class="line">       <span class="keyword">float</span> f = <span class="number">5.67f</span>;</span><br><span class="line">       <span class="keyword">double</span> d = .<span class="number">1234</span>;</span><br><span class="line">       <span class="keyword">double</span> result = (f * b) + (i / c) - (d * s);</span><br><span class="line">       System.out.println((f * b) + <span class="string">" + "</span> + (i / c) + <span class="string">" - "</span> + (d * s));</span><br><span class="line">       System.out.println(<span class="string">"result = "</span> + result);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>我们来分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> result = (f * b) + (i / c) - (d * s);</span><br></pre></td></tr></table></figure>

<p>的类型提升过程，在第一个子表达式<code>f*b</code>中，变量b被 升为float类型，该子表达式的结果当然是float类型。 接下来，在子表达式i/c，中，变量c被 升为int类型，该子表达式的结果当然是int类型。然 后，子表达式<code>d*s</code>中的变量s被 升为double类型，该子表达式的结果当然也是double类型。 最后，考虑三个中间值，float类型，int类型，和double类型。float类型加int类型的结果是float 类型。然后float类型减去 升为double类型的double类型，该表达式的最后结果是double型。</p>
<h3 id="Java中的break"><a href="#Java中的break" class="headerlink" title="Java中的break"></a>Java中的break</h3><p>Java中的break除了可以用来在switch或者循环中终止某个条件或者循环，还可以作为goto语句的一种形式来使用。Java中没有goto语句，因为goto让程序流程变得非结构化，可能让程序难以理解和维护，并且可以阻止某些编译器优化。但是，有些地方使用goto语句有助于流程控制，并且是合法的。例如，从嵌套很深的循环中退出来，goto语句就很有帮助。因此，Java定义了break语句的一种扩展形式来处理这种情况。通过给某个代码块加上标签，那么<strong>其内部的break语句</strong>就可以在某些情况下跳转到该标签。这个代码块不必非要是循环或者switch，它可以是任意的代码块。标签的指定如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using break as a civilized form of goto.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Break</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> t = <span class="keyword">true</span>;</span><br><span class="line">       first: &#123;</span><br><span class="line">         second: &#123;</span><br><span class="line">           third: &#123;</span><br><span class="line">            System.out.println(<span class="string">"Before the break."</span>);</span><br><span class="line">            <span class="keyword">if</span>(t) <span class="keyword">break</span> second; <span class="comment">// break out of second block</span></span><br><span class="line">            System.out.println(<span class="string">"This won't execute"</span>);</span><br><span class="line">&#125; </span><br><span class="line">           System.out.println(<span class="string">"This won't execute"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(<span class="string">"This is after second block."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>改程序的输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Before the <span class="built_in">break</span>.</span><br><span class="line">This is after second block.</span><br></pre></td></tr></table></figure>

<p>这个示例中有三个嵌套的代码块，每一个都有它自己的标签。break语句使得循环往外层跳转，直接跳过了second标签的的代码块，直接执行了first标签的代码块。</p>
<h3 id="Java中的方法重载"><a href="#Java中的方法重载" class="headerlink" title="Java中的方法重载"></a>Java中的方法重载</h3><p>方法重载就是说如果两个方法有相同的方法名字，但是其参数不同（参数个数不同或者参数类型不同），那么Java会根据调用时候不同的参数类型来匹配不同的方法来调用。然而有时候其类型匹配不是很精确：比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Automatic type conversions apply to overloading.</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">OverloadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"No parameters"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// Overload test for two integer parameters. </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a，<span class="keyword">int</span> b)</span> </span>&#123; </span><br><span class="line">      System.out.println(<span class="string">"a and b: "</span> + a + <span class="string">" "</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// overload test for a double parameter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside test(double) a: "</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">      OverloadDemo ob = <span class="keyword">new</span> OverloadDemo();</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">88</span>;</span><br><span class="line">      ob.test(); ob.test(<span class="number">10</span>，<span class="number">20</span>); </span><br><span class="line">      ob.test(i); <span class="comment">// this will invoke test(double)</span></span><br><span class="line">      ob.test(<span class="number">123.2</span>); <span class="comment">// this will invoke test(double)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">No parameters</span><br><span class="line">a and b: 10 20</span><br><span class="line">Inside <span class="built_in">test</span>(double) a: 88</span><br><span class="line">Inside <span class="built_in">test</span>(double) a: 123.2</span><br></pre></td></tr></table></figure>

<p>这里，我们的<code>test(i)</code>中i是int型，但是在调用时，我们发现调用<code>test(double)</code>类型，这是因为在调用<code>test(int)</code>型的时候Java找不到相应的类型，所以就将int扩大为了double，然后就调用了<code>test(double)</code>，如果我们这里定义了一个<code>test(int)</code>，那么就会调用这个<code>test(int)</code>而不会将int扩大为double。</p>
<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>在继承中，super可以用来表示父类，可以调用父类特有的方法。还有一种应用情况是：它可以用来调用父类中被子类所隐藏的属性，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i; &#125; </span><br><span class="line">    <span class="comment">// Create a subclass by extending class A.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i; <span class="comment">// this i hides the i in A</span></span><br><span class="line">      B(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">       <span class="keyword">super</span>.i = a; <span class="comment">// i in A</span></span><br><span class="line">       i = b; <span class="comment">// i in B</span></span><br><span class="line">&#125; </span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"i in superclass: "</span> + <span class="keyword">super</span>.i);</span><br><span class="line">       System.out.println(<span class="string">"i in subclass: "</span> + i);</span><br><span class="line">&#125; &#125; </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UseSuper</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       B subOb = <span class="keyword">new</span> B(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">       subOb.show();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的输出为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i <span class="keyword">in</span> superclass: 1</span><br><span class="line">i <span class="keyword">in</span> subclass: 2</span><br></pre></td></tr></table></figure>

<p>尽管B中的实例变量i隐藏了A中的i，使用super就可以访问超类中定义的i。其实， super也可以用来调用超类中被子类隐藏的方法。 </p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在类的层次结构中，构造函数的调用顺序是从父类到子类。并且父类的构造方法的调用要放在子类构造方法的第一行中。如果子类中没有用到super()，那么每个父类默认的或者无参数的构造函数将执行。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a super class.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">      A() &#123;</span><br><span class="line">       System.out.println(<span class="string">"Inside A's constructor."</span>);</span><br><span class="line">&#125; &#125; </span><br><span class="line">    <span class="comment">// Create a subclass by extending class A.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">      B() &#123;</span><br><span class="line">       System.out.println(<span class="string">"Inside B's constructor."</span>);</span><br><span class="line">&#125; &#125; </span><br><span class="line">    <span class="comment">// Create another subclass by extending B.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">      C() &#123;</span><br><span class="line">       System.out.println(<span class="string">"Inside C's constructor."</span>);</span><br><span class="line">&#125; &#125; </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CallingCons</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">C c = <span class="keyword">new</span> C(); &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序的输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside A’s constructor</span><br><span class="line">Inside B’s constructor</span><br><span class="line">Inside C’s constructor</span><br></pre></td></tr></table></figure>

<p>由此可见，构造函数以派生的顺序被调用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/09/10/chat-computer-science-basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/chat-computer-science-basic/" itemprop="url">计算机核心概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-10T10:10:40+08:00">2017-09-10</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>我们先来看一个有趣的例子：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-f48d5ace81b3d0cb.png" alt="溢出128"></p>
<p>在这里我们定义了一个<code>signed char</code>类型的数据，将其赋值为128，然后系统给我们一个警告，意思就是说它隐式地将数值给转换成了<strong>-128</strong>，这究竟是为什么呢？</p>
<p>其实在计算机中数值都是以补码的形式存储的：</p>
<blockquote>
<p>正数的补码是其自身，负数的补码是其对应的正数的反码加1。</p>
</blockquote>
<p>我们先看一下-42在计算机中是如何表示的：<br>它是先将其对象的正数42，0010 1010然后取反1101 0101，然后再加1，得到1101 0110。</p>
<p>我们知道signed char是占八位的。其存储范围是：0000 0000到1111 1111。那么128的补码还是128，其二进制表示为：1000 0000。但是这里有个问题，因为其类型是有符号的，所以最高位是符号位，也就是说这个数不能用来表示128了，那么它表示多少呢？我们就要看看它是谁的补码就是好了。我们先将<code>1000 0000</code>取反，然后的到<code>0111 1111</code>，加一得到<code>1000 0000</code>，再乘以-1,得到-128。如果不太明白，我我们可以将128变大，变成129：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-d236d51fa77178ad.png" alt="溢出129"></p>
<p>129为整数，其补码是其自身，1000 0001，又因为其最高位是符号位，所以其表示的是一个负数，它表示多少呢？先将其取反<code>0111 1110</code>，然后+1得到<code>0111 1111</code>，这时127，最后乘以-1得到-127。</p>
<h3 id="switch语句为什么比if-else快？"><a href="#switch语句为什么比if-else快？" class="headerlink" title="switch语句为什么比if else快？"></a>switch语句为什么比if else快？</h3><p>因为编译器在编译switch语句的时候会检查每个case常量，并且会创建出一个”跳转表”，这个表用来在表达式的基础上选择执行路径，其时间复杂度是O(1)，而if else的时间复杂度是O(n)，所以switch case要比if else快很多。</p>
<h3 id="寄存器是什么？"><a href="#寄存器是什么？" class="headerlink" title="寄存器是什么？"></a>寄存器是什么？</h3><p>寄存器是一种存储信息的硬件，它和内存一样可以用来存储，但是和内存不同的是，它的速度极其快（比RAM的主存要快得多，它还有一些辅助功能，它常常被用做软件和外设之间通信的桥梁，起到缓冲的作用，同时CPU中寄存器速度非常快，这就让经常需要用到的数据放到寄存器中，而不需要每次都从主存中去读取，从而提高了程序的执行速度。软件将信息写入寄存器，然后外设将信息从寄存器中读出去。如果外设有信息需要软件进行处理，那么它也需要先将信息放到寄存器中，然后有软件从中读取。寄存器的主要功能包括：</p>
<ul>
<li>某些功能的配置和初始化，特别是在初始化阶段</li>
<li>缓存存储</li>
<li>不同种类的输入输出</li>
<li>状态报告，比如某个硬件的状态发生了变化</li>
</ul>
<p>常见的寄存器包括：MAR(Memory Address Register)，这个寄存器主要用来存放下一条即将执行的指令，CPU根据MAR中指令的地址取出指令，然后放到MDR(Memory Data Register中，然后CIR(Current Instruction Regitster)将指令从MDR中拷贝一份。MBR(Memory Buffer Register)，用来存放要放入存储器的数据和从存储器中读出的数据。<a href="https://www.youtube.com/watch?time_continue=220&v=TBADs7knuWM" target="_blank" rel="noopener">相关资料可以参考YouTube</a></p>
<h3 id="CPU为什么需要三级缓存？"><a href="#CPU为什么需要三级缓存？" class="headerlink" title="CPU为什么需要三级缓存？"></a>CPU为什么需要三级缓存？</h3><p>CPU和内存的速度不匹配是计算机领域的一个重要问题，如果内存中采用和CPU中相同型号的寄存器，那么其代价又会太高，并且根据局部性原理，这种需求是没有必要的。存储器的<strong>价格，速度，容量</strong>是人们考虑的主要因素，但是它们之间也存在这制约因素：速度越快，价格就越高；容量越大，价格越高；容量越大，速度越低。根据局部性原理(Principle of Locality)我们的程序中常用的数据又基本都是固定的。所以就在CPU和内存之间采用了三级缓存（它内部存储的）来提高获取数据的速度，如果数据能在L1，L2，L3中找到的话就直接从中取，如果没有再从内存取，如果内存没有，再从外存取，这样就会提高获取数据的速度。<strong>这里要注意每个处理器都有其自己的缓存区，最后他们共享一块内存，这就会造成数据不一致的严重问题。</strong></p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>在多任务执行的时候，上下文切换是指从一个线程或者进程切换到另外一个线程或者进程，这里的上下文是指：<strong>CPU寄存器和程序计数器中的内容。</strong>它的具体内容包含以下三个步骤：</p>
<ol>
<li>挂起当前进程，将当前的CPU状态保存至内存</li>
<li>从内存中获取接下来将要执行进程的上下文，并且将其存入CPU寄存器中</li>
<li>返回程序计数器指定的位置（例如进程被终止的点）并且继续执行进程</li>
</ol>
<p>这里的切换包含进程切换和线程切换两种情况，它们之间的相同点和不同点为：</p>
<h4 id="一、进程切换"><a href="#一、进程切换" class="headerlink" title="一、进程切换"></a>一、进程切换</h4><p>虚拟内存空间不能保持相同；调用操作系统内核；寄存器内容的切入切出和内核操作的转移是最消耗性能的；</p>
<h4 id="二、线程切换"><a href="#二、线程切换" class="headerlink" title="二、线程切换"></a>二、线程切换</h4><p>虚拟内存空间保持相同；调用操作系统内核；寄存器内容的切入切出和内核操作的转移是最消耗性能的；</p>
<p>这其中还有一个隐含的性能消耗点是：处理器缓存系统的失效。在虚拟内存空间切换的过程中会导致处理器的Translation Lookaside Buffer (TLB) 失效，这会造成很大的内存损耗。造成上下文切换的原因有：进程自动让出其时间片，或者调度器给它分配的时间片到了，或者硬件发生了中断操作，加锁，或者其它的软件操作也会造成上下文切换。上下文切换很消耗大量的CPU时间造成较大的性能损耗。</p>
<h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><p>线程是寄存器的一组状态，这组状态用来规定程序的执行顺序，执行地址，以及下条指令的地址。</p>
<h3 id="什么是指令重排？"><a href="#什么是指令重排？" class="headerlink" title="什么是指令重排？"></a>什么是指令重排？</h3><p>指令重排就是在执行程序的过程中，在确保不影响程序输出结果的情况下，为了提升性能，编译器和处理器对指令做的重排序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-54707f7dafa478cf.png" alt="ReSortInstruction"></p>
<p>指令重排可以带来性能的提升，它在单线程的情况下是不会出问题的，这一点是由<strong>程序的顺序规则来保证的</strong>，如果是在多线程就会出现各种意想不到的问题。比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread one = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            a = <span class="number">1</span>;  <span class="comment">// A1</span></span><br><span class="line">            x = b;  <span class="comment">// A2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread two = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            b = <span class="number">2</span>;  <span class="comment">//B1</span></span><br><span class="line">            y = a;  <span class="comment">//B2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    one.start();</span><br><span class="line">    two.start();</span><br><span class="line">    one.join();</span><br><span class="line">    two.join();</span><br><span class="line">    System.out.println(<span class="string">"x ="</span> + x + <span class="string">";"</span> + <span class="string">"y ="</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码不仅可以输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span> ; y = <span class="number">1</span></span><br><span class="line">x = <span class="number">2</span> ; y = <span class="number">0</span></span><br><span class="line">x = <span class="number">2</span> ; y = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>但是在A1和A2，B1和B2重排序之后还可以输出：<code>x = 0 ; y = 0</code>的情况。</p>
<p>参考资料:</p>
<ol>
<li><p><a href="https://stackoverflow.com/questions/5440128/thread-context-switch-vs-process-context-switch" target="_blank" rel="noopener">线程上下文切换和进程上下文</a></p>
</li>
<li><p><a href="http://www.linfo.org/context_switch.html" target="_blank" rel="noopener">上下文切换的定义</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/5201852/what-is-a-thread-really" target="_blank" rel="noopener">线程的定义</a></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/09/05/chat-if-else/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/05/chat-if-else/" itemprop="url">聊聊if else</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-05T07:04:01+08:00">2017-09-05</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1513759-12027b6db51d7301.png" alt="if else"><br>if else 是我们学习C语言开始用的流程控制语句。还记得大学老师说过一句话，任何复杂的业务逻辑都可以用if else去解决。然而就像面向对象中的继承一样，如果用的过多就会造成代码的腐烂。下面我们就来聊聊if else。</p>
<h2 id="为什么太多的if-else不好？"><a href="#为什么太多的if-else不好？" class="headerlink" title="为什么太多的if else不好？"></a>为什么太多的if else不好？</h2><p>我们先看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnMessage</span><span class="params">(Push.PushMessage pushMessage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String message = pushMessage.messageContent;</span><br><span class="line">        Log.v(<span class="string">"keyes"</span>, <span class="string">"pushMessage = "</span> + message);</span><br><span class="line">        <span class="keyword">if</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">            JsonObject data = <span class="keyword">new</span> JsonParser().parse(message).getAsJsonObject();</span><br><span class="line">            <span class="keyword">if</span> (data.get(<span class="string">"type"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String type = data.get(<span class="string">"type"</span>).getAsString();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"100"</span>.equals(type)) &#123;<span class="comment">//XX消息</span></span><br><span class="line">                    EventBus.getDefault().post(<span class="keyword">new</span> GrabActionEvent());</span><br><span class="line">                    PopBean bean = PushUtils.dealPushMessage(mContext, message);</span><br><span class="line">                    IDealWithPush dealWithPush = AppStateUtils.getAppState(mContext);</span><br><span class="line">                    dealWithPush.dealPush(mContext, bean);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"106"</span>.equals(type)) &#123;<span class="comment">// </span></span><br><span class="line">                    String nick = data.get(<span class="string">"nick"</span>).getAsString();</span><br><span class="line">                    WPushNotify.notification(<span class="number">106</span>, nick, <span class="string">"正在访问您的信息，请立即回复"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Gson temp = <span class="keyword">new</span> Gson();</span><br><span class="line">                    <span class="keyword">final</span> SystemNotification bean = temp.fromJson(pushMessage.messageContent, SystemNotification.class);</span><br><span class="line">                    <span class="keyword">if</span> (bean.getType() == <span class="number">103</span>) &#123;</span><br><span class="line">                        <span class="comment">//应用在后台，不需要刷新UI,通知栏提示新消息</span></span><br><span class="line">                        <span class="keyword">if</span> (!AppInfoUtils.isRunningForeground(HyApplication.getApplication())) &#123;</span><br><span class="line">                            WPushNotify.notification(bean);</span><br><span class="line">                        &#125;</span><br><span class="line">                        saveDataToDB(bean);</span><br><span class="line">                        EventBus.getDefault().post(bean);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bean.getType() == <span class="number">104</span>) &#123;</span><br><span class="line">                        List&lt;Activity&gt; list = HyApplication.getInstance().getActivityList();</span><br><span class="line">                        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            Activity activity = list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">if</span> (!TextUtils.isEmpty(bean.getDescribe())) &#123;</span><br><span class="line">                                <span class="keyword">new</span> LogoutDialog(activity, bean.getDescribe());</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">new</span> LogoutDialog(activity, activity.getString(R.string.force_exit));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bean.getType() == <span class="number">108</span>) &#123;<span class="comment">//沉默用户唤醒</span></span><br><span class="line">                        String title = bean.getTitle();</span><br><span class="line">                        String describe = bean.getDescribe();</span><br><span class="line">                        WPushNotify.notification(<span class="number">108</span>, title, describe);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LogUtils.e(<span class="string">"push"</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.i(<span class="string">"song"</span>, pushMessage.messageContent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法里面仅仅嵌套了好多层if else，看上去会比较复杂难懂，再看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isSkipPPUForQA &amp;&amp; StringUtils.isNotBlank(request.getParameter(<span class="string">"userId"</span>)))&#123;</span><br><span class="line">    <span class="keyword">super</span>.doFilter(request, response, chain);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"/app/school/article/share"</span>.equals(request.getRequestURI()))&#123;</span><br><span class="line">        <span class="keyword">super</span>.doFilter(request, response, chain);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!filterReqUrl(request)) &#123;</span><br><span class="line">                <span class="keyword">long</span> ppuUserId = PassportService.passportService.getLoginUserId(RemoteValid.SAPCE_ONE_HOUR, request, response);</span><br><span class="line">                <span class="keyword">if</span> (ppuUserId &lt; <span class="number">2</span>) &#123;</span><br><span class="line">response.getWriter().write(<span class="keyword">this</span>.generateResponse(AppResultStateEnum.PPU_UNVALID.getCodeStr(), <span class="string">"登录认证信息已过期，请重新登录"</span>));</span><br><span class="line">                    log.error(<span class="string">"ppu返回的userId:"</span> + ppuUserId + <span class="string">",ppu过期,ppu="</span> + PPUCookieUtil.getPpuCookie(request) + <span class="string">",url="</span> + request.getRequestURI());</span><br><span class="line">                    log.error(<span class="string">"imei="</span> + request.getParameter(<span class="string">"imei"</span>) + <span class="string">",version="</span> + request.getParameter(<span class="string">"version"</span>) + <span class="string">",platform="</span> + request.getParameter(<span class="string">"platform"</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> flag = isTouchSingleDeviceLimitWithoutLogin(ppuUserId, request);</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                        String singleDeviceLoginContent = configComp.getValueByConfigTable(ConfigEnum.APP_SINGLE_DEVICE_LOGIN_CONTENT);</span><br><span class="line">                        <span class="keyword">boolean</span> isH5 = <span class="string">"1"</span>.equals(request.getParameter(<span class="string">"isH5"</span>));</span><br><span class="line">                        <span class="keyword">if</span>(isH5)&#123;</span><br><span class="line">                            String jsAjaxHeader = request.getHeader(<span class="string">"X-Requested-With"</span>);</span><br><span class="line">                            <span class="keyword">if</span>(<span class="string">"XMLHttpRequest"</span>.equals(jsAjaxHeader))&#123;response.getWriter().write(<span class="keyword">this</span>.generateResponse(AppResultStateEnum.SINGLE_DEVICE_LOGIN.getCodeStr(), singleDeviceLoginContent));</span><br><span class="line">                            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                             renderSingleDeviceHtml(response,<span class="string">"/single_device_error"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            response.getWriter().write(<span class="keyword">this</span>.generateResponse(AppResultStateEnum.SINGLE_DEVICE_LOGIN.getCodeStr(), singleDeviceLoginContent));</span><br><span class="line">                        &#125;</span><br><span class="line">                        log.error(<span class="string">"触发单设备登录限制错误"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        request.addParameter(<span class="string">"userId"</span>, <span class="keyword">new</span> String[]&#123;ppuUserId + <span class="string">""</span>&#125;);</span><br><span class="line">                        <span class="keyword">super</span>.doFilter(request, response, chain);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"业务处理异常,url="</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一，这个方法中嵌套了七层的if else，层次太多。第二这个方法太长。嵌套层次过多和方法过长都是Bad Smell。那么究竟很多的if else有哪些弊端呢？</p>
<ul>
<li><p><strong>僵化</strong>：如果再有更多情况的时候，我们需要在原来的地方写更多的if…else if条件。也就是说你需要去改动原来的代码，然后重新编译，重新部署，这是很浪费时间的。并且这违背了面向对象中的<strong>开放封闭原则</strong>：对扩展开放，对修改封闭。同时由于这个类需要处理各种业务，职责太多，所以也违背了<strong>职责单一原则。</strong></p>
</li>
<li><p><strong>效率低下</strong>：很多系统的类，比如<code>HashMaps</code>，<code>Properties</code>等，都非常注意基于数据的条件判断。</p>
</li>
<li><p><strong>难阅读</strong>：像这种层层if else嵌套的情况，如果其他人需要来看，并且维护这份代码，由于难阅读，他们会感觉吃力。试想下，如果段代码很长，一个屏看不完，那肯定是维护的灾难。</p>
</li>
<li><p><strong>难维护</strong>：if else不像switch case，它的每个分支都和其它分支有关系，如果需求变更，在修改某个分支之前要看懂其它所有分支，确保不会对其它分支造成影响。</p>
</li>
<li><p><strong>难调试</strong>：很多if else，调试过程中需要一步步跟进，会影响调试效率。</p>
</li>
<li><p><strong>难测试</strong>：每次我们写测试用例的Case，针对每个有很多if else的方法，我们要对每个分支都写一个测试，这样下来这个测试用例将会变得非常长。</p>
</li>
</ul>
<blockquote>
<p>在任何面向对象语言中，都需要考虑移除分支控制逻辑（<code>if</code>以及<code>switch</code>，<code>case</code>）。移除的常用做法是将这些控制逻辑的方法移到一个类中。 <a href="https://www.quora.com/Why-should-Java-programmers-try-to-avoid-if-statements" target="_blank" rel="noopener">Quora,Simon Hayes</a></p>
</blockquote>
<p>那么我们怎样来解决这种情况，因为遇到不同的情况需要用不同的解决方案，我们逐个来分析：</p>
<h2 id="常见的嵌套类if-else处理方式"><a href="#常见的嵌套类if-else处理方式" class="headerlink" title="常见的嵌套类if else处理方式"></a>常见的嵌套类if else处理方式</h2><p>比如第一个if else的例子，通常</p>
<h2 id="平行类的if-else处理方式"><a href="#平行类的if-else处理方式" class="headerlink" title="平行类的if else处理方式"></a>平行类的if else处理方式</h2><p><strong>如果我们有几个判断条件是平级if，那么我们可以使用命令模式来解决这种问题。</strong>比如我们现在有如下的if else：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value.equals(<span class="string">"A"</span>)) &#123; doCommandA() &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (value.equals(<span class="string">"B"</span>)) &#123; doCommandB() &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> etc.</span><br></pre></td></tr></table></figure>

<p>这时，我们可以使用<strong>命令模式</strong>来解决，先创建一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>CommandA</code>和<code>CommandB</code>类实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">CommandA</span><span class="params">()</span> implements Command </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">CommandB</span><span class="params">()</span> implements Command </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建一个<code>Map&lt;String,Command&gt;</code>,并且往其中添加Command实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commandMap.put(<span class="string">"A"</span>, <span class="keyword">new</span> CommandA());</span><br><span class="line">commandMap.put(<span class="string">"B"</span>, <span class="keyword">new</span> CommandB());</span><br></pre></td></tr></table></figure>

<p>然后所有的<strong>if/else if</strong>，就都会变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commandMap.get(value).exec();</span><br></pre></td></tr></table></figure>

<p>如果某个Command有任何的改变只需要改动某个具体的类即可，如果有新加的Command，那么只需要添加响应的Command即可。命令模式就是加了一个<strong>中间件：命令容器</strong>(就是这里的Map，根据情况可能会是List或者其它)来实现解耦。</p>
<h2 id="复杂处理算法的if-else"><a href="#复杂处理算法的if-else" class="headerlink" title="复杂处理算法的if else"></a>复杂处理算法的if else</h2><p>如果我们if之后的代码处理的业务逻辑很相似，并且这种处理算法可能会经常变动，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfElseDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> double calculateInsurance(double income, <span class="type">InputType</span> type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == smallType) &#123;</span><br><span class="line">            <span class="keyword">return</span> income*<span class="number">0.365</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == mediumType) &#123;</span><br><span class="line">            <span class="keyword">return</span> (income-<span class="number">10000</span>)*<span class="number">0.2</span>+<span class="number">35600</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == bigType) &#123;</span><br><span class="line">            <span class="keyword">return</span> (income-<span class="number">30000</span>)*<span class="number">0.1</span>+<span class="number">76500</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (income-<span class="number">60000</span>)*<span class="number">0.02</span>+<span class="number">105600</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们就可以将每个if分支中的代码单独分离到各个类中，然后再抽出一个父类，这样我们每个条件分支中就不会有很多代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InsuranceStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculateInsuranceVeryHigh</span><span class="params">(<span class="keyword">double</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (income - getAdjustment()) * getWeight() + getConstant();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getConstant</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getAdjustment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsuranceStrategyMedium</span> <span class="keyword">extends</span> <span class="title">InsuranceStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getConstant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">35600</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAdjustment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*InsuranceStrategyLow和InsuranceStrategyHigh的处理方式相似，此处略去*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IfElseDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InsuranceStrategy strategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculateInsurance</span><span class="params">(<span class="keyword">double</span> income, InputType type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == smallType) &#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> InsuranceStrategyLow();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == mediumType) &#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> InsuranceStrategyMedium();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == bigType) &#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> InsuranceStrategyHigh();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            strategy = <span class="keyword">new</span> InsuranceStrategyVeryHigh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strategy.calculate(income);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样最终不还是有if else吗？是的，最终还是有if else，但是if else的逻辑变得非常清晰，只是用于创建一个新的类。并且我们将经常变化的算法部分封装到了子类中，如果某个子类中的算法变了，只需要变动某个子类（<strong>封装变化</strong>），然后重新编译就可以了，不需要将整个项目重新编译，部署。</p>
<h2 id="区间类的if-else"><a href="#区间类的if-else" class="headerlink" title="区间类的if else"></a>区间类的if else</h2><p>如果客户端的if条件表示的是不同的范围，然后根据不同范围来选择不同的对象来处理，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Request request = <span class="keyword">new</span> Request();</span><br><span class="line">        request.addSalaryAmount = <span class="number">9999</span>;</span><br><span class="line">        <span class="keyword">if</span> (request.addSalaryAmount &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">            DivisionManager divisionManager = <span class="keyword">new</span> DivisionManager();</span><br><span class="line">            divisionManager.accept();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (request.addSalaryAmount &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">            Chief chief = <span class="keyword">new</span> Chief();</span><br><span class="line">            chief.accept();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (request.addSalaryAmount &lt;= <span class="number">10000</span>)&#123;</span><br><span class="line">            GeneralManager generalManager  = <span class="keyword">new</span> GeneralManager();</span><br><span class="line">            generalManager.accept();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"金额太大没人能批准"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子中，不同的条件分支是让不同的对象来处理这种条件。并且以后可能Request对象会添加其他的请求属性，比如offWork（请假），并且这种请求属性同样需要<code>DivisionManager</code>，<code>Chief</code>，<code>GeneralManager</code>。然而其中的处理顺序变了，并不是现在的请求等级。可能是先由<code>Chief</code>处理，再有<code>GeneralManager</code>处理，最后有<code>DivisionManager</code>来处理，那怎么办呢？难道还要写一套if else吗？<br>这时候我们就可以用责任链模式来将这一长串if else嵌套进每一个对象中去，我们可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ManagerCommand</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> requestAmount)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommManager</span> <span class="keyword">implements</span> <span class="title">ManagerCommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> CommManager superior;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuperior</span><span class="params">(CommManager superior)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.superior = superior;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivisionManager</span> <span class="keyword">extends</span> <span class="title">CommManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> requestAmount)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requestAmount&lt;<span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"部门经理批准"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( <span class="keyword">this</span>.superior != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.superior.accept(requestAmount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chief</span> <span class="keyword">extends</span> <span class="title">CommManager</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">accept</span><span class="params">(<span class="keyword">int</span> requestAmount)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (requestAmount &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"总监同意"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.superior != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.superior.accept(requestAmount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralManager</span> <span class="keyword">extends</span> <span class="title">CommManager</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> requestAmount)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requestAmount&lt;<span class="number">10000</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"总经理批准"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.superior != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.superior.accept(requestAmount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在Client端调用的时候，我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Request request = <span class="keyword">new</span> Request();</span><br><span class="line">        request.addSalaryAmount = <span class="number">999</span>;</span><br><span class="line">        DivisionManager divisionManager = <span class="keyword">new</span> DivisionManager();</span><br><span class="line">        Chief chief = <span class="keyword">new</span> Chief();</span><br><span class="line">        GeneralManager generalManager = <span class="keyword">new</span> GeneralManager();</span><br><span class="line">        divisionManager.setSuperior(chief);</span><br><span class="line">        chief.setSuperior(generalManager);</span><br><span class="line">        divisionManager.accept(request.addSalaryAmount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法的好处是：<strong>将条件和处理该条件的对象解耦，每个处理条件的对象都不知道其他对象，我们可以随时地增加或者修改处理一个请求的结构。这增加了给对象指派职责的灵活性</strong>。</p>
<blockquote>
<p>小结：其实上述的每种方式都是利用<strong>多态</strong>来解决分支带来的僵化，<a href="https://www.youtube.com/watch?v=4F72VULWFvc" target="_blank" rel="noopener">谷歌有一个视频对这个问题阐述得很好。</a>。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://stackoverflow.com/questions/10175805/how-to-avoid-a-lot-of-if-else-conditions" target="_blank" rel="noopener">https://stackoverflow.com/questions/10175805/how-to-avoid-a-lot-of-if-else-conditions</a></li>
<li><a href="https://stackoverflow.com/questions/271526/avoiding-null-statements?rq=1" target="_blank" rel="noopener">https://stackoverflow.com/questions/271526/avoiding-null-statements?rq=1</a></li>
<li><a href="https://stackoverflow.com/questions/14136721/converting-many-if-else-statements-to-a-cleaner-approach" target="_blank" rel="noopener">https://stackoverflow.com/questions/14136721/converting-many-if-else-statements-to-a-cleaner-approach</a></li>
<li><a href="https://www.youtube.com/watch?v=4F72VULWFvc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=4F72VULWFvc</a></li>
<li><a href="https://www.quora.com/Why-should-Java-programmers-try-to-avoid-if-statements" target="_blank" rel="noopener">https://www.quora.com/Why-should-Java-programmers-try-to-avoid-if-statements</a></li>
<li><a href="https://stackoverflow.com/questions/1199646/long-list-of-if-statements-in-swift/1199677#1199677" target="_blank" rel="noopener">https://stackoverflow.com/questions/1199646/long-list-of-if-statements-in-swift/1199677#1199677</a></li>
<li><a href="https://industriallogic.com/xp/refactoring/conditionalWithStrategy.html" target="_blank" rel="noopener">https://industriallogic.com/xp/refactoring/conditionalWithStrategy.html</a></li>
<li>大话设计模式</li>
<li>重构改善既有代码的设计</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="击水湘江">
            
              <p class="site-author-name" itemprop="name">击水湘江</p>
              <p class="site-description motion-element" itemprop="description">努力让明天的自己爱上今天的自己！</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">56</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">击水湘江</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
