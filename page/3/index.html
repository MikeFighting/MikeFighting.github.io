<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.3">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.3" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT" />


<meta name="description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:type" content="website">
<meta property="og:title" content="击水湘江">
<meta property="og:url" content="https://mikefighting.github.io/page/3/index.html">
<meta property="og:site_name" content="击水湘江">
<meta property="og:description" content="努力让明天的自己爱上今天的自己！">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="击水湘江">
<meta name="twitter:description" content="努力让明天的自己爱上今天的自己！">






  <link rel="canonical" href="https://mikefighting.github.io/page/3/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>击水湘江</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">击水湘江</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Born To Fight!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />Commonweal 404</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/24/avfoundation-edit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/avfoundation-edit/" itemprop="url">AVFoundation--视频编辑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-24T10:26:09+08:00">2017-08-24</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AV Foundation框架提供了很多类来方便对视频和音频的资源处理。AV Foundation框架的核心API是合成。一个合成仅仅是对一种或多种不同媒体资源track的组合。<code>AVMutableComposition</code>类提供了一个插入，移除以及管理track临时顺序的接口。你可以使用一个mutable composition来将一个新的asset和已经存在的asset集合组合在一起。如果你仅仅需要将很多的asset按序组装到一起，这些就够了。如果你想在合成的过程中执行任何定制的视频，音频处理，你需要分别加入音频混合（audio mix）和视频合成。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-78492783e7c8d858.png" alt="Mutable Composition"></p>
<p>使用<code>AVMutableAudioMix</code>类，你可以在合成的过程中定制音频。同时，你可以指定一个音轨（audio track）的最大音量，或者设定一个音量坡度（volume ramp）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-c1cb33719c5023b8.png" alt="AudioMix"></p>
<p>对于视频合成中的video track如果要编辑的话，你可以使用<code>AVMutableVideoComposition</code>类来进行处理。对于单一的视频合成来说，你可以对输出的视频文件指明渲染的大小，比例，以及时长。通过一个视频的合成指令（<code>AVMutableVideoCompositionInstruction</code>类提供），你可以改变视频的背景色并且使用layer指令。在合成过程中，你可以使用这些layer指令(<code>AVMutableVideoCompositionLayerInstruction</code>类)来对video track实现旋转，旋转坡度（transform ramps），透明度，透明度坡度（opacity ramp）。视频合成类也可以让你使用核心动画来产生响应的效果（使用<code>animationTool</code>属性）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-615e5cde04c0c133.png" alt="Video Composition"></p>
<p>使用<code>AVAssetExportSession</code>，你可以将音频混合（audio mix）和视频合成同时组合到你的合成中去。用你的composition初始化这个export session，然后将音频混合和视频混合分别赋值给<code>audioMix</code>和<code>videoComposition</code>属性即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-eea273fda859f11e.png" alt="Audio Mix And Video Composition"></p>
<h2 id="创建一个Composition"><a href="#创建一个Composition" class="headerlink" title="创建一个Composition"></a>创建一个Composition</h2><p>使用<code>AVMutableComposition</code>类来创建你自己的composition。为了添加媒体数据到你的composition，你必须通过<code>AVMutableCompositionTrack</code>类来添加一个或者多个composition tracks。最简单的情况就是用video track和audio track来创建一个mutable composition。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div></pre></td><td class="code"><pre><div class="line">AVMutableComposition *mutableComposition = [AVMutableComposition composition];</div><div class="line">// Create the video composition track.</div><div class="line">AVMutableCompositionTrack *mutableCompositionVideoTrack = [mutableComposition</div><div class="line">addMutableTrackWithMediaType:AVMediaTypeVideo</div><div class="line">preferredTrackID:kCMPersistentTrackID_Invalid];</div><div class="line">// Create the audio composition track.</div><div class="line">AVMutableCompositionTrack *mutableCompositionAudioTrack = [mutableComposition</div><div class="line">addMutableTrackWithMediaType:AVMediaTypeAudio</div><div class="line">preferredTrackID:kCMPersistentTrackID_Invalid];</div><div class="line">```   </div><div class="line"></div><div class="line">### 初始化一个Composition Track时的选项</div><div class="line"></div><div class="line">当你要往一个composition中添加一个新的track的时候，你必须提供一个media type和一个track ID。尽管视频和音频是最常用的media type，你还可以设置其它的media type，比如`AVMediaTypeSubtitle`（字幕）`AVMediaTypeText`（文本）。</div><div class="line"></div><div class="line">每一个和试听数据相关的track都有一个唯一标示叫做 track ID。如果你将这个track ID赋值为`kCMPersistentTrackID_Invalid`，那么在关联的时候系统会自动给你创建一个唯一标识。</div><div class="line"></div><div class="line">## 给一个Composition添加音视频数据</div><div class="line"></div><div class="line">一旦你使用一个或者多个track创建一个composition，那么你就可以开始将你的媒体数据media数据添加到合适的tracks上。为了将媒体数据添加到一个composition track，你需要使用AVAsset对象（媒体数据存储在这个对象内部）。你可以在某个track上使用mutable composition track接口来将多个具有相同隐含媒体类型的`track`放到一起。接下来的例子说明了怎样将两种video asset track按序放到某种composition track中：</div><div class="line"></div><div class="line">```objc</div><div class="line"></div><div class="line">// You can retrieve AVAssets from a number of places, like the camera roll for</div><div class="line">example.</div><div class="line">AVAsset *videoAsset = &lt;#AVAsset with at least one video track#&gt;;</div><div class="line">AVAsset *anotherVideoAsset = &lt;#another AVAsset with at least one video track#&gt;;</div><div class="line"></div><div class="line">// Get the first video track from each asset.</div><div class="line">AVAssetTrack *videoAssetTrack = [[videoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0]; </div><div class="line">AVAssetTrack *anotherVideoAssetTrack = [[anotherVideoAsset</div><div class="line">tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];</div><div class="line"></div><div class="line">// Add them both to the composition.</div><div class="line">[mutableCompositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,videoAssetTrack.timeRange.duration)</div><div class="line">ofTrack:videoAssetTrack atTime:kCMTimeZero error:nil];</div><div class="line"></div><div class="line">[mutableCompositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,anotherVideoAssetTrack.timeRange.duration) ofTrack:anotherVideoAssetTrack atTime:videoAssetTrack.timeRange.duration error:nil]; </div><div class="line"></div><div class="line">```   </div><div class="line"></div><div class="line">### 检索兼容的Composition Track</div><div class="line"></div><div class="line">如果可能的话，你应该对每一种媒体类型仅有一个composition track。可兼容asset track的统一可以将资源的利用降低到最少。当序列地展示媒体数据的时候，你应该将任何相同类型的媒体数据都放到同一个compsition track中。你可以查询一个mutable composition来找出和你需要的asset track相兼容的任何composition track：</div><div class="line"></div><div class="line">```objc</div><div class="line">AVMutableCompositionTrack *compatibleCompositionTrack = [mutableComposition</div><div class="line">mutableTrackCompatibleWithTrack:&lt;#the AVAssetTrack you want to insert#&gt;];</div><div class="line">if (compatibleCompositionTrack) &#123;</div><div class="line">    // Implementation continues.</div><div class="line">&#125; </div><div class="line">```   </div><div class="line"></div><div class="line">*注：将多个视频片段放到同一个composition track，在过个媒体片段转换时可能会隐性的造成掉帧现象，这种情况在嵌入式设备中尤其明显。对你的视频片段选择合适的合成track完全取决于你App的设计以及其将要展示的平台*</div><div class="line"></div><div class="line">###  生成音量坡度（Volume Ramp）</div><div class="line"></div><div class="line">在你的composition中，一个简单的`AVMutableAudioMix`对象可以单独对所有的音频track进行常用的音频处理。在你合成的过程中，使用`audioMix`类方法来创建一个audio mix，然后使用`AVMutableAudioMixInputParameters`实例来将这个audio mix和特定的track相关联。接下来的例子将会说明说明如何在一个指定的`audio track`上设置一个音量坡度来让音量在合成的过程中缓慢的消失。</div><div class="line"></div><div class="line">```objc</div><div class="line">AVMutableAudioMix *mutableAudioMix = [AVMutableAudioMix audioMix];</div><div class="line">// Create the audio mix input parameters object.</div><div class="line">AVMutableAudioMixInputParameters *mixParameters = [AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack]; </div><div class="line">// Set the volume ramp to slowly fade the audio out over the duration of the</div><div class="line">composition.</div><div class="line">[mixParameters setVolumeRampFromStartVolume:1.f toEndVolume:0.f</div><div class="line">timeRange:CMTimeRangeMake(kCMTimeZero, mutableComposition.duration)];</div><div class="line">// Attach the input parameters to the audio mix.</div><div class="line">mutableAudioMix.inputParameters = @[mixParameters];</div><div class="line">```    </div><div class="line"></div><div class="line">### 运用透明度坡度（Opacity Ramp）</div><div class="line"></div><div class="line">视频合成指令也可以用于视频和成Layer指令。一个`AVMutableVideoCompsitionLayerInstruction`对象可以对某个composition内部的某个video track使用旋转，旋转坡度，透明度，透明度坡度。某个视频合成指令的`layerInstructions`数组中layer指令的顺序决定了合成指令的过程中，来自source track的视频帧怎样被分层堆放，怎样被合成。在接下来的代码片段说明了怎样设置透明度坡度来在第一个视频结束切换第二个视频的时候产生缓慢消失的效果。</div><div class="line"></div><div class="line">```objc</div><div class="line">AVAsset *firstVideoAssetTrack = &lt;#AVAssetTrack representing the first video segment played in the composition#&gt;; </div><div class="line">AVAsset *secondVideoAssetTrack = &lt;#AVAssetTrack representing the second video</div><div class="line">  segment played in the composition#&gt;;</div><div class="line">  </div><div class="line">// Create the first video composition instruction.</div><div class="line">AVMutableVideoCompositionInstruction *firstVideoCompositionInstruction =</div><div class="line">[AVMutableVideoCompositionInstruction videoCompositionInstruction];</div><div class="line"></div><div class="line">// Set its time range to span the duration of the first video track.</div><div class="line">  firstVideoCompositionInstruction.timeRange = CMTimeRangeMake(kCMTimeZero,</div><div class="line">  firstVideoAssetTrack.timeRange.duration);</div><div class="line">  </div><div class="line">// Create the layer instruction and associate it with the composition video track. </div><div class="line">  AVMutableVideoCompositionLayerInstruction *firstVideoLayerInstruction =</div><div class="line">  [AVMutableVideoCompositionLayerInstruction</div><div class="line">  videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack];</div><div class="line">  </div><div class="line">// Create the opacity ramp to fade out the first video track over its entire duration.</div><div class="line"> [firstVideoLayerInstruction setOpacityRampFromStartOpacity:1.f toEndOpacity:0.f</div><div class="line">  timeRange:CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration)];</div><div class="line">  </div><div class="line">// Create the second video composition instruction so that the second video track isn't transparent.</div><div class="line"> AVMutableVideoCompositionInstruction *secondVideoCompositionInstruction =</div><div class="line"> [AVMutableVideoCompositionInstruction videoCompositionInstruction];</div><div class="line">  </div><div class="line">// Set its time range to span the duration of the second video track.</div><div class="line">secondVideoCompositionInstruction.timeRange =</div><div class="line">  CMTimeRangeMake(firstVideoAssetTrack.timeRange.duration,</div><div class="line">  CMTimeAdd(firstVideoAssetTrack.timeRange.duration,</div><div class="line">  secondVideoAssetTrack.timeRange.duration));</div><div class="line">  </div><div class="line">// Create the second layer instruction and associate it with the composition video track.</div><div class="line"> AVMutableVideoCompositionLayerInstruction *secondVideoLayerInstruction =</div><div class="line">  [AVMutableVideoCompositionLayerInstruction</div><div class="line">  videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack];</div><div class="line">  </div><div class="line">// Attach the first layer instruction to the first video composition instruction.</div><div class="line">firstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction]; </div><div class="line"></div><div class="line">// Attach the second layer instruction to the second video composition instruction. </div><div class="line">secondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction]; </div><div class="line"></div><div class="line">// Attach both of the video composition instructions to the video composition.</div><div class="line">  mutableVideoComposition.instructions = @[firstVideoCompositionInstruction,</div><div class="line">  secondVideoCompositionInstruction];</div><div class="line">```   </div><div class="line"></div><div class="line">### 加入核心动画效果</div><div class="line"></div><div class="line">通过使用`animationTool`属性，你可以在合成视频的时候添加核心动画效果。通过这个animation tool，你可以完成给视频添加水印，添加标题或者动画覆盖。在视频合成过程中，核心动画有两种不同的使用方式：你可以在它自己composition track的视频帧中添加一个Core Animation layer,或者你可以直接使用（Core Animation layer）来渲染核心动画效果。接下来的代码展示了怎样使用第二种方式在视频的中间来添加一个水印。</div><div class="line"></div><div class="line">```objc </div><div class="line">CALayer *watermarkLayer = &lt;#CALayer representing your desired watermark image#&gt;;</div><div class="line">CALayer *parentLayer = [CALayer layer];</div><div class="line">CALayer *videoLayer = [CALayer layer];</div><div class="line">parentLayer.frame = CGRectMake(0, 0, mutableVideoComposition.renderSize.width,</div><div class="line">mutableVideoComposition.renderSize.height);</div><div class="line">videoLayer.frame = CGRectMake(0, 0, mutableVideoComposition.renderSize.width,</div><div class="line">mutableVideoComposition.renderSize.height);</div><div class="line">[parentLayer addSublayer:videoLayer];</div><div class="line">watermarkLayer.position = CGPointMake(mutableVideoComposition.renderSize.width/2,</div><div class="line"> mutableVideoComposition.renderSize.height/4);</div><div class="line">[parentLayer addSublayer:watermarkLayer];</div><div class="line">mutableVideoComposition.animationTool = [AVVideoCompositionCoreAnimationTool</div><div class="line">videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer:videoLayer</div><div class="line">inLayer:parentLayer];</div><div class="line">```   </div><div class="line"></div><div class="line">## 综合：综合各种Assets并且保存到Camera Roll中</div><div class="line"></div><div class="line">接下来的代码例子说明了如何将两个视频asset track和一个音频asset track综合来创建一个简单的video file。它的主要功能有</div><div class="line"></div><div class="line">* 创建一个`AVMutableComposition`对象并且添加很多的`AVMutableCompositionTrack`对象</div><div class="line">* 给可兼容的composition track通过`AVAssetTrack`对象添加时间范围</div><div class="line">* 检查一个video asset的`preferredTransform`属性来确定视频的方向</div><div class="line">* 在一个合成过程中使用`AVMutableVideoCompositionLayerInstruction`对象来对一个视频track实现旋转效果</div><div class="line">* 给一个video composition对象设置合适的`renderSize`和`frameDuration`属性值。</div><div class="line">* 在导出视频文件的时候使用合成结合另一个视频合成</div><div class="line">* 将视频文件导出到`Camera Roll`文件中</div><div class="line"></div><div class="line">*注：为了展示最关键的代码，该实例略去了一个完整的应用所需要的功能点，比如：内存管理，注销观察者（对KVO的观察或者对某个通知的监听）。为了能够很好的使用AV Foundation，你需要对Cocoa有丰富的经验，以便处理可能遗漏的功能点。*</div><div class="line"></div><div class="line">### 创建Composition </div><div class="line"></div><div class="line">为了将几个不同的assets创建放到一起，你可以使用一个`AVMutableComposition`对象。创建这个composition并且将一个音频和视频track添加进去。</div><div class="line"></div><div class="line">```objc</div><div class="line">AVMutableComposition *mutableComposition = [AVMutableComposition composition];</div><div class="line">AVMutableCompositionTrack *videoCompositionTrack = [mutableComposition</div><div class="line">addMutableTrackWithMediaType:AVMediaTypeVideo</div><div class="line">preferredTrackID:kCMPersistentTrackID_Invalid];</div><div class="line">AVMutableCompositionTrack *audioCompositionTrack = [mutableComposition</div><div class="line">addMutableTrackWithMediaType:AVMediaTypeAudio</div><div class="line">preferredTrackID:kCMPersistentTrackID_Invalid];</div><div class="line">```  </div><div class="line"></div><div class="line">### 添加Assets</div><div class="line"></div><div class="line">一个空的composition没有什么作用。添加两个video asset track和audio asset track到这个composition中。</div><div class="line"></div><div class="line">```objc</div><div class="line">AVAssetTrack *firstVideoAssetTrack = [[firstVideoAsset</div><div class="line">tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];</div><div class="line">AVAssetTrack *secondVideoAssetTrack = [[secondVideoAsset</div><div class="line">tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];</div><div class="line">[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,</div><div class="line">firstVideoAssetTrack.timeRange.duration) ofTrack:firstVideoAssetTrack</div><div class="line">atTime:kCMTimeZero error:nil];</div><div class="line">[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,</div><div class="line">secondVideoAssetTrack.timeRange.duration) ofTrack:secondVideoAssetTrack</div><div class="line">atTime:firstVideoAssetTrack.timeRange.duration error:nil];</div><div class="line">[audioCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration)) ofTrack:[[audioAsset tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0] atTime:kCMTimeZero error:nil]; </div><div class="line">```  </div><div class="line"></div><div class="line">*注：假设你有两个assets，它们每一个至少包含了一个video track，第三个asset中至少包含了一个audio track。这个视频可以从Camera Roll中获取，audio track可以从音乐库或者视频自己的audio tack中获取。*</div><div class="line"></div><div class="line">### 检测视频方向</div><div class="line"></div><div class="line">一旦你将音频和视频track添加到这个composition中，你需要确保两个video track的方向正确的。默认情况下，所有的视频track假定都是水平模式的。如果你的video track在竖直模式拍摄，那么当它们输出的时候是不能被正确输出的。同样的，如果你试图将一个竖直模式的视频和一个水平模式的视频合成一个视频，那么这个输出的session就会失败。</div><div class="line"></div><div class="line">```objc</div><div class="line">BOOL isFirstVideoPortrait = NO;</div><div class="line">CGAffineTransform firstTransform = firstVideoAssetTrack.preferredTransform;</div><div class="line"></div><div class="line">// Check the first video track's preferred transform to determine if it was recorded in portrait mode. </div><div class="line">if (firstTransform.a == 0 &amp;&amp; firstTransform.d == 0 &amp;&amp; (firstTransform.b == 1.0 ||</div><div class="line"> firstTransform.b == -1.0) &amp;&amp; (firstTransform.c == 1.0 || firstTransform.c ==</div><div class="line">-1.0)) &#123;</div><div class="line">    isFirstVideoPortrait = YES;</div><div class="line">&#125; </div><div class="line">BOOL isSecondVideoPortrait = NO;</div><div class="line">CGAffineTransform secondTransform = secondVideoAssetTrack.preferredTransform;</div><div class="line"></div><div class="line">// Check the second video track's preferred transform to determine if it was</div><div class="line">recorded in portrait mode.</div><div class="line">if (secondTransform.a == 0 &amp;&amp; secondTransform.d == 0 &amp;&amp; (secondTransform.b == 1.0</div><div class="line"> || secondTransform.b == -1.0) &amp;&amp; (secondTransform.c == 1.0 || secondTransform.c</div><div class="line">== -1.0)) &#123;</div><div class="line">    isSecondVideoPortrait = YES;</div><div class="line">&#125; </div><div class="line">if ((isFirstVideoAssetPortrait &amp;&amp; !isSecondVideoAssetPortrait) ||</div><div class="line">(!isFirstVideoAssetPortrait &amp;&amp; isSecondVideoAssetPortrait)) &#123;</div><div class="line">    UIAlertView *incompatibleVideoOrientationAlert = [[UIAlertView alloc]</div><div class="line">initWithTitle:@"Error!" message:@"Cannot combine a video shot in portrait mode</div><div class="line">with a video shot in landscape mode." delegate:self cancelButtonTitle:@"Dismiss"</div><div class="line">otherButtonTitles:nil];</div><div class="line">    [incompatibleVideoOrientationAlert show];</div><div class="line">return; </div><div class="line">&#125; </div><div class="line">```   </div><div class="line"></div><div class="line">### 使用视频合成层指令</div><div class="line"></div><div class="line">一旦你知道视频片段有可兼容的视频方向，那么你就可以对每个视频段使用必要的图层指令来，并且将这些图层指令添加到视频合成中。</div><div class="line"></div><div class="line">```objc    </div><div class="line">BOOL isFirstVideoPortrait = NO;</div><div class="line">CGAffineTransform firstTransform = firstVideoAssetTrack.preferredTransform;</div><div class="line">// Check the first video track's preferred transform to determine if it was recorded in portrait mode. </div><div class="line">if (firstTransform.a == 0 &amp;&amp; firstTransform.d == 0 &amp;&amp; (firstTransform.b == 1.0 ||</div><div class="line"> firstTransform.b == -1.0) &amp;&amp; (firstTransform.c == 1.0 || firstTransform.c ==</div><div class="line">-1.0)) &#123;</div><div class="line">    isFirstVideoPortrait = YES;</div><div class="line">&#125; </div><div class="line">BOOL isSecondVideoPortrait = NO;</div><div class="line">CGAffineTransform secondTransform = secondVideoAssetTrack.preferredTransform;</div><div class="line">// Check the second video track's preferred transform to determine if it was</div><div class="line">recorded in portrait mode.</div><div class="line">if (secondTransform.a == 0 &amp;&amp; secondTransform.d == 0 &amp;&amp; (secondTransform.b == 1.0</div><div class="line"> || secondTransform.b == -1.0) &amp;&amp; (secondTransform.c == 1.0 || secondTransform.c</div><div class="line">== -1.0)) &#123;</div><div class="line">    isSecondVideoPortrait = YES;</div><div class="line">&#125; </div><div class="line">if ((isFirstVideoAssetPortrait &amp;&amp; !isSecondVideoAssetPortrait) ||</div><div class="line">(!isFirstVideoAssetPortrait &amp;&amp; isSecondVideoAssetPortrait)) &#123;</div><div class="line">    UIAlertView *incompatibleVideoOrientationAlert = [[UIAlertView alloc]</div><div class="line">initWithTitle:@"Error!" message:@"Cannot combine a video shot in portrait mode</div><div class="line">with a video shot in landscape mode." delegate:self cancelButtonTitle:@"Dismiss"</div><div class="line">otherButtonTitles:nil];</div><div class="line">    [incompatibleVideoOrientationAlert show];</div><div class="line">return; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的<code>AVAssetTrack</code>对象都有一个<code>preferredTransform</code>属性，该属性中包含了这个asset track对象的方向信息。只要这个asset track在屏幕上展示，那么这个<code>transform</code>都将会被使用。在上面的代码中，这个<code>layer instruction transform</code>被设置成了这个<code>asset track</code>的transform，以便于这个视频在新的合成中一旦调整渲染尺寸，仍然可以正常展示。</p>
<h3 id="设置渲染尺寸和帧时长"><a href="#设置渲染尺寸和帧时长" class="headerlink" title="设置渲染尺寸和帧时长"></a>设置渲染尺寸和帧时长</h3><p>为了将视频的方向固定，你必须响应地调整<code>renderSize</code>属性。你也应该对<code>frameDuration</code>属性挑选一个合适的值。比如每秒钟30次（或者30帧每秒）。默认情况下，renderScale属性被设置为1.0，这在本次合成过程中是合适的。</p>
<pre><code class="objc">  <span class="built_in">CGSize</span> naturalSizeFirst, naturalSizeSecond;
  <span class="comment">// If the first video asset was shot in portrait mode, then so was the second one</span>
   <span class="keyword">if</span> we made it here.
  <span class="keyword">if</span> (isFirstVideoAssetPortrait) {
  <span class="comment">// Invert the width and height for the video tracks to ensure that they display</span>
  properly.
      naturalSizeFirst = <span class="built_in">CGSizeMake</span>(firstVideoAssetTrack.naturalSize.height,
  firstVideoAssetTrack.naturalSize.width);
      naturalSizeSecond = <span class="built_in">CGSizeMake</span>(secondVideoAssetTrack.naturalSize.height,
  secondVideoAssetTrack.naturalSize.width);
} <span class="keyword">else</span> { 
  <span class="comment">// If the videos weren't shot in portrait mode, we can just use their natural</span>
  sizes.
      naturalSizeFirst = firstVideoAssetTrack.naturalSize;
      naturalSizeSecond = secondVideoAssetTrack.naturalSize;
  }
  <span class="keyword">float</span> renderWidth, renderHeight;
  <span class="comment">// Set the renderWidth and renderHeight to the max of the two videos widths and</span>
  heights.
  <span class="keyword">if</span> (naturalSizeFirst.width &gt; naturalSizeSecond.width) {
      renderWidth = naturalSizeFirst.width;
} <span class="keyword">else</span> { 
      renderWidth = naturalSizeSecond.width;
  }
  <span class="keyword">if</span> (naturalSizeFirst.height &gt; naturalSizeSecond.height) {
      renderHeight = naturalSizeFirst.height;
} <span class="keyword">else</span> { 
      renderHeight = naturalSizeSecond.height;
  }

 mutableVideoComposition.renderSize = <span class="built_in">CGSizeMake</span>(renderWidth, renderHeight);
  <span class="comment">// Set the frame duration to an appropriate value (i.e. 30 frames per second for</span>
  video).
 mutableVideoComposition.frameDuration = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>,<span class="number">30</span>);
</code></pre>
<h3 id="导出合成，并且将它保存到Camera-Roll中"><a href="#导出合成，并且将它保存到Camera-Roll中" class="headerlink" title="导出合成，并且将它保存到Camera Roll中"></a>导出合成，并且将它保存到Camera Roll中</h3><p>在该过程的最后一个步骤设计到将整个合成保存到一个单独的视频文件，并且将视频存储到Camera Roll中。你可以使用<code>AVAssetExportSession</code>对象来创建这个新的video文件，然后你将它传递到输出文件期望的<code>URL</code>中。然后使用<code>ALAssetLibrary</code>对象来保存这个结果视频文件到Camera Roll中。</p>
<pre><code class="objc"><span class="comment">// Create a static date formatter so we only have to initialize it once.</span>
  <span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *kDateFormatter;
  <span class="keyword">if</span> (!kDateFormatter) {
      kDateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];
      kDateFormatter.dateStyle = <span class="built_in">NSDateFormatterMediumStyle</span>;
      kDateFormatter.timeStyle = <span class="built_in">NSDateFormatterShortStyle</span>;
} 

<span class="comment">// Create the export session with the composition and set the preset to the highest quality. </span>
  <span class="built_in">AVAssetExportSession</span> *exporter = [[<span class="built_in">AVAssetExportSession</span> alloc]
  initWithAsset:mutableComposition presetName:<span class="built_in">AVAssetExportPresetHighestQuality</span>];

<span class="comment">// Set the desired output URL for the file created by the export process.</span>
exporter.outputURL = [[[[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> 
create:@YES error:<span class="literal">nil</span>] URLByAppendingPathComponent:[kDateFormatter stringFromDate:[<span class="built_in">NSDate</span> date]]] URLByAppendingPathExtension:<span class="built_in">CFBridgingRelease</span>(UTTypeCopyPreferredTagWithClass((<span class="built_in">CFStringRef</span>)<span class="built_in">AVFileTypeQuickTimeMovie</span>, 
   kUTTagClassFilenameExtension))];

<span class="comment">// Set the output file type to be a QuickTime movie.</span>
  exporter.outputFileType = <span class="built_in">AVFileTypeQuickTimeMovie</span>;
  exporter.shouldOptimizeForNetworkUse = <span class="literal">YES</span>;
  exporter.videoComposition = mutableVideoComposition;

<span class="comment">// Asynchronously export the composition to a video file and save this file to the camera roll once export completes. </span>
 [exporter exportAsynchronouslyWithCompletionHandler:^{
      <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^{
          <span class="keyword">if</span> (exporter.status == <span class="built_in">AVAssetExportSessionStatusCompleted</span>) {

 ALAssetsLibrary *assetsLibrary = [[ALAssetsLibrary alloc] init];
              <span class="keyword">if</span> ([assetsLibrary
  videoAtPathIsCompatibleWithSavedPhotosAlbum:exporter.outputURL]) {

[assetsLibrary writeVideoAtPathToSavedPhotosAlbum:exporter.outputURL completionBlock:<span class="literal">NULL</span>]; 
         } 
      } 
   }); 
}];
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/23/sdwebimage-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/23/sdwebimage-1/" itemprop="url">从SDWebImage中学到的（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-23T09:52:09+08:00">2017-08-23</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文是根据SDWebImage，Tag2.0到Tag2.6所做的总结。</p>
<h2 id="注意判空"><a href="#注意判空" class="headerlink" title="注意判空"></a>注意判空</h2><p>为了安全起见，方法中每个参数的值的异常我们都需考虑到，我们要有一个guard，然后直接返回，否则在某些特殊情况下，比如这个参数是服务端返回的，某次服务端没有返回，就会崩溃，加了guard之后就不会了，在swift中加入了<code>guard</code>关键字来做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">guard</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 变量不符合条件判断,则返回</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">```     </div><div class="line"></div><div class="line">因为在<span class="type">OC</span>中没有这样的判断，所以我们需要添加如下的代码：</div><div class="line">```objc </div><div class="line">  <span class="keyword">if</span> (!url)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">self</span>.image = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">```   </div><div class="line"></div><div class="line">## 针对某个机型做接口适配</div><div class="line"></div><div class="line">如果某个机型的手机需要做一些特殊处理，我们可以这么做：</div><div class="line"></div><div class="line">```objc</div><div class="line"> #ifdef __IPHONE_4_0</div><div class="line"> <span class="type">UIDevice</span> *device = [<span class="type">UIDevice</span> currentDevice];</div><div class="line">        <span class="keyword">if</span> ([device respondsToSelector:@selector(isMultitaskingSupported)] &amp;&amp; device.multitaskingSupported)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// When in background, clean memory in order to have less chance to be killed</span></div><div class="line">            [[<span class="type">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">                                                     selector:@selector(clearMemory)</div><div class="line">                                                         name:<span class="type">UIApplicationDidEnterBackgroundNotification</span></div><div class="line">                                                       object:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">```   </div><div class="line"></div><div class="line">这样一来就只有iPhone4会执行里面的代码（__IPHONE_4_0是系统自带的宏）。</div><div class="line"></div><div class="line">## 多线程中如何使用`<span class="type">NSFileManager</span>`</div><div class="line"></div><div class="line">如果某个方法是在后台线程中执行的，并且这个线程中使用了`<span class="type">NSFileManager</span>`，为了避免资源竞争，需要使用`[[<span class="type">NSFileManager</span> alloc] <span class="keyword">init</span>]`的方式进行初始化：</div><div class="line"></div><div class="line">```objc</div><div class="line">  <span class="comment">// Can't use defaultManager another thread</span></div><div class="line">    <span class="type">NSFileManager</span> *fileManager = [[<span class="type">NSFileManager</span> alloc] <span class="keyword">init</span>];</div><div class="line">```   </div><div class="line"></div><div class="line">## 存储图片时候不改变其图片类型</div><div class="line"></div><div class="line">如果我们在存储图片的时候要存储成某种格式的图片类型，那么可以使用：</div><div class="line"></div><div class="line">```objc</div><div class="line"> [fileManager createFileAtPath:[<span class="keyword">self</span> cachePathForKey:key] contents:<span class="type">UIImageJPEGRepresentation</span>(image, (<span class="type">CGFloat</span>)<span class="number">1.0</span>) attributes:<span class="literal">nil</span>];</div><div class="line">```   </div><div class="line"></div><div class="line">如果我们不想改变存储时候的数据类型，那么可以使用：</div><div class="line"></div><div class="line">```objc</div><div class="line">   [fileManager createFileAtPath:[<span class="keyword">self</span> cachePathForKey:key] contents:data attributes:<span class="literal">nil</span>];</div><div class="line">```   </div><div class="line"></div><div class="line">来完成。</div><div class="line"></div><div class="line">## 在<span class="type">NSOperationQueue</span>中添加立即执行的任务</div><div class="line"></div><div class="line">如果要在<span class="type">NSOperationQueue</span>中添加要立即执行的任务，那么可以这样做：</div><div class="line"></div><div class="line">```objc</div><div class="line">[cacheOutQueue addOperation:[[[<span class="type">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:@selector(queryDiskCacheOperation:) object:arguments]</div><div class="line">```   </div><div class="line"></div><div class="line"></div><div class="line">## 头文件引入过多</div><div class="line"></div><div class="line">如果我们的头文件引入过多，那么我们需要将这些头文件都放到一个新的文件中去，然后引入那个单独的文件即可，比如<span class="type">SDWebImageCompat</span>文件的存在就是为了解决这个问题：</div><div class="line"></div><div class="line">```objc</div><div class="line">#<span class="keyword">import</span> &lt;TargetConditionals.h&gt;</div><div class="line">#<span class="keyword">if</span> !<span class="type">TARGET_OS_IPHONE</span></div><div class="line">#<span class="keyword">import</span> &lt;AppKit/AppKit.h&gt;</div><div class="line">#ifndef <span class="type">UIImage</span></div><div class="line">#define <span class="type">UIImage</span> <span class="type">NSImage</span></div><div class="line">#endif</div><div class="line">#ifndef <span class="type">UIImageView</span></div><div class="line">#define <span class="type">UIImageView</span> <span class="type">NSImageView</span></div><div class="line">#endif</div><div class="line">#<span class="keyword">else</span></div><div class="line">#<span class="keyword">import</span> &lt;UIKit/UIKit.h&gt;</div><div class="line">#endif</div></pre></td></tr></table></figure>
<h2 id="从数组中找到指向同一块内存空间的指针"><a href="#从数组中找到指向同一块内存空间的指针" class="headerlink" title="从数组中找到指向同一块内存空间的指针"></a>从数组中找到指向同一块内存空间的指针</h2><p>如果要从数组中找到数值相同的指针，我们可以使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">    <span class="built_in">NSUInteger</span> idx = [cacheDelegates indexOfObjectIdenticalTo:delegate];</div><div class="line">    <span class="keyword">if</span> (idx == <span class="built_in">NSNotFound</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// Request has since been canceled</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">```     </div><div class="line"></div><div class="line">这种形式，但是要注意没有找到时候的处理。</div><div class="line"></div><div class="line"><span class="meta">## UIImage的解压缩</span></div><div class="line"></div><div class="line">PNG和JPEG等只是一种图片压缩格式，PNG是无损压缩，含有alpha通道，JPEG是有损压缩，没有alpha通道。我们每次展示图片的时候都需要先将<span class="built_in">UIImage</span>进行解压缩。解压缩默认是在主线程中进行的，如果图片较大则会造成很大的性能消耗，如果在IO线程中进行则会提高性能，框架中使用的方式是：</div><div class="line"></div><div class="line">```objc</div><div class="line"><span class="built_in">CGImageRef</span> imageRef = image.CGImage;</div><div class="line"><span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line"><span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</div><div class="line">                                                 <span class="built_in">CGImageGetWidth</span>(imageRef),</div><div class="line">                                                 <span class="built_in">CGImageGetHeight</span>(imageRef),</div><div class="line">                                                 <span class="number">8</span>,</div><div class="line">                                                 <span class="comment">// Just always return width * 4 will be enough</span></div><div class="line">                                                 <span class="built_in">CGImageGetWidth</span>(imageRef) * <span class="number">4</span>,</div><div class="line">                                                 <span class="comment">// System only supports RGB, set explicitly</span></div><div class="line">                                                 colorSpace,</div><div class="line">                                                 <span class="comment">// Makes system don't need to do extra conversion when displayed.</span></div><div class="line">                                                 kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Little); </div><div class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">    <span class="keyword">if</span> (!context) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>, <span class="built_in">CGImageGetWidth</span>(imageRef), <span class="built_in">CGImageGetHeight</span>(imageRef)&#125;;</div><div class="line">    <span class="built_in">CGContextDrawImage</span>(context, rect, imageRef);</div><div class="line">    <span class="built_in">CGImageRef</span> decompressedImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</div><div class="line">    <span class="built_in">CGContextRelease</span>(context);</div><div class="line"></div><div class="line">    <span class="built_in">UIImage</span> *decompressedImage = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:decompressedImageRef];</div><div class="line">    <span class="built_in">CGImageRelease</span>(decompressedImageRef);</div><div class="line">    <span class="keyword">return</span> [decompressedImage autorelease];</div><div class="line">```     </div><div class="line"></div><div class="line">关于<span class="built_in">UIImage</span>的解压缩，可以参考相关文章：</div><div class="line">[怎样避免<span class="built_in">UIImage</span>解压缩造成的性能消耗？](https:<span class="comment">//www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/)，[IOS中的图片解压缩](http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/)，[UIImage解压缩的两种形式](https://stackoverflow.com/questions/19682804/why-does-this-code-decompress-a-uiimage-so-much-better-than-the-naive-approach)，[谈谈IOS中图片的解压缩](http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/)</span></div><div class="line"></div><div class="line"><span class="meta">## 怎样获取某个目录下的文件大小？</span></div><div class="line"></div><div class="line">```objc</div><div class="line">-(<span class="keyword">int</span>)getSize</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">    <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [[<span class="built_in">NSFileManager</span> defaultManager] enumeratorAtPath:diskCachePath];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *fileName <span class="keyword">in</span> fileEnumerator)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSString</span> *filePath = [diskCachePath stringByAppendingPathComponent:fileName];</div><div class="line">        <span class="built_in">NSDictionary</span> *attrs = [[<span class="built_in">NSFileManager</span> defaultManager] attributesOfItemAtPath:filePath error:<span class="literal">nil</span>];</div><div class="line">        size += [attrs fileSize];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125; </div><div class="line">```  </div><div class="line"></div><div class="line"><span class="meta">## Struct初始化</span></div><div class="line"></div><div class="line">在某些情况下，Struct可以使用如下的方法进行初始化：</div><div class="line"></div><div class="line">```objc</div><div class="line"><span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>, &#123; <span class="built_in">CGImageGetWidth</span>(imageRef), <span class="built_in">CGImageGetHeight</span>(imageRef) &#125;&#125;;</div></pre></td></tr></table></figure>
<h2 id="调用方法是需要注意"><a href="#调用方法是需要注意" class="headerlink" title="调用方法是需要注意"></a>调用方法是需要注意</h2><p>在某种特殊情况下，调用方法前要判断是否该对象具有某个方法，以免引起崩溃：</p>
<pre><code class="objc">-    <span class="keyword">if</span> ([((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] &gt;= <span class="number">400</span>)
+    <span class="keyword">if</span> ([response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] &amp;&amp; [((<span class="built_in">NSHTTPURLResponse</span> *)response) statusCode] &gt;= <span class="number">400</span>)
</code></pre>
<p>因为在上述代码中<code>response</code>可能不是HTTP的response。</p>
<h2 id="ImageIO实现图片边下边展示效果"><a href="#ImageIO实现图片边下边展示效果" class="headerlink" title="ImageIO实现图片边下边展示效果"></a>ImageIO实现图片边下边展示效果</h2><p>实现渐下渐放效果是在<code>SDWebImageDownloader.m</code>文件的<code>- (void)connection:(NSURLConnection *)aConnection didReceiveData:(NSData *)data{}</code>方法中。其中的关键代码为：</p>
<pre><code class="objc"> <span class="comment">/// Create the image</span>
            <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);

<span class="meta">#ifdef TARGET_OS_IPHONE</span>
            <span class="comment">// Workaround for iOS anamorphic image</span>
            <span class="keyword">if</span> (partialImageRef)
            {
                <span class="keyword">const</span> size_t partialHeight = <span class="built_in">CGImageGetHeight</span>(partialImageRef);
                <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();
                <span class="built_in">CGContextRef</span> bmContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, width * <span class="number">4</span>, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);
                <span class="built_in">CGColorSpaceRelease</span>(colorSpace);
                <span class="keyword">if</span> (bmContext)
                {
                    <span class="built_in">CGContextDrawImage</span>(bmContext, (<span class="built_in">CGRect</span>){.origin.x = <span class="number">0.0</span>f, .origin.y = <span class="number">0.0</span>f, .size.width = width, .size.height = partialHeight}, partialImageRef);
                    <span class="built_in">CGImageRelease</span>(partialImageRef);
                    partialImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(bmContext);
                    <span class="built_in">CGContextRelease</span>(bmContext);
                }
                <span class="keyword">else</span>
                {
                    <span class="built_in">CGImageRelease</span>(partialImageRef);
                    partialImageRef = <span class="literal">nil</span>;
                }
            }
</code></pre>
<p>然后根据<code>CGImageRef</code>生成对应的<code>UIImage</code>并且将结果返回给delegate：</p>
<pre><code class="objc"><span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:partialImageRef];
[delegate imageDownloader:<span class="keyword">self</span> didUpdatePartialImage:image];
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/14/wwdc-protocol-value-type-uikit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/wwdc-protocol-value-type-uikit/" itemprop="url">怎样在UIKit中更好的使用ValueType</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-14T09:06:45+08:00">2017-08-14</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ValueType怎样用到UIView中？"><a href="#ValueType怎样用到UIView中？" class="headerlink" title="ValueType怎样用到UIView中？"></a>ValueType怎样用到UIView中？</h2><p><strong>如果两个类没有相同的父类，我们又想对它们写一个相同的逻辑</strong>，怎么办？我们可以让它们遵守同一个协议，该协议中有它们共有的属性，然后就可以复用了。这样我们就依赖Protocol而不是SuperClassl来建立一个多态。<br>分享代码不必使用继承了：<br>UIView的组合不是最优的，因为UIView的创建需要很长的时间，并且需要开辟堆空间，需要处理事件。</p>
<p>我们接下来看看怎样利用ValueType将Layout和具体的类进行分开。因为我们可能会用<code>UIView</code>也可能用<code>SKNode</code>来做其ContentView。<br>按照之前的情况，我们可能这样写：  </p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">DecoratingLayoutCell</span> : <span class="title">UITableViewCell</span> </span>{
   <span class="keyword">var</span> content: <span class="type">UIView</span>
   <span class="keyword">var</span> decoration: <span class="type">UIView</span>
   <span class="comment">// Perform layout...</span>
}
</code></pre>
<p>为了将具体的Cell和其Layout分开，我们创建一个Struct：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span> </span>{
   <span class="keyword">var</span> content: <span class="type">UIView</span>
   <span class="keyword">var</span> decoration: <span class="type">UIView</span>   
<span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
   <span class="comment">// Perform layout...</span>
   } 
}
</code></pre>
<p>然后在Cell中我们就可以这样写：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">DreamCell</span> : <span class="title">UITableViewCell</span> </span>{
   ...
   <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> {

   <span class="keyword">var</span> decoratingLayout = <span class="type">DecoratingLayout</span>(content: content, decoration:decoration)
   decoratingLayout.layout(<span class="keyword">in</span>:bounds)
}
</code></pre>
<p>同时，我们可以对UIView也用同样的Layout（封装变化）。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">DreamDetailView</span> : <span class="title">UIView</span> </span>{
   ...
   <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> {
      <span class="keyword">var</span> decoratingLayout = <span class="type">DecoratingLayout</span>(content: content, decoration:decoration)
   decoratingLayout.layout(<span class="keyword">in</span>:bounds)
} }
</code></pre>
<p>将Layout分开之后还非常有利于单元测试，比如我们想要测试我们的Layout创建出来的两个View是否符合我们的预期，我们可以这样：</p>
<pre><code class="Swift"> <span class="keyword">let</span> child1 = <span class="type">UIView</span>()
   <span class="keyword">let</span> child2 = <span class="type">UIView</span>()
   <span class="keyword">var</span> layout = <span class="type">DecoratingLayout</span>(content: child1, decoration: child2)
   layout.layout(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">120</span>, height: <span class="number">40</span>))
} 
<span class="type">XCTAssertEqual</span>(child2.frame, <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">5</span>, width: <span class="number">35</span>, height: <span class="number">30</span>))
<span class="type">XCTAssertEqual</span>(child2.frame, <span class="type">CGRect</span>(x: <span class="number">35</span>, y: <span class="number">5</span>, width: <span class="number">70</span>, height: <span class="number">30</span>))
</code></pre>
<p>因为我们的Layout代码量很小并且和其它代码是隔离的（没有继承，不是Reference Type），那么这样我们就可以很好的做局部分析。</p>
<p>有一天，我们要对SKNode也做同样的操作。所以我们也需要<code>NodeDecoratingLayout</code>：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">ViewDecoratingLayout</span> </span>{
   <span class="keyword">var</span> content: <span class="type">UIView</span>
   <span class="keyword">var</span> decoration: <span class="type">UIView</span>   
<span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
   <span class="comment">// Perform layout...</span>
   } 
} 
<span class="class"><span class="keyword">struct</span> <span class="title">NodeDecoratingLayout</span> </span>{
   <span class="keyword">var</span> content: <span class="type">SKNode</span>
   <span class="keyword">var</span> decoration: <span class="type">SKNode</span>   
<span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
   <span class="comment">// Perform layout...</span>
   content.frame = ....
   decoration.frame = ...
   } 
}
</code></pre>
<p>我们可以看到这和<code>VIewDecoratingLayout</code>是一样的。所以我们要将它封装起来，怎么封装？UIView和SKNode没有共同的父类。因为这两个结构体都有一个属性，那么我们就用一个Layout的<code>Protocol</code>来解决这个问题：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>{
   <span class="keyword">var</span> frame: <span class="type">CGRect</span> {<span class="keyword">get</span> <span class="keyword">set</span>}
}
<span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span> </span>{
   <span class="keyword">var</span> content: <span class="type">Layout</span>
   <span class="keyword">var</span> decoration: <span class="type">Layout</span>
   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
      content.frame = ...
      decoration.frame = ...
   }
}
</code></pre>
<p>然后为了让<code>UIView</code>和<code>SKNode</code>都是用这个<code>Layout</code>，我们只用<code>Protocol Extension</code>。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> : <span class="title">Layout</span></span>{}
<span class="class"><span class="keyword">extension</span> <span class="title">SKNode</span> : <span class="title">Layout</span></span>{}
</code></pre>
<blockquote>
<p>我们用Protocol和Extension实现了多态，而没有使用继承!</p>
</blockquote>
<p> 这样我们的Layout就不必依赖于UIKit了。</p>
<p>但是上面的代码有一个Bug，我们不能保证<code>content</code>和<code>decoration</code>是相同的类型，他们可能一个是<code>UIView</code>，一个是<code>SKNode</code>。我们可以使用<strong>泛型</strong>来解决这个问题。我们可以给<code>DecoratingLayout</code>添加泛型：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span>: <span class="title">Layout</span>&gt; </span>{
   <span class="keyword">var</span> content: <span class="type">Child</span>
   <span class="keyword">var</span> decoration: <span class="type">Child</span>
   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
      content.frame = ...
      decoration.frame = ...
   }
}
</code></pre>
<p>这样我么就可以保证了，content和decoration有相同的类型。使用泛型，可以让编译器对代码有一个更好的理解，然后会对代码做很多的优化。</p>
<p>但是如果出现了更加相似的布局，我们该怎样重用我们的代码呢？比如：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-c5236656635ca10c.png" alt="SimilarLayout"></p>
<p>重用代码，我们最先想到的是继承，但是继承会造成Override及变量的变更，这样我们很难从子类中就明确的推断出代码的含义，那么我们用组合来做这个事情，面对上面的第二张图，我们通常的做法是，创建两个UIView：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-8a14f1f51e4c035c.png" alt="Composition"></p>
<p>但是这样做有弊端的：类对象是很消耗性能的：开辟堆空间，内存管理，除此之外，UIView还有：绘制，事件处理。然而Struct是几乎不消耗性能，并且由于其实Value Type，所以它可以做更好的封装，你不需要关系别人对其进行修改。</p>
<p>我们可以使用如下方式：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">CascadingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>&gt; </span>{
   <span class="keyword">var</span> children: [<span class="type">Child</span>]
   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
... } 
} 
<span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>&gt; </span>{
   <span class="keyword">var</span> content: <span class="type">Child</span>
   <span class="keyword">var</span> decoration: <span class="type">Child</span>
   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> {
      content.frame = ...
      decoration.frame = ...
   }
}
</code></pre>
<p>这两种方式组合，这里我们不需要<code>Layout</code>协议有frame属性，我们只需要其有<code>layout()</code>方法即可</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>{
 <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>
}
</code></pre>
<p>然后，我们的<code>DecoratingLayout</code>和<code>CascadingLayout</code>遵守该协议即可：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>, ...&gt; : <span class="title">Layout</span> </span>{}
<span class="class"><span class="keyword">struct</span> <span class="title">CascadingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>{}
</code></pre>
<p>这之后我们就可以用组合的方式实现上文提到的UI效果了：</p>
<pre><code class="Swift"><span class="comment">// Composition of Values</span>
<span class="keyword">let</span> decoration = <span class="type">CascadingLayout</span>(children: accessories)
<span class="keyword">var</span> composedLayout = <span class="type">DecoratingLayout</span>(content: content, decoration: decoration)
composedLayout.layout(<span class="keyword">in</span>: rect)
</code></pre>
<p>为了实现这种UIView的叠加效果，我们给Layout协议添加<code>contents</code>属性：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>{
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>
  <span class="keyword">var</span> contents:[<span class="type">Layout</span>]{<span class="keyword">get</span>}  <span class="comment">// 这里可以是UIView或者SKNode</span>
}
</code></pre>
<p>但是这回出现和之前所说的一样的Bug，我们没有办法保证这个contents属性里是否既有UIView还有SKNode，为了解决这个问题，我们加上一个关联属性：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Layout</span> </span>{
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>
  associatedtype <span class="type">Content</span>
  <span class="keyword">var</span> contents:[<span class="type">Content</span>]{<span class="keyword">get</span>}  <span class="comment">// 这里可以是UIView或者SKNode</span>
}
</code></pre>
<p>然后在<code>DecoratingLayout</code>中，我们这样做：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span> : <span class="title">Layout</span>&gt; : <span class="title">Layout</span> </span>{
   ...
   <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>
   <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">Child</span>.<span class="type">Content</span>
   <span class="keyword">var</span> contents: [<span class="type">Content</span>] { <span class="keyword">get</span> }
</code></pre>
<p>如果我们要对其中的内容做以限制，那么我们可以这样做：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">DecoratingLayout</span>&lt;<span class="title">Child</span>:<span class="title">Layout</span>, <span class="title">Decoration</span>:<span class="title">Layout</span> <span class="title">where</span> <span class="title">Child</span>.<span class="title">Content</span> == <span class="title">Decoration</span>.<span class="title">Content</span>&gt; : <span class="title">Layout</span> </span>{
    <span class="keyword">var</span> content: <span class="type">Child</span>
    <span class="keyword">var</span> decoration: <span class="type">Decoration</span>
    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">layout</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span>
    <span class="keyword">typealias</span> <span class="type">Content</span> = <span class="type">Child</span>.<span class="type">Content</span>
    <span class="keyword">var</span> contents: [<span class="type">Content</span>] { <span class="keyword">get</span> }
}
</code></pre>
<p>这样我们的单元测试就不必依赖于具体的UIView或者是SKNode：</p>
<pre><code class="Swift">  <span class="function"><span class="keyword">func</span> <span class="title">testLayout</span><span class="params">()</span></span> {
   <span class="keyword">let</span> child1 = <span class="type">TestLayout</span>()
   <span class="keyword">let</span> child2 = <span class="type">TestLayout</span>()
   <span class="keyword">var</span> layout = <span class="type">DecoratingLayout</span>(content: child1, decoration: child2)
   layout.layout(<span class="keyword">in</span>: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">120</span>, height: <span class="number">40</span>))
   <span class="type">XCTAssertEqual</span>(layout.contents[<span class="number">0</span>].frame, <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">5</span>, width: <span class="number">35</span>, height: <span class="number">30</span>))
   <span class="type">XCTAssertEqual</span>(layout.contents[<span class="number">1</span>].frame, <span class="type">CGRect</span>(x: <span class="number">35</span>, y: <span class="number">5</span>, width: <span class="number">70</span>, height: <span class="number">30</span>))
}

<span class="class"><span class="keyword">struct</span> <span class="title">TestLayout</span> : <span class="title">Layout</span> </span>{
   <span class="keyword">var</span> frame: <span class="type">CGRect</span>
   ...  
}
</code></pre>
<h2 id="ValueType怎样用到Controller中"><a href="#ValueType怎样用到Controller中" class="headerlink" title="ValueType怎样用到Controller中"></a>ValueType怎样用到Controller中</h2><p>我们增加了Favoriate功能之后，我们的撤销功能消失了。为了隔离我们的Model，我们将其变为一个Struct，并且拥有之前的属性：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>{
   <span class="keyword">var</span> model: <span class="type">Model</span>
... 
} 
<span class="class"><span class="keyword">struct</span> <span class="title">Model</span> : <span class="title">Equatable</span> </span>{
    <span class="keyword">var</span> dreams: [<span class="type">Dream</span>]
    <span class="keyword">var</span> favoriteCreature: <span class="type">Creature</span>
}
</code></pre>
<p>然后将Model和View隔离的做法极其容易出bug，因为我们的Model的任何改变都要对应相应View的位置。<br>我们可以将其合并起来：</p>
<pre><code class="Swift"><span class="comment">/// Diffs the model changes and updates the UI based on the new model.</span>
    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">modelDidChange</span><span class="params">(diff: Model.Diff)</span></span> {
        <span class="comment">// Check to see if we need to update any rows that present a dream.</span>
        <span class="keyword">if</span> diff.hasAnyDreamChanges {
            <span class="keyword">switch</span> diff.dreamChange {
                <span class="keyword">case</span> .inserted?:
                    <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: diff.from.dreams.<span class="built_in">count</span>, section: <span class="type">Section</span>.dreams.rawValue)
                    tableView.insertRows(at: [indexPath], with: .automatic)

                <span class="keyword">case</span> .removed?:
                    <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: diff.from.dreams.<span class="built_in">count</span> - <span class="number">1</span>, section: <span class="type">Section</span>.dreams.rawValue)
                    tableView.deleteRows(at: [indexPath], with: .automatic)

                <span class="keyword">case</span> .updated(<span class="keyword">let</span> indexes)?:
                    <span class="keyword">let</span> indexPaths = indexes.<span class="built_in">map</span> { <span class="type">IndexPath</span>(row: $<span class="number">0</span>, section: <span class="type">Section</span>.dreams.rawValue) }
                    tableView.reloadRows(at: indexPaths, with: .automatic)

                <span class="keyword">case</span> <span class="literal">nil</span>: <span class="keyword">break</span>
            }
        }
</code></pre>
<p>如果我们的UI有各种状态，并且我们要处理这种状态，这时，该怎样处理才比较好呢？比如我们的这个App中有:展示、选择、分享三种状态。这时如果遇到状态的切换就会遇到问题，因为Cell是复用的，所以就会出现忘记清除前一种Cell的状态而引起的Bug。<br>这种情况出现的原因就是我们的ViewController持有了这些不同的状态，如果状态逐渐变多，那么就会有非常复杂的业务逻辑需要处理。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">DreamListViewController</span> : <span class="title">UITableViewController</span> </span>{
    <span class="keyword">var</span> isInViewingMode: <span class="type">Bool</span>
    <span class="keyword">var</span> sharingDreams: [<span class="type">Dream</span>]?
    <span class="keyword">var</span> selectedRows: <span class="type">IndexSet</span>?
    ... 
}
</code></pre>
<p>因为UI只能出现一种状态，所以每次我们切换状态，我们就需要给其它的两种状态进行置空，这时就很容易引起Bug，为了解决这个问题，我们可以使用<code>Enum</code>来讲这些状态进行封装。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>{
    <span class="keyword">case</span> viewing
    <span class="keyword">case</span> sharing(dreams:[<span class="type">Dream</span>])
    <span class="keyword">case</span> selecting(selectedRows: <span class="type">IndexSet</span>)
}
</code></pre>
<p>这样我们就可以避免因为状态转换而产生的Bug了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/13/server-side-json-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/13/server-side-json-model/" itemprop="url">Vapor制作JSON Model</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-13T18:16:34+08:00">2017-08-13</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上篇博客中我们讲到了怎样配置数据库，以及怎样将数据库中的数据读出并且返回给客户端，本文将说明怎样将数据库中的数据用Model来表示，并且怎样对Model进行各种操作。</p>
<h2 id="建立Class"><a href="#建立Class" class="headerlink" title="建立Class"></a>建立Class</h2><p>我们建立以个简单的<code>User</code>类，如下：</p>
<pre><code class="Swift"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{
 <span class="keyword">var</span> id: <span class="type">String</span>
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">var</span> age: <span class="type">Int</span>
    <span class="keyword">var</span> gender: <span class="type">String</span>
    <span class="keyword">var</span> imageUrl: <span class="type">String</span>
    <span class="keyword">var</span> oatch: <span class="type">String</span>

    <span class="keyword">init</span>(id: <span class="type">String</span>, name: <span class="type">String</span>, age:<span class="type">Int</span>, gender: <span class="type">String</span>, imageUrl: <span class="type">String</span>, oatch: <span class="type">String</span>) 
    {

        <span class="keyword">self</span>.id = id
        <span class="keyword">self</span>.age = age
        <span class="keyword">self</span>.name = name
        <span class="keyword">self</span>.gender = gender
        <span class="keyword">self</span>.imageUrl = imageUrl
        <span class="keyword">self</span>.oatch = oatch
    }
}
</code></pre>
<h2 id="遵守NodeRepresentable和NodeRepresentable协议"><a href="#遵守NodeRepresentable和NodeRepresentable协议" class="headerlink" title="遵守NodeRepresentable和NodeRepresentable协议"></a>遵守NodeRepresentable和NodeRepresentable协议</h2><p>从之前返回JSON时，JSONS的生成过程<code>JSON(node:someNode)</code>，那么Node是什么呢？其实就是一个遵守<code>NodeRepresentable</code>的对象，我们让User遵守<code>NodeRepresentable</code>协议，兵且实现其<code>makeNode</code>方法，这样就可以传入<code>JSON(node:user)</code>了：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">makeNode</span><span class="params">(<span class="keyword">in</span> context: Context?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Node</span> {

        <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">Node</span>(node:[
            <span class="string">"id"</span>:id,
            <span class="string">"name"</span>:name,
            <span class="string">"age"</span>:age,
            <span class="string">"gender"</span>:gender,
            <span class="string">"imageUrl"</span>:imageUrl,
            <span class="string">"oatch"</span>:oatch
            ])
    }
</code></pre>
<p>我们这样不调用<code>JSON</code>的方法，只使用我们的Model就可以创建出来JSON对象呢？我们只需要遵守<code>JSONRepresentable</code>对象即可，然后添加其需要实现的协议方法。</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">makeJSON</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">JSON</span> {
    <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">JSON</span>(node: <span class="keyword">self</span>)
}
</code></pre>
<p>然后我们就可以使用<code>user.makeJSON()</code>来创建JSON对象了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/11/vapor-prepare-data-base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/11/vapor-prepare-data-base/" itemprop="url">Swift后端Vapor安装数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-11T09:52:02+08:00">2017-08-11</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1513759-b14c0ae08140a1d3.png" alt="MySQL"></p>
<p>Vapor中使用<code>Fluent</code>作为数据库的驱动，它现在可支持的数据库类型有：MySQL，SQL lite，MongoDB，PostgreSQL。因为MySQL用得较多，我们先来学习它。</p>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="安装MySQL-Provider"><a href="#安装MySQL-Provider" class="headerlink" title="安装MySQL-Provider"></a>安装<code>MySQL-Provider</code></h3><p>在<code>Package.swift</code>文件中加入</p>
<pre><code>.Package(url: &quot;https://github.com/vapor/mysql-provider.git&quot;, majorVersion: 2)
</code></pre><p>然后执行执行<code>vapor clean</code>和<code>rm -rf .build Package.pins</code>，最后执行<code>vapor update</code>和<code>vapor build</code>。<br>安装完MySql之后报错<code>mysql/mysql.h file not found</code>以及<code>Could not build Objective-C module CMySQL</code>，这时因为MySql数据库需要更新，执行下面的指令</p>
<pre><code>brew update &amp;&amp; brew install mysql vapor/tap/cmysql pkg-config
</code></pre><p>然后再执行<code>vapor xcode</code>就可以运行成功了。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="在Droplet中添加驱动"><a href="#在Droplet中添加驱动" class="headerlink" title="在Droplet中添加驱动"></a>在Droplet中添加驱动</h3><p>我们要往<code>Config</code>对象中添加相应的<code>Provider</code>，如下所示</p>
<pre><code class="Swift"><span class="keyword">import</span> MySQLProvider
<span class="keyword">let</span> config = <span class="keyword">try</span> <span class="type">Config</span>()
<span class="keyword">try</span> config.addProvider(<span class="type">MySQLProvider</span>.<span class="type">Provider</span>.<span class="keyword">self</span>)
<span class="keyword">let</span> drop = <span class="keyword">try</span> <span class="type">Droplet</span>(config)
</code></pre>
<h3 id="配置Fluent"><a href="#配置Fluent" class="headerlink" title="配置Fluent"></a>配置Fluent</h3><p>在<code>fluent.json</code>文件中加入如下的配置</p>
<pre><code>{
    &quot;//&quot;: &quot;The underlying database technology to use.&quot;,
    &quot;//&quot;: &quot;memory: SQLite in-memory DB.&quot;,
    &quot;//&quot;: &quot;sqlite: Persisted SQLite DB (configure with sqlite.json)&quot;,
    &quot;//&quot;: &quot;Other drivers are available through Vapor providers&quot;,
    &quot;//&quot;: &quot;https://github.com/search?q=topic:vapor-provider+topic:database&quot;,
    &quot;driver&quot;: &quot;mysql&quot;,
}
</code></pre><h3 id="配置MySQL"><a href="#配置MySQL" class="headerlink" title="配置MySQL"></a>配置MySQL</h3><p>在Config文件夹下面新建文件<code>mysql.json</code>，并添加如下内容</p>
<pre><code>{
    &quot;hostname&quot;: &quot;localhost&quot;,
    &quot;user&quot;: &quot;root&quot;,
    &quot;password&quot;: &quot;yourPassword&quot;,
    &quot;database&quot;: &quot;yourDatabase&quot;
    &quot;poort&quot;: &quot;3306&quot;
}      
</code></pre><p>也可以将证书作为url传入MySQL。</p>
<pre><code>{
&quot;url&quot;: &quot;http://root:password@172.0.0.1/hello&quot;
}
</code></pre><h3 id="多份读取（Read-Replicas）"><a href="#多份读取（Read-Replicas）" class="headerlink" title="多份读取（Read Replicas）"></a>多份读取（Read Replicas）</h3><p>多份读取可以通过配置hostname或者是<code>readReplicas</code>接口数组来进行配置。在mysql.josn中加入：</p>
<pre><code>{
   {
    &quot;master&quot;: &quot;master.mysql.foo.com&quot;,
    &quot;readReplicas&quot;: [&quot;read01.mysql.foo.com&quot;, &quot;read02.mysql.foo.com&quot;],
    &quot;user&quot;: &quot;root&quot;,
    &quot;password&quot;: &quot;password&quot;,
    &quot;database&quot;: &quot;hello&quot;
   }
}
</code></pre><p><em>Tip:也可以将readReplicas用字符串表示，多个字符串用逗号分隔开。</em></p>
<h3 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h3><p>你可以在Routes中得到<code>MySQL Driver</code>（前提是在你自己的MySQL数据库中创建了<code>your_table</code>)表。</p>
<pre><code class="Swift"><span class="keyword">import</span> MySQLProvider
<span class="keyword">get</span>(<span class="string">"mysql"</span>) { req <span class="keyword">in</span>

           <span class="keyword">let</span> mysqlDriver = <span class="keyword">try</span> <span class="keyword">self</span>.mysql()
           <span class="keyword">let</span> user = <span class="keyword">try</span> mysqlDriver.raw(<span class="string">"SELECT * FROM your_table"</span>)
           <span class="keyword">let</span> reusltJon = <span class="keyword">try</span> <span class="type">JSON</span>(node: user)
           <span class="keyword">return</span> reusltJon

       }
</code></pre>
<p>然后在浏览器中输入<code>http://localhost:8080/mysql</code>，如果看到输出了相应的JSON传就证明安装成功了。</p>
<h3 id="配置缓存"><a href="#配置缓存" class="headerlink" title="配置缓存"></a>配置缓存</h3><p>在<code>Config/droplet.json</code>里面可以配置<code>fluent</code>缓存，这里<code>fluent</code>缓存走的是<code>mysql</code>：</p>
<pre><code class="Swift">{
 <span class="string">"driver"</span>: <span class="string">"fluent"</span>
}
</code></pre>
<p>下次，当启动Droplet的时候，如果出现：</p>
<pre><code class="bash">Database prepared
</code></pre>
<p>就说明安装成功了。</p>
<h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><ol>
<li>如果运行出现 </li>
</ol>
<pre><code class="bash">The current <span class="built_in">hash</span> key <span class="string">"0000000000000000"</span> is not secure.
Update hash.key <span class="keyword">in</span> Config/crypto.json before using <span class="keyword">in</span> production.
Use `openssl rand -base64 &lt;length&gt;` to generate a random string.
The current cipher key <span class="string">"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="</span> is not secure.
Update cipher.key <span class="keyword">in</span> Config/crypto.json before using <span class="keyword">in</span> production.
Use `openssl rand -base64 32` to generate a random string.
</code></pre>
<p>这说明我们需要运行<code>openssl rand -base64 &lt;length&gt;</code>，以及<code>openssl rand -base64 32</code>来产生新的hash key和cipher key，并且将原来的数值替换掉。</p>
<ol>
<li>MySql更改密码：</li>
</ol>
<p>请参考：</p>
<ol>
<li><a href="https://stackoverflow.com/questions/2101694/mysql-how-to-set-root-password-to-null" target="_blank" rel="external">https://stackoverflow.com/questions/2101694/mysql-how-to-set-root-password-to-null</a> </li>
<li><a href="https://stackoverflow.com/questions/30692812/mysql-user-db-does-not-have-password-columns-installing-mysql-on-osx" target="_blank" rel="external">https://stackoverflow.com/questions/30692812/mysql-user-db-does-not-have-password-columns-installing-mysql-on-osx</a></li>
<li><a href="https://sraji.wordpress.com/2011/08/10/how-to-reset-mysql-root-password/" target="_blank" rel="external">https://sraji.wordpress.com/2011/08/10/how-to-reset-mysql-root-password/</a></li>
<li><a href="https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating" target="_blank" rel="external">https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating</a></li>
<li><a href="https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating/9704993#comment16367803_9704993" target="_blank" rel="external">https://stackoverflow.com/questions/9624774/after-mysql-install-via-brew-i-get-the-error-the-server-quit-without-updating/9704993#comment16367803_9704993</a></li>
</ol>
<p>需要注意的是：<em><code>sudo mysqld_safe --skip-grant-tables</code>执行完之后，要重新打开一个终端执行</em>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/10/swift-server-vapor-validation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/10/swift-server-vapor-validation/" itemprop="url">Vapor中的数据校验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-10T07:10:13+08:00">2017-08-10</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>   <img src="http://upload-images.jianshu.io/upload_images/1513759-267da7a2929f0562.jpg" alt="Validation"><br>服务端在有数据请求时需要对数据进行校验然后返回响应的校验结果，比如要求必须输入邮箱，必须输入电话等，Validation工具给我们提供了非常方便的常用操作，接下来就对其使用过程做以总结（<em>本文用到的是Validation 1.2.0版本</em>）。</p>
<h2 id="Vapor中添加Validation依赖包"><a href="#Vapor中添加Validation依赖包" class="headerlink" title="Vapor中添加Validation依赖包"></a>Vapor中添加Validation依赖包</h2><p>在<code>Package.swift</code>文件中添加如下的依赖，比如：</p>
<pre><code>.Package(url: &quot;https://github.com/vapor/vapor.git&quot;, majorVersion: 2),
.Package(url: &quot;https://github.com/vapor/validation-provider.git&quot;, majorVersion: 1)
</code></pre><blockquote>
<p>之后要执行<code>vapor clean</code>或者<code>rm -rf .build Package.pins</code>，然后执行<code>vapor update</code>或者<code>swift package update</code>，<code>vapor xcode</code>，这样才可以安装好依赖。</p>
</blockquote>
<h2 id="校验实例"><a href="#校验实例" class="headerlink" title="校验实例"></a>校验实例</h2><h3 id="Alphanumeric校验"><a href="#Alphanumeric校验" class="headerlink" title="Alphanumeric校验"></a>Alphanumeric校验</h3><p> 接下来我们来做一个简单的校验，校验输入的字符串是否是a-z或者0-9在请求中加入如下代码：</p>
<pre><code class="Swift"><span class="keyword">get</span>(<span class="string">"alpha"</span>) { request <span class="keyword">in</span>
            <span class="keyword">guard</span> <span class="keyword">let</span> input = request.data[<span class="string">"input"</span>]?.string <span class="keyword">else</span> {
                <span class="keyword">throw</span> <span class="type">Abort</span>.badRequest
            }
            <span class="keyword">let</span> validInput = <span class="keyword">try</span> input.tested(by: <span class="type">OnlyAlphanumeric</span>())
            <span class="keyword">return</span> <span class="string">"validated:<span class="subst">\(validInput)</span>"</span>
}
</code></pre>
<p>我们运行程序，然后在PostMan中输入<a href="http://localhost:8080/alpha?input=example@github.com，这时会得到下面的返回值：" target="_blank" rel="external">http://localhost:8080/alpha?input=example@github.com，这时会得到下面的返回值：</a></p>
<pre><code class="Swift">{<span class="string">"identifier"</span>:<span class="string">"Validation.ValidatorError.failure"</span>,<span class="string">"reason"</span>:<span class="string">"Internal Server Error"</span>,<span class="string">"debugReason"</span>:<span class="string">"OnlyAlphanumeric failed validation: example@github.com is not alphanumeric"</span>,<span class="string">"error"</span>:<span class="literal">true</span>}
</code></pre>
<p>这也就说明了，我们传输的问本内容不符合<code>alphanumeric</code>。<br>然后我们将URL改为<code>http://localhost:8080/alpha?input=example123</code>，然后就会看到我们的返回值</p>
<pre><code>validated:example
</code></pre><h3 id="邮箱校验"><a href="#邮箱校验" class="headerlink" title="邮箱校验"></a>邮箱校验</h3><p>我们可以利用<code>EmailValidator</code>来做邮箱的校验，方法同上面一样：</p>
<pre><code class="Swift"><span class="keyword">get</span>(<span class="string">"email"</span>) { request <span class="keyword">in</span>
            <span class="keyword">guard</span> <span class="keyword">let</span> input = request.data[<span class="string">"input"</span>]?.string <span class="keyword">else</span> {
                <span class="keyword">throw</span> <span class="type">Abort</span>.badRequest
            }
            <span class="keyword">let</span> validaInput = <span class="keyword">try</span> input.tested(by: <span class="type">EmailValidator</span>())
            <span class="keyword">return</span> <span class="string">"validated:<span class="subst">\(validaInput)</span>"</span>
    }
</code></pre>
<p>然后我们输入URL：<a href="http://localhost:8080/email?input=wallaceicdi@outlook.com，然后就会的到：" target="_blank" rel="external">http://localhost:8080/email?input=wallaceicdi@outlook.com，然后就会的到：</a></p>
<pre><code>Validated: wallaceicdi@outlook.com
</code></pre><h3 id="其余自带校验工具"><a href="#其余自带校验工具" class="headerlink" title="其余自带校验工具"></a>其余自带校验工具</h3><table>
<thead>
<tr>
<th>校验类</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unique</td>
<td>输入内容是否唯一</td>
<td>someCharacter.tested(by: Unique())</td>
</tr>
<tr>
<td>Compare</td>
<td>输入内容的数值比较</td>
<td>int.tested(by:Compare.greaterThan(1))</td>
</tr>
<tr>
<td>Contains</td>
<td>输入的内容是否包含某个</td>
<td>someArray.tested(by: Contains(“1”))</td>
</tr>
<tr>
<td>Count</td>
<td>输入的内容个数</td>
<td>someArray.tested(by: Count.max(2))</td>
</tr>
<tr>
<td>Equals</td>
<td>输入的内容是否相同</td>
<td>someConent.tested(by: Equals.init(“equal”))</td>
</tr>
<tr>
<td>In</td>
<td>输入内容是否被包含</td>
<td>input.tested(by: In.init([“1”,”2”,”3”]))</td>
</tr>
</tbody>
</table>
<h2 id="创建自己的校验工具"><a href="#创建自己的校验工具" class="headerlink" title="创建自己的校验工具"></a>创建自己的校验工具</h2><p>通过参考工具自带的<code>Equals.Swift</code>：</p>
<pre><code class="Swift"><span class="comment">/// Validates that matches a given input</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Equals</span>&lt;<span class="title">T</span>&gt;: <span class="title">Validator</span> <span class="title">where</span> <span class="title">T</span>: <span class="title">Validatable</span>, <span class="title">T</span>: <span class="title">Equatable</span> </span>{
    <span class="comment">/// The value expected to be in sequence</span>
    <span class="keyword">public</span> <span class="keyword">let</span> expectation: <span class="type">T</span>

    <span class="comment">/// Initialize a validator with the expected value</span>
    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> expectation: <span class="type">T</span>) {
        <span class="keyword">self</span>.expectation = expectation
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">validate</span><span class="params">(<span class="number">_</span> input: T)</span></span> <span class="keyword">throws</span> {
        <span class="keyword">guard</span> input == expectation <span class="keyword">else</span> {
            <span class="keyword">throw</span> error(<span class="string">"<span class="subst">\(input)</span> does not equal expectation <span class="subst">\(expectation)</span>"</span>)
        }
    }
}
</code></pre>
<p>从这里面我们可以看出，只要遵守<code>Validator</code>协议，并且实现其<code>validate</code>方法即可。</p>
<p>参考文件：<br><a href="https://github.com/vapor/validation/blob/master/Tests/ValidationTests/ValidationConvenienceTests.swift" target="_blank" rel="external">https://github.com/vapor/validation/blob/master/Tests/ValidationTests/ValidationConvenienceTests.swift</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/07/wwdc-advanced-swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/wwdc-advanced-swift/" itemprop="url">Swift进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-07T22:29:53+08:00">2017-08-07</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文是对<a href="https://developer.apple.com/videos/play/wwdc2014/404/" target="_blank" rel="external">WWDC2014–AdvancedSwift的总结</a></p>
<h2 id="改变参数名"><a href="#改变参数名" class="headerlink" title="改变参数名"></a>改变参数名</h2><p>比如我们要改变Thing对象的参数名：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>{
<span class="keyword">init</span>(location: <span class="type">Thing</span>?, name:<span class="type">String</span>,
     longDescription: <span class="type">String</span>){ ... }
}
</code></pre>
<p>如果我们不想用默认的<code>Thing.init(location:Beijing, name:&quot;wall&quot;,longDescription:&quot;An amazing city&quot;)</code>这种方式进行初始化，我们可以在参数前面添加<code>label</code>的形式：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>{
  <span class="keyword">init</span>(newLocation location: <span class="type">Thing</span>?, newName name: <span class="type">String</span>,
newLongDescription longDescription: <span class="type">String</span>) { ... }
}
</code></pre>
<p>这样我们就可以使用<code>Thing.init(newLocation:Beijing, newName:&quot;wall&quot;,newLongDescription:&quot;An amazing city&quot;)</code>这种参数来进行初始化。</p>
<h2 id="匿名参数"><a href="#匿名参数" class="headerlink" title="匿名参数"></a>匿名参数</h2><p>比如下面的例子，我们不需要字典中的value，那么我们就只需要遍历其<code>key</code>即可。</p>
<pre><code class="Swift"><span class="keyword">for</span> (key,<span class="number">_</span>) <span class="keyword">in</span> dictionary {
 <span class="built_in">print</span>(\(key))
}
</code></pre>
<p>在这个例子中，我们使用下划线<code>_</code>来进行你匿名操作，略过了我们不关心的value值，而只输出了<code>key</code>的值。</p>
<p>在上面<code>Thing</code>的例子中，如果我们要移除其参数名称，那么我们可以将<code>label</code>变为下划线，这样我们在调用的时候就不必写参数名了。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>{
  <span class="keyword">init</span>(<span class="number">_</span> location: <span class="type">Thing</span>?, <span class="number">_</span> name: <span class="type">String</span>,

   <span class="number">_</span> longDescription: <span class="type">String</span>) { ... }
}
</code></pre>
<p>这样我们就可以使用<code>Thing.init(Beijing, &quot;wall&quot;,&quot;An amazing city&quot;)</code>来初始化了。</p>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>如果我们要给上面的<code>Thing</code>对象添加一个方法<code>performPull</code>来执行其是否可以被拉动的方法。</p>
<pre><code class="Swift">        <span class="comment">// The parser will call this. func performPull(object: Thing) </span>
{ <span class="keyword">if</span> <span class="comment">/* object is   pullable */</span> {      <span class="comment">/* pull it */</span> }<span class="keyword">else</span>{      <span class="comment">/* complain */</span>   } }
</code></pre>
<p>这时我们可以添加一个Protocol：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Pullable</span> </span>{
  <span class="function"><span class="keyword">func</span> <span class="title">pull</span><span class="params">()</span></span>
} 
<span class="class"><span class="keyword">class</span> <span class="title">Boards</span>: <span class="title">Thing</span>, <span class="title">Pullable</span> </span>{
<span class="function"><span class="keyword">func</span> <span class="title">pull</span><span class="params">()</span></span> {
....
}
}
</code></pre>
<p>这样我们的<code>Boards</code>类就遵守了<code>Pullable</code>协议，当我们来检查某个对象是否遵守了某个协议时，我们可以这样做：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">performPull</span><span class="params">(object: Thing)</span></span> { <span class="keyword">if</span> <span class="keyword">let</span> pullableObject = object <span class="keyword">as</span> <span class="type">Pullable</span> { pullableObject.pull()    }<span class="keyword">else</span>{ 
     <span class="built_in">print</span>(<span class="string">"You are not sure how to print a <span class="subst">\(object.name)</span>."</span>)
   } 
}
</code></pre>
<h3 id="对象转String"><a href="#对象转String" class="headerlink" title="对象转String"></a>对象转String</h3><p>如果我们要打印某个对象，并且需要打印出其中的有效信息，那么我们要像OC中实现<code>description</code>方法一样，来遵守<code>CustomStringConvertible</code>协议并且实现其中的<code>description</code>方法。<br>还有很多类似的方法</p>
<table>
<thead>
<tr>
<th>Protocol</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ExpressibleByStringLiteral</td>
<td>“abc”</td>
</tr>
<tr>
<td>ExpressibleByArrayLiteral</td>
<td>[ a, b, c ]</td>
</tr>
<tr>
<td>ExpressibleByDictionaryLiteral</td>
<td>[a: x, b: y]</td>
</tr>
<tr>
<td>Sequence</td>
<td>for x in sequence</td>
</tr>
<tr>
<td>CustomStringConvertible</td>
<td>“(convertible)”</td>
</tr>
</tbody>
</table>
<p>同样，如果我们要对某个对象使用下表，那么我们要<code>subscript</code>。怎样对某个类使用下表呢？</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p> 比如以下三个方法，其参数的形式是一样的，但是其参数类型不同，我们想把它变成一个函数，这时候我们最常想到的做法就是使用<code>Any</code>来表示任何类型的参数和任何类型的返回值。</p>
<pre><code class="Swift"><span class="comment">// 之前的三个函数</span>
<span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">(interestingValue: String)</span></span> {
  <span class="built_in">println</span>(<span class="string">"[peek] <span class="subst">\(interestingValue)</span>"</span>)
}
<span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">(interestingValue: Int)</span></span> {
  <span class="built_in">println</span>(<span class="string">"[peek] <span class="subst">\(interestingValue)</span>"</span>)
}
<span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">(interestingValue: Float)</span></span> {
  <span class="built_in">println</span>(<span class="string">"[peek] <span class="subst">\(interestingValue)</span>"</span>)
} 
<span class="comment">// 变为一个函数</span>
<span class="function"><span class="keyword">func</span> <span class="title">peek</span><span class="params">(interestingValue: Any)</span></span> {
  <span class="built_in">println</span>(<span class="string">"[peek] <span class="subst">\(interestingValue)</span>"</span>)
}
</code></pre>
<p>但是这有个问题，在我们要调用返回值的某个方法时候编译器会报错，因为我们的返回值<code>Any</code>并没有所调用的方法，也就是说我们需要一次强转，强转在代码层面是很难看的，也很麻烦，这时候我们就可以使用泛型来解决这个问题，如果我们使用了泛型，那么编译器会将输入的参数和输出的参数给我们推断出来，这样就不必强转了。并且当编译器可以推断出来是那种type的时候它会给我们做各种优化。</p>
<p>泛型在Swift中很常见，比如：<br>Array<t>以及Dictionary<k,v>：是范型的结构体<br>Optional<t>：范型枚举<br>我们也可以创建自己的泛型类</t></k,v></t></p>
<h3 id="Type间的关系"><a href="#Type间的关系" class="headerlink" title="Type间的关系"></a>Type间的关系</h3><p>比如我们要转换两个变量的值，我们可以调用下面的方法：</p>
<pre><code class="Swift"> // Exchange the values of x and y
func swap&lt;T&gt;(inout x: T, inout y: T) { 
let tmp = x     x = y     y = tmp 
} 
var studentCount = 42
var teacherCount = 7
swap(&amp;studentCount, &amp;teacherCount) // OK
var schoolName = “Homestead High School"
swap(&amp;studentCount, &amp;schoolName) // error: 'Int' is not identical to 'String'
</code></pre>
<p>有了这样的编译器提示，这样我们就可以保证了输入的两种类型是相同的，这样就会更加<strong>安全</strong>，代码也会少很多bug。</p>
<h3 id="对泛型进行Protocol限制"><a href="#对泛型进行Protocol限制" class="headerlink" title="对泛型进行Protocol限制"></a>对泛型进行Protocol限制</h3><p>我们可以给泛型加上限制，让它遵守某些协议，比如：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">indexOf</span>&lt;T&gt;<span class="params">(sought: T, inArray array: T[])</span></span> -&gt; <span class="type">Int</span>? {
  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..array.<span class="built_in">count</span> {
    <span class="keyword">if</span> array[i] == sought { <span class="comment">// error: could not find an overload for '==' that accepts the supplied arguments </span>
      <span class="keyword">return</span> i
} } 
<span class="keyword">return</span> <span class="literal">nil</span> }
</code></pre>
<p>这是编译不通过的，因为编译器不知道我们的<code>T</code>是否遵守了<code>Equatable</code>协议，如果我们将其变为<code>func indexOf&lt;T:Equatable&gt;(Sought: T, inArray array: T[]) -&gt; Int?</code>就可以编译通过了。</p>
<h3 id="实现Equatable协议"><a href="#实现Equatable协议" class="headerlink" title="实现Equatable协议"></a>实现Equatable协议</h3><p>Enum，Class以及Struct都可以实现协议，比如我们有如下的Struct，实现Equatable协议如下：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">Temperature</span> : <span class="title">Equatable</span> </span>{ 
  <span class="keyword">let</span> value: <span class="type">Int</span> = <span class="number">0</span>
}

<span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Temperature, rhs: Temperature)</span></span> -&gt; <span class="type">Bool</span> {
  <span class="keyword">return</span> lhs.value == rhs.value
}
</code></pre>
<p>当我们实现了<code>Equatable</code>，那么对于<code>!=</code>这种操作，Swift在底层就会自动帮我们实现。</p>
<h2 id="斐波那契数列的例子"><a href="#斐波那契数列的例子" class="headerlink" title="斐波那契数列的例子"></a>斐波那契数列的例子</h2><p>什么是菲波那切数列？数列的前两个数相加等于后面的一个数。 <code>0, 1, 1, 2, 3, 5, 8, 13, 21, ...</code><br>我们创建一个菲波那切数列的函数：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">Double</span> {
  <span class="keyword">return</span> n &lt; <span class="number">2</span> ? <span class="type">Double</span>(n) : fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)
}
</code></pre>
<p>这个函数的返回值仍然是一个函数，它是一个递归调用的函数，这个函数的效率极低。当你在Playground中实验的时候就会卡的不行。如果调用<code>fibonacci(44)</code>估计要十几秒的时间。原因就是它需要一个调用一个树状结构，我们用<code>fibonacci(5)</code>做个图示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-1d9abd75b75e42ea.png" alt="fibonacci(n:5)"></p>
<p>在图中我们发现fib(1)，fib(2)等函数被持续的调用，我们如果可以把这个已经计算过的数值存下来，那么以后不是就就可以直接计算了呢？这样不就可以极大的提高计算的速度。这样我们就只计算下面带星号的函数即可：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-12e6e8ab9ae865d9.png" alt="valuable func"></p>
<p>这时最先想到的就是用一个全局的字典手动来存储这个数值，实现方法如下：</p>
<pre><code class="Swift"><span class="keyword">var</span> fibonacciMemo = <span class="type">Dictionary</span>&lt;<span class="type">Int</span>, <span class="type">Double</span>&gt;() <span class="comment">// implementation detail </span> <span class="comment">// Return the nth fibonacci number: 0, 1, 1, 2, 3, 5, 8, 13, 21, ...</span> <span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">Double</span> { 
  <span class="keyword">if</span> <span class="keyword">let</span> result = fibonacciMemo[n] {
    <span class="keyword">return</span> result
  }
  <span class="keyword">let</span> result = n &lt; <span class="number">2</span> ? <span class="type">Double</span>(n) : fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)
  fibonacciMemo[n] = result
  <span class="keyword">return</span> result
} 

<span class="comment">// 1.61803399...</span>
<span class="keyword">let</span> phi = fibonacci(<span class="number">45</span>) / fibonacci(<span class="number">44</span>) <span class="comment">//0.1 seconds = 100x speedup</span>
</code></pre>
<p>这样一来，我们之前计算<code>fibonacci(44)</code>中十几秒的计算时间一下子缩短到了0.1秒，缩减了100倍。<br>如果这样做的话，我们以后每次用到这个方法就都需要写一个字典，每次把这个计算过程过一遍，并且更重要的是它不具备通用型，如果我要放进去字符串，那就不起作用了。下面我们写一个通用的函数来解决这种需要保留中间数值，并且不需要额外的全局变量<code>fibonacciMemo</code>就可以解决问题的方法。先看一个不递归时候的函数：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">memoize</span>&lt;T: Hashable, U&gt;<span class="params">(work: @escaping <span class="params">(T)</span></span></span>-&gt;<span class="type">U</span>) -&gt; (<span class="type">T</span>)-&gt;<span class="type">U</span> {

    <span class="keyword">var</span> memo = <span class="type">Dictionary</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt;()
    <span class="keyword">return</span> { x <span class="keyword">in</span>
        <span class="keyword">if</span> <span class="keyword">let</span> q = memo[x] { <span class="keyword">return</span> q }
        <span class="keyword">let</span> r = work(x)
        memo[x] = r
        <span class="keyword">return</span> r
    }
}
</code></pre>
<p>然后再来一个可以递归的方法：</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">memoize</span>&lt;T: Hashable, U&gt;<span class="params">(work: @escaping <span class="params">(<span class="params">(T)</span></span></span></span>-&gt;<span class="type">U</span>, <span class="type">T</span>) -&gt; <span class="type">U</span>) -&gt; (<span class="type">T</span>)-&gt;<span class="type">U</span> {
    <span class="keyword">var</span> memo = <span class="type">Dictionary</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt;()
    <span class="function"><span class="keyword">func</span> <span class="title">wrap</span><span class="params">(x: T)</span></span>-&gt;<span class="type">U</span> {
        <span class="keyword">if</span> <span class="keyword">let</span> q = memo[x] { <span class="keyword">return</span> q }
        <span class="keyword">let</span> r = work(wrap, x)
        memo[x] = r
        <span class="keyword">return</span> r
    }
    <span class="keyword">return</span> wrap
}
</code></pre>
<p>这两个函数包含了swift中的很多高级语法：</p>
<ul>
<li>强大的编译器推断匹配,比如你调用：</li>
</ul>
<pre><code class="Swift">     <span class="keyword">let</span> fibonacci = memoize {
    (n: <span class="type">Int</span>) <span class="keyword">in</span>
    <span class="type">String</span>(n)
}
</code></pre>
<p>那么上面泛型中的<code>T</code>就会被推断成<code>Int</code>，而<code>U</code>怎会被推断成<code>String</code>。</p>
<ul>
<li>尾随闭包，比如调用<code>let fibonacci = memoize {...}</code>的时候。</li>
<li>更通用，更安全，性能更高的泛型函数。</li>
</ul>
<p>关于这个函数，有人专门写了一篇博客来说明:<a href="https://medium.com/@mvxlr/swift-memoize-walk-through-c5224a558194" target="_blank" rel="external">https://medium.com/@mvxlr/swift-memoize-walk-through-c5224a558194</a></p>
<h2 id="泛型结构体的一个例子"><a href="#泛型结构体的一个例子" class="headerlink" title="泛型结构体的一个例子"></a>泛型结构体的一个例子</h2><pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">StringStack</span> </span>{
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(x: String)</span></span> {
items += x } 
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">String</span> {
    <span class="keyword">return</span> items.removeLast()
} 
  <span class="keyword">var</span> items: <span class="type">String</span>[]
}
</code></pre>
<p>这里我们创建了一个字符串的栈，如果我们要变为泛型，则需要：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>{
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(x: T)</span></span> {
items += x } 
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">T</span> {
    <span class="keyword">return</span> items.removeLast()
} 
  <span class="keyword">var</span> items: <span class="type">T</span>[]
}
</code></pre>
<p>这样我们就可以往里面放任何数据类型了：</p>
<pre><code class="Swift"><span class="keyword">var</span> intStack = <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()
intStack.push(<span class="number">42</span>)
</code></pre>
<p>但是当我们需要对这个Stack做<code>for in</code>操作时候，却得到了下面的错误提示：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-9d39a23bddecaefd.png" alt="for_in_error"><br>这时候我们需要理解下，什么是<code>Sequence</code>，当Swift给我们做<code>for in</code>操作的时候在底层给我们做了什么？</p>
<pre><code class="Swift"><span class="comment">// 我们代码</span>
 <span class="keyword">for</span> x <span class="keyword">in</span> someSequence {
  ...
 }
<span class="comment">// Swift翻译后的代码</span>
<span class="keyword">var</span> __g = someSequence.generate()
<span class="keyword">while</span> <span class="keyword">let</span> x = __g.next(){
...
}
</code></pre>
<p>从上面可以看到，首先我们的<code>someSequence</code>需要关联一个<code>generate</code>，并且这个<code>generate</code>需要实现一个<code>next</code>方法，这样我们就可以对这个结构体做<code>for in</code>操作了。<br>我们先看这个<code>generate()</code>，它是一个结构体，其遵守<code>Generator</code>（<code>protocol</code>)。</p>
<pre><code class="Swift"><span class="class"><span class="keyword">protocol</span> <span class="title">Generator</span> </span>{
 <span class="keyword">typealias</span> <span class="type">Element</span>
 <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> ?
}
</code></pre>
<p>然后我们创建一个遵守<code>Generator</code>的结构体：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">struct</span> <span class="title">StackGenerator</span>&lt;<span class="title">T</span>&gt; : <span class="title">Generator</span> </span>{
  <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">T</span>
  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? {
    <span class="keyword">if</span> items.isEmpty { <span class="keyword">return</span> <span class="literal">nil</span> }
    <span class="keyword">let</span> ret = items[<span class="number">0</span>]
    items = items[<span class="number">1</span>..items.<span class="built_in">count</span>]
    <span class="keyword">return</span> ret
} 
  <span class="keyword">var</span> items: <span class="type">Slice</span>&lt;<span class="type">T</span>&gt;
}
</code></pre>
<p>那么什么是<code>Sequence</code>呢？它也是一个<code>protocol</code></p>
<pre><code class="Swift"> <span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>{
  <span class="keyword">typealias</span> <span class="type">GeneratorType</span> : <span class="type">Generator</span>
  <span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">GeneratorType</span>
}
</code></pre>
<p>它关联了一个<code>Generator</code>，然后我们让新建的<code>Stack</code>遵守这个<code>Sequence</code>协议：</p>
<pre><code class="Swift"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> : <span class="title">Sequence</span> </span>{
  <span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">StackGenerator</span>&lt;<span class="type">T</span>&gt; {
    <span class="keyword">return</span> <span class="type">StackGenerator</span>( items[<span class="number">0</span>..itemCount] )
  }
}
</code></pre>
<p>这样就可以对<code>Stack</code>做<code>for in</code>操作了。</p>
<pre><code class="Swift"><span class="function"><span class="keyword">func</span> <span class="title">peekStack</span><span class="params">(s: Stack&lt;T&gt;)</span></span> {
  <span class="keyword">for</span> x <span class="keyword">in</span> s { <span class="built_in">println</span>(x) }
}
</code></pre>
<p>关于<code>Sequence</code>和<code>Generator</code>的详细说明，请看我的另外一篇博客<a href="https://mikefighting.github.io/2017/07/28/note-advance-swift-collection-protocols/">Swift中Collection的Protocol</a></p>
<h3 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h3><p>Swift是静态编译，很小的runtime。写好的代码传到设备上之后不需要再重新编译，只需要等着运行即可。Swift中的编译器，相比于C，C++，Objective-C的Clang，做了一步优化：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-3cb2500863892632.png" alt="SwiftComplier"><br>除此之外，Swift会在编译时候做以下几点</p>
<ul>
<li>全局分析App</li>
<li>使用Struct不会对Runtime的性能造成影响</li>
<li>Int，Float等很多标准库都是Struct的</li>
</ul>
<p>Swift还有去虚拟化的特点，它可以让再运行期确定的事情放到了编译期，这样就会更快了，详细内容可以参考我的另外一篇博客<a href="https://mikefighting.github.io/2017/08/01/Why-Swift-IS-swift/">为什么Swift比OC快</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/05/avfoundation-play/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/05/avfoundation-play/" itemprop="url">AVFoundation--视频播放</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-05T12:23:18+08:00">2017-08-05</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用<code>AVPlayer</code>对象可以用来控制asset的播放。在播放期间，你可以使用AVPlayerItem实例来asset的presentation state。并且一个<code>AVPlayerItemTrack</code>对象可以管理某个独立track的展示状态。展示一个视频，你可以使用<code>AVPlayerLayer</code>对象。</p>
<h2 id="播放Assets"><a href="#播放Assets" class="headerlink" title="播放Assets"></a>播放Assets</h2><p>一个player是一个控制器对象，你可以使用它来管理一个asset的播放，比如，开始和停止播放以及寻找特殊的时间点。使用<code>AVPlayer</code>实例来播放一个asset。你可以使用<code>AVQueuePlayer</code>对象来按序播放一系列的item（AVQueuePlayer是AVPlayer的一个子类）。</p>
<p>一个player给你提供了播放状态的信息，如果有需要，你可以让你的UI和player的状态相同步。通常情况下，你可以直接指出player的输出到一个特定的Core Animation的layer上(<code>AVPlayerLayer</code>或者<code>AVSynchronizedLayer</code>)对象。</p>
<blockquote>
<p>多个player layer:你可以对一个AVPlayer实例创建很多的AVPlayerLayer对象，但是只有最近创建layer才可以在屏幕上展示在视频内容。</p>
</blockquote>
<p>你不用给AVPlayer对象直接提供assets，尽管你最终想要播放的是asset。相反，你需要提供一个AVPlayerItem的实例。以个item用来管理其相关联的asset的presentation state。一个item包含一个AVPlayerItemTrack的实例，这个实例和asset中的track相对应。结构如下：<br><img src="http://upload-images.jianshu.io/upload_images/1513759-f0dabcb6010b69ad.png" alt="PlaeyItem关系图"><br>下面的图说明了你可以用不同的player同时播放一个指定的asset，但是每个player都可以用不同的方式进行渲染。例如，使用item track，你可以在播放期间让一个特定的track失效（比如，你可能不想播放一个音频部分）。<br><img src="http://upload-images.jianshu.io/upload_images/1513759-2a0e8b3648efb92a.png" alt="AVPlayerItem"></p>
<p>你可以使用一个已经存在的asset来初始化一个player，或者你可以用一个URL来初始化一个player，以便于你可以再一个特定的点来播放这个资源(<code>AVPlayerItem</code>将会对这个资源的创建和配置这个asset)。和<code>AVAsset</code>一样，仅仅初始化一个player item并不意味着它可以直接用来播放。你可以使用KVO来观察这个item的<code>status</code>属性来决定播放的时机及播放的逻辑。</p>
<h2 id="处理不同类型的Asset"><a href="#处理不同类型的Asset" class="headerlink" title="处理不同类型的Asset"></a>处理不同类型的Asset</h2><p>你可以根据将要播放的不同的Asset类型来决定怎样配置asset。一般说来，有两种不同的类型：文件类型的assets，有几种可以选择，比如：本地文件，相机胶卷，或者媒体库；另外就是基于流的assets（HTTP直播流形式）。</p>
<p><strong>基于文件的视频加载</strong>，为了播放基于文件的视频，有以下步骤：</p>
<ul>
<li>创建一个<code>AVURLAsset</code>对象。</li>
<li>使用asset创建一个<code>AVPlayerItem</code>对象</li>
<li>将一个<code>AVPlayer</code>和这个item对象相关联</li>
<li>等待，一直到这个item的<code>status</code>属性指明可以播放了（利用KVO）</li>
</ul>
<p><strong>基于HTTP直播视频流来播放</strong>，利用该URL创建一个AVPlayerItem。（你不可以直接创建一个<code>AVAsset</code>对象来代表<code>HTTP Live Stream</code>的媒体）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div></pre></td><td class="code"><pre><div class="line">	NSURL *url = [NSURL URLWithString:@"&lt;#Live stream URL#&gt;];</div><div class="line">	// You may find a test stream at</div><div class="line">	&lt;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8&gt;.</div><div class="line">	self.playerItem = [AVPlayerItem playerItemWithURL:url];</div><div class="line">	[playerItem addObserver:self forKeyPath:@"status" options:0</div><div class="line">	context:&amp;ItemStatusContext];</div><div class="line">	self.player = [AVPlayer playerWithPlayerItem:playerItem];</div><div class="line">```   </div><div class="line"></div><div class="line">当你将这个player item和以个player相结合的时候，它就变为待播放状态了。当它准备好播放的时候，这个player item创建`AVAsset`以及`AVAssetTrack`实例，你可以利用它来检测直播流的内容。想要得到这个item的播放时长，你可以观察其`duration`属性。当这个item状态变为可以播放时，这个属性就会更新到这个视频流的准确数值。</div><div class="line">*注：当这个状态变为AVPlayerItemStatusReadyToPlay的时候，这个播放时长可以使用下面的代码来获取时长*</div><div class="line"></div><div class="line">```objc </div><div class="line">    [[[[[playerItem tracks] objectAtIndex:0] assetTrack] asset] duration];</div><div class="line">```  </div><div class="line"></div><div class="line">如果你仅仅想要播放一个直播流，那么你可以走个捷径，直接使用这个`URL`创建一个player：</div><div class="line"></div><div class="line">```objc</div><div class="line">	self.player = [AVPlayer playerWithURL:&lt;#Live stream URL#&gt;];</div><div class="line">	[player addObserver:self forKeyPath:@"status" options:0</div><div class="line">	context:&amp;PlayerStatusContext];</div><div class="line">```  </div><div class="line"></div><div class="line">和asset和item一样，初始化完player之后并不意味着你可以立即使用播放了。你需要观察其`status`属性，该属性变为`AVPlayerStatusReadyToPlay`的时候就表明它可以播放了。你也可以观察`currentItem`来获取已经创建的item。</div><div class="line"></div><div class="line">**如果你不知道你要播放的URL的类型**，那么你需要这样做：</div><div class="line"></div><div class="line">1. 尝试使用这个URL来初始化一个`AVURLAsset`对象，然后加载其`tracks`key。如果tracks加载成功，那么你可以为这个asset创建一个player item。</div><div class="line">2. 如果1失败了，那么利用这个URL直接创建一个`AVPlayerItem`对象。观察这个player的`status`属性，来决定是否可以播放了。</div><div class="line"></div><div class="line">只要其中一个成功，你就可以得到一个player item，然后将其和一个player对象相关联。</div><div class="line"></div><div class="line">## 播放一个Item</div><div class="line"></div><div class="line">为了开始播放，你需要调用player的`play`方法即可：</div><div class="line"></div><div class="line">```objc</div><div class="line">	- (IBAction)play:sender &#123;</div><div class="line">	      [player play];</div><div class="line">	      </div><div class="line">	   &#125;</div><div class="line">```   </div><div class="line"></div><div class="line">除了紧紧播放以外，你可以管理播放过程中各种方面，比如，playhead的位置和速度。你也可以观察player的stata。比如，你如果想将UI和asset的presention state相同步，你就要这样做。</div><div class="line"></div><div class="line">### 改变播放速度</div><div class="line"></div><div class="line">你可以通过设定player的`rate`属性来改变其播放的速度。</div><div class="line"></div><div class="line">```objc</div><div class="line">	aPlayer.rate = 0.5;</div><div class="line">	aPlayer.rate = 2.0;</div><div class="line">```  </div><div class="line"></div><div class="line">1.0的数值表示利用当前`item`的正常速度播放，0.0速度和暂停是一样的效果。</div><div class="line">支持回播的player，可以使用一个负值来设置这这个播放速度。你可以使用`canPlayReverse`(是否支持数值-1.0的播放速度)属性来检测其是否可以支持回播，使用`canPlaySlowReverse`(支持0.0到1.0的播放速度)，以及`canPlayFastReverse`(支持小于-1.0的播放速度)</div><div class="line"></div><div class="line">### 寻找-重置Playhead</div><div class="line"></div><div class="line">为了将playhead移动到一个特定的时间点，你通常需要使用`seekToTime`：</div><div class="line"></div><div class="line">```objc</div><div class="line">	CMTime fiveSecondsIn = CMTimeMake(5,1);</div><div class="line">	[player seekToTime: fiveSecondsIn];</div><div class="line">```    </div><div class="line"></div><div class="line">然而，这个`seekToTime:`方法不是很精确，尽管其性能较高。如果你要精确得移动这个`playhead`，你可以使用下面的`seekToTime:toleranceBefore:toleranceAfter:`方法。</div><div class="line"></div><div class="line">```objc</div><div class="line">	CMTime fiveSecondsIn = CMTimeMake(5,1);</div><div class="line">	[player seekToTime: fiveSecondsIn toleranceBefore: kCMTimeZero toleranceAfter: kCMTimeZero];</div><div class="line">```  </div><div class="line"></div><div class="line">上面的例子中将`tolerance`设置为零需要框架解码大量的数据。因此，仅仅在必要的时候再使用零，比如：你需要写一个精确的媒体编辑应用，它需要精确的控制。</div><div class="line"></div><div class="line">在视频播放之后，player的head被设定在了item的尾部，因此接下来调用`play`操作是不起作用的。为了将playhead放到item的起始位置，你需要注册一个item的`AVPlayerItemDidPlayToEndTimeNotification`通知，在该通知的回调方法中，你调用`seekToTime:`方法，并且传入`kCMTimeZero`参数。</div><div class="line"></div><div class="line">```objc</div><div class="line">	    // Register with the notification center after creating the player item.</div><div class="line">	    [[NSNotificationCenter defaultCenter]</div><div class="line">	        addObserver:self</div><div class="line">	        selector:@selector(playerItemDidReachEnd:)</div><div class="line">	        name:AVPlayerItemDidPlayToEndTimeNotification</div><div class="line">	        object:&lt;#The player item#&gt;];</div><div class="line">	        </div><div class="line">	    - (void)playerItemDidReachEnd:(NSNotification *)notification &#123;</div><div class="line">	    [player seekToTime:kCMTimeZero];</div><div class="line">	 &#125; </div><div class="line">```  </div><div class="line"></div><div class="line">## 很多Item的播放</div><div class="line"></div><div class="line">你可以使用`AVQueuePlayer`对象来播放一系列的`item`。这个`AVQueuePlayer`类是`AVPlayer`类的子类。通过一个`item`的数组，你可以初始化一个`queue player`。</div><div class="line"></div><div class="line">```objc</div><div class="line">	NSArray *items = &lt;#An array of player items#&gt;;</div><div class="line">	AVQueuePlayer *queuePlayer = [[AVQueuePlayer alloc] initWithItems:items];</div><div class="line">```   </div><div class="line"></div><div class="line">然后调用其`play`方法即可。这个player会按序播放这些`item`。如果不想播放某个`item`可以调用它的`advanceToNextItem`方法。</div><div class="line">可以使用`insertTtem:afterItem:`，`removeItem:`，以及`removeAllItems`方法，如果要插入一个item，你需要首先调用`canInsertItem：afterItem:`方法来确定它是否可以插入到这个`queue`中。你可以传给第二个参数`nil`，来检测是否新的`item`可以被加到`queue`的后面。</div><div class="line"></div><div class="line">```objc</div><div class="line">	AVPlayerItem *anItem = &lt;#Get a player item#&gt;;</div><div class="line">	if ([queuePlayer canInsertItem:anItem afterItem:nil]) &#123;</div><div class="line">	    [queuePlayer insertItem:anItem afterItem:nil];</div><div class="line">	&#125;</div><div class="line">```   </div><div class="line"></div><div class="line">## 监控视频播放</div><div class="line"></div><div class="line">你可以监控正在player的显示状态以及其正在播放的item的各个方面。这对你所不能控制的状态改变来说是极其有益的，比如：</div><div class="line"></div><div class="line">* 比如如果用户使用多任务操作来切换应用，那么一个player的`rate`属性就会掉到0.0;</div><div class="line">* 如果你正在播放一个远程的媒体，一个player item的`loadedTimeRangs`和`seekableTimeRanges`属性就会在更多的数据变得可用的时候改变。这些属性告诉你这些player item的那些部分是可用的。</div><div class="line">* 在HTTP直播流被创建的时候，player item的`tracks`属性就会改变。如果这个视频流对内容提供了不同的编码格式，那么这就会发生；在player切换不同的编码的时候，这个`tracks`就改变了。</div><div class="line">* 如果一个视频播放失败，那么这个player或者player item的`status`属性可能会改变。</div><div class="line"></div><div class="line">你可以使用KVO来监控这些属性值的改变。</div><div class="line"></div><div class="line">&gt;你应该将注册KVO以及取消注册KVO都放到主线程中。这样，如果另外一个线程发生了改变，这将会避免收到部分通知的可能。尽管这些属性的变化会在其它线程上，但是AV Foundation触发`observeValueForKeyPath:ofObject:change:context:`是在主线程上。</div><div class="line"></div><div class="line">### 响应某个状态的改变</div><div class="line"></div><div class="line">当一个player或者一个player item的状态改变的时候，它发出一个KVO的变化通知。如果一个对象由于某种原因不能够被播放（比如，媒体服务被重置），其状态将会变为`AVPlayerStatusFailed`或者`AVPlayerItemStatusFailed`。在这种情况下，这个对象的`error`属性将会变为一个error 对象，这个对象中包含了其不能够播放的原因描述。</div><div class="line"></div><div class="line">AVFoundation不会指明这个通知发送的线程。如果你想改变UI，你必须要确保任何相关的代码会在主线程中执行。比如，你可以使用`dispatch_async`来在主线程中执行代码。</div><div class="line"></div><div class="line">```objc</div><div class="line">	- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object</div><div class="line">	                          change:(NSDictionary *)change context:(void *)context &#123;</div><div class="line">	      if (context == &lt;#Player status context#&gt;) &#123;</div><div class="line">	</div><div class="line">	          AVPlayer *thePlayer = (AVPlayer *)object;</div><div class="line">	          if ([thePlayer status] == AVPlayerStatusFailed) &#123;</div><div class="line">	              NSError *error = [&lt;#The AVPlayer object#&gt; error];</div><div class="line">	              // Respond to error: for example, display an alert sheet.</div><div class="line">	              return;</div><div class="line">	&#125; </div><div class="line">	          // Deal with other status change if appropriate.</div><div class="line">	      &#125;</div><div class="line">	      // Deal with other change notifications if appropriate.</div><div class="line">	      [super observeValueForKeyPath:keyPath ofObject:object</div><div class="line">	             change:change context:context];</div><div class="line">	      return;</div><div class="line">	&#125; </div><div class="line">```   </div><div class="line"></div><div class="line">### 追踪可视化播放的准备状态</div><div class="line"></div><div class="line">你可以观察`AVPlayerLayer`对象的`readyForDisplay`属性来获取当`layer`的用户可视内容改变时发出的通知。尤其重要的是，只有在用户可以看到一些东西的时候，你才可以将一个player layer插入到layer tree中，然后执行转化操作。</div><div class="line"></div><div class="line">### 追踪时间</div><div class="line"></div><div class="line">为了追踪一个`AVPlayer`对象中`playhead`的位置，你可以使用addPeriodicTimeObserverForInterval: queue: usingBlock:或者addBoundaryTimeObserverForTimes: queue: usingBlock:比如，你可以用过去的时间以及剩余的时间来更新用于界面，或者执行其它的UI同步操作。</div><div class="line"></div><div class="line">* 如果时间超过了你所指定的周期点，以及视频播放开始或者停止，这个时候`addPeriodicTimeObserverForInterval:queue:usingBlock:`将会被触发。</div><div class="line">* 你也可以指定在某些时间触发`addBoundaryTimeObserverForTimes:queue:usingBlock:`，这里你需要传递一个包含被`NSValue`封装的`CMTime`数组。</div><div class="line"></div><div class="line">如果你要想这个基于时间的`observation block`被触发，那么你必须要对这两个方法返回的对象做强引用。同时你必须在每次触发这些方法时调`removeTimeObserver:`。使用这些方法，AV Foundation不会保证在每次的时间间隔或者时间范围达到的时候都触发这些操作。如果之前的block没有执行完毕，那么AV Foundation不会执行接下来的block。因此，你必须保证在block中执行的任务不能消耗太多的CPU资源。</div><div class="line"></div><div class="line">```objc</div><div class="line">	/ Assume a property: @property (strong) id playerObserver;</div><div class="line">	</div><div class="line">	Float64 durationSeconds = CMTimeGetSeconds([&lt;#An asset#&gt; duration]);</div><div class="line">	CMTime firstThird = CMTimeMakeWithSeconds(durationSeconds/3.0, 1);</div><div class="line">	CMTime secondThird = CMTimeMakeWithSeconds(durationSeconds*2.0/3.0, 1);</div><div class="line">	NSArray *times = @[[NSValue valueWithCMTime:firstThird], [NSValue</div><div class="line">	valueWithCMTime:secondThird]];</div><div class="line">	</div><div class="line">	self.playerObserver = [&lt;#A player#&gt; addBoundaryTimeObserverForTimes:times queue:NULL usingBlock:^&#123; </div><div class="line">	NSString *timeDescription = (NSString *) CFBridgingRelease(CMTimeCopyDescription(NULL, [self.player currentTime])); </div><div class="line">	    NSLog(@"Passed a boundary at %@", timeDescription);</div><div class="line">	&#125;];</div><div class="line">```  </div><div class="line"></div><div class="line">### 某个Item结束了</div><div class="line"></div><div class="line">当一个Item播放结束的时候，你可以收到一个`AVPlayerItemDidPlayToEndTimeNotification`通知。你可以注册这个通知。</div><div class="line"></div><div class="line">```objc</div><div class="line">	[[NSNotificationCenter defaultCenter] addObserver:&lt;#The observer, typically self#&gt; selector:@selector(&lt;#The selector name#&gt;) </div><div class="line">	name: AVPlayerItemDidPlayToEndTimeNotification  object:&lt;#A player item#&gt;];</div><div class="line">```  </div><div class="line"></div><div class="line">## 综合：使用AVPlayerLayer播放一个视频文件</div><div class="line"></div><div class="line">接下来会用简单的代码实例来演示怎样使用`AVPlyer`对象来播放一个视频文件。它包含以下几部分内容：</div><div class="line"></div><div class="line">* 使用`AVPlayerLayer`来配置View</div><div class="line">* 创建一个`AVPlayer`对象</div><div class="line">* 基于视频文件创建一个`AVPlayerItem`，并且使用KVO来观察其状态</div><div class="line">* 通过使能按钮来让该Item准备播放</div><div class="line">* 播放该`Item`并且将这个播放完的Item的head重置到开始</div><div class="line"></div><div class="line">*注：为了展示最关键的代码，该实例略去了一个完整的应用所需要的功能点，比如：内存管理，注销观察者（对KVO的观察或者对某个通知的监听）。为了能够很好的使用AV Foundation，你需要对Cocoa有丰富的经验，以便处理可能遗漏的功能点。*</div><div class="line"></div><div class="line">### Player View</div><div class="line"></div><div class="line">为了播放一个Asset的可视部分，你需要一个包含了AVPlayerLayer的View以便这个AVPlayer对象的输出可以被获取。创建一个UIView的子类就可以完成这些内容：</div><div class="line"></div><div class="line">```objc   </div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">#import &lt;AVFoundation/AVFoundation.h&gt;</div><div class="line">@interface PlayerView : UIView</div><div class="line">@property (nonatomic) AVPlayer *player;</div><div class="line">@end</div><div class="line">@implementation PlayerView</div><div class="line">+ (Class)layerClass &#123;</div><div class="line">    return [AVPlayerLayer class];</div><div class="line">&#125;</div><div class="line">- (AVPlayer*)player &#123;</div><div class="line">    return [(AVPlayerLayer *)[self layer] player];</div><div class="line">&#125;</div><div class="line">- (void)setPlayer:(AVPlayer *)player &#123;</div><div class="line">    [(AVPlayerLayer *)[self layer] setPlayer:player];</div><div class="line">&#125;</div><div class="line">@end </div><div class="line">```    </div><div class="line"></div><div class="line">### 一个简单的ViewController</div><div class="line"></div><div class="line">假如你有一个类似下面的ViewController：</div><div class="line"></div><div class="line">```objc</div><div class="line">@class PlayerView;</div><div class="line">@interface PlayerViewController : UIViewController</div><div class="line"></div><div class="line">@property (nonatomic) AVPlayer *player;</div><div class="line">@property (nonatomic) AVPlayerItem *playerItem;</div><div class="line">@property (nonatomic, weak) IBOutlet PlayerView *playerView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIButton *playButton;</div><div class="line">- (IBAction)loadAssetFromFile:sender;</div><div class="line">- (IBAction)play:sender;</div><div class="line">- (void)syncUI;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个<code>syncUI</code>的方法可以将button和player的状态相同步。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line"> - (<span class="keyword">void</span>)syncUI &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.player.currentItem != <span class="literal">nil</span>) &amp;&amp;</div><div class="line">        ([<span class="keyword">self</span>.player.currentItem status] == <span class="built_in">AVPlayerItemStatusReadyToPlay</span>)) &#123;</div><div class="line">        <span class="keyword">self</span>.playButton.enabled = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">self</span>.playButton.enabled = <span class="literal">NO</span>;</div><div class="line">&#125; &#125; </div><div class="line">```   </div><div class="line"></div><div class="line">在ViewController的`viewDidLoad`方法中你可以触发这个`syncUI`来确保View在首次展示时候的用户界面是统一的。</div><div class="line"></div><div class="line">```objc </div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    [<span class="keyword">self</span> syncUI];</div><div class="line">```    </div><div class="line"></div><div class="line">其余的属性和方法将会在接下来的部分中给以描述。</div><div class="line"></div><div class="line"><span class="meta">### 创建Asset</span></div><div class="line"></div><div class="line">使用`<span class="built_in">AVURLAsset</span>`来将一个URL创建为一个Asset（接下来的例子假如你的项目包含了一个可用的Video资源）。</div><div class="line"></div><div class="line"></div><div class="line">```objc</div><div class="line">- (<span class="keyword">IBAction</span>)loadAssetFromFile:sender &#123;</div><div class="line">    <span class="built_in">NSURL</span> *fileURL = [[<span class="built_in">NSBundle</span> mainBundle]</div><div class="line">        URLForResource:&lt;<span class="meta">#@<span class="meta-string">"VideoFileName"</span>#&gt; withExtension:<span class="meta-string">&lt;#@"extension"#&gt;</span>];</span></div><div class="line">    <span class="built_in">AVURLAsset</span> *asset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:fileURL options:<span class="literal">nil</span>];</div><div class="line">    <span class="built_in">NSString</span> *tracksKey = <span class="string">@"tracks"</span>;</div><div class="line">    [asset loadValuesAsynchronouslyForKeys:@[tracksKey] completionHandler:</div><div class="line">     ^&#123;</div><div class="line">         <span class="comment">// The completion block goes here.</span></div><div class="line">     &#125;];</div><div class="line">&#125; </div><div class="line">``` </div><div class="line"></div><div class="line">在完成的Block回调中，你可以给这个asset创建一个`<span class="built_in">AVPlayerItem</span>`对象，并且将其设置为`player view`的`player`。和创建`asset`一样，仅仅创建一个`player item`并不意味着就可以立即使用了。为了确定什么时候可以播放，你需要观察`item`的`status`属性。你需要将该player item对象和player关联之前来配置这种KVO的监听。</div><div class="line"></div><div class="line">当你将player item和player关联的时候，你需要触发player item的准备。</div><div class="line"></div><div class="line">```objc  </div><div class="line"><span class="comment">// Define this constant for the key-value observation context.</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *ItemStatusContext;</div><div class="line">  <span class="comment">// Completion handler block.</span></div><div class="line">           <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),</div><div class="line">              ^&#123;</div><div class="line">                  <span class="built_in">NSError</span> *error;</div><div class="line">  </div><div class="line">error:&amp;error];</div><div class="line"><span class="built_in">AVKeyValueStatus</span> status = [asset statusOfValueForKey:tracksKey</div><div class="line"><span class="keyword">if</span> (status == <span class="built_in">AVKeyValueStatusLoaded</span>) &#123;</div><div class="line">                      <span class="keyword">self</span>.playerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:asset];</div><div class="line">                      </div><div class="line"> <span class="comment">// ensure that this is done before the playerItem is associated with the player</span></div><div class="line"> [<span class="keyword">self</span>.playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"status"</span></div><div class="line">             options:<span class="built_in">NSKeyValueObservingOptionInitial</span></div><div class="line">  context:&amp;ItemStatusContext];</div><div class="line">                      [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">  selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)</div><div class="line">  name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></div><div class="line">  object:<span class="keyword">self</span>.playerItem];</div><div class="line"><span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:<span class="keyword">self</span>.playerItem]; [<span class="keyword">self</span>.playerView setPlayer:<span class="keyword">self</span>.player]; </div><div class="line">&#125; <span class="keyword">else</span> &#123; </div><div class="line">  </div><div class="line">  <span class="comment">// You should deal with the error appropriately.</span></div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"The asset's tracks were not loaded:\n%@"</span>, [error</div><div class="line">  localizedDescription]);</div><div class="line">  &#125; </div><div class="line">&#125;); </div><div class="line">```    </div><div class="line"></div><div class="line"><span class="meta">### 响应Player Item的状态变更</span></div><div class="line">  </div><div class="line">当一个player item的状态变更的时候，这个View Controller收到一个KVO的变更通知。AV Foundation不会去指明这个通知发送到哪个线程上。如果你需要变更UI,那么你必须确保相关代码要在主线程中执行。改代码使用`diapatch_async`来将将同步UI的操作放到主线程中去。</div><div class="line"></div><div class="line">```objc   </div><div class="line"> - (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object</div><div class="line">                          change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">      <span class="keyword">if</span> (context == &amp;ItemStatusContext) &#123;</div><div class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),</div><div class="line">          ^&#123; </div><div class="line">                 [<span class="keyword">self</span> syncUI];</div><div class="line">           &#125;);</div><div class="line">     </div><div class="line">           <span class="keyword">return</span>; </div><div class="line">      &#125; </div><div class="line">      [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object</div><div class="line">             change:change context:context];</div><div class="line">       </div><div class="line">       <span class="keyword">return</span>; </div><div class="line">&#125; </div><div class="line">```    </div><div class="line"></div><div class="line"><span class="meta">### 播放该Item</span></div><div class="line"></div><div class="line">播放视频需要给player对象发送一个`play`的消息：</div><div class="line"></div><div class="line">```objc</div><div class="line">- (<span class="keyword">IBAction</span>)play:sender &#123;</div><div class="line">    [player play];</div><div class="line">&#125; </div><div class="line">```   </div><div class="line"></div><div class="line">这个Item被播放了一次。在播放完成之后，playhead被放置在item的尾部，所以如果进一步触发其`play`方法是不起作用的。为了playhead放置在item的起始位置，你可以对该item注册并收到一个`<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span>`的通知。然后在通知的会调中触发`seekToTime:`方法，传入`kCMTimeZero`参数即可：</div><div class="line"></div><div class="line">```objc</div><div class="line"><span class="comment">// Register with the notification center after creating the player item.</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter]</div><div class="line">        addObserver:<span class="keyword">self</span></div><div class="line">        selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)</div><div class="line">        name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></div><div class="line">        object:[<span class="keyword">self</span>.player currentItem]];</div><div class="line">- (<span class="keyword">void</span>)playerItemDidReachEnd:(<span class="built_in">NSNotification</span> *)notification &#123;</div><div class="line">    [<span class="keyword">self</span>.player seekToTime:kCMTimeZero];</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/04/avfoundation-asset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/04/avfoundation-asset/" itemprop="url">AVFoundation--使用Asset</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-04T23:38:03+08:00">2017-08-04</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Asset可能来自于文件，或者用户的library或者Photo。创建完Asset对象之后，你所需要的所有信息不回立马就可用。一旦你有一个movie asset，你可以从它里面抽取静态图片，转码成其它格式，或者将其内容剪切。</p>
<h2 id="新建一个Asset对象"><a href="#新建一个Asset对象" class="headerlink" title="新建一个Asset对象"></a>新建一个Asset对象</h2><p>使用一个URL，就可创建出一个Asset，使用AVURLAsset。最简单的就是从一个文件中创建一个Asset：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *url = &lt;<span class="meta">#A URL that identifies an audiovisual asset such as a movie file#&gt;;</span></div><div class="line"><span class="built_in">AVURLAsset</span> *anAsset = [[<span class="built_in">AVURLAsset</span> alloc] initWithURL:url options:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>最后的<code>options</code>参数是一个字典。唯一的key是<code>AVURLAssetPreferPreciseDurationAndTimingKey</code>它相应的Value是一个布尔值(包含在NSValue对象里)，它表明了是否这个Asset应该用来指明一个精确的持续时间提供一个精确地随机获取(provide precise random access)。<br>但是获取精确的持续时间需要提前处理很多东西。使用粗略的持续时间通常是更快捷的操作，并且这对回播来说已经足够了。因此</p>
<ul>
<li>如果你只需要播放这个Asset，那么要么传nil，要么传一个子字典，其key为<code>AVURLAssetPreferPreciseDurationAndTimingKey</code>，它相应的值为NO（NSValue对象）。</li>
<li>如果你要将该Asset进行视频合成(<code>AVMutableComposition</code>)，那么通常你需要一个精确的<code>random access</code>。将这个字典的Value值传YES(用NSValue对象)。</li>
</ul>
<p>创建方式如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *url = &lt;<span class="meta">#A URL that identifies an audiovisual asset such as a movie file#&gt;; </span></div><div class="line"><span class="built_in">NSDictionary</span> *options = @&#123; <span class="built_in">AVURLAssetPreferPreciseDurationAndTimingKey</span> :</div><div class="line">   @YES &#125;;</div><div class="line"><span class="built_in">AVURLAsset</span> *anAssetToUseInAComposition = [[<span class="built_in">AVURLAsset</span> alloc]</div><div class="line">  initWithURL:url options:options];</div></pre></td></tr></table></figure>
<h2 id="获取用户的Asset"><a href="#获取用户的Asset" class="headerlink" title="获取用户的Asset"></a>获取用户的Asset</h2><p>为了获取iPod library或者相册，你首先需要得到这个Asset的URL。</p>
<ul>
<li>为了获取iPod Library，你需要创建一个MPMediaQuery对象来找到你需要的item，然后用<code>MPMediaItemPropertyAssetURL</code>来获取其URL。</li>
<li>为了获取相册的Asset，你需要使用<code>ALAssetsLibrary</code>。</li>
</ul>
<p>下面这个例子说明了怎样获取展示在相册中的第一个视频：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">ALAssetsLibrary *library = [[ALAssetsLibrary alloc]init];</div><div class="line"> <span class="comment">// Enumerate just the photos and videos group by using ALAssetsGroupSavedPhotos.</span></div><div class="line"> [library enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">     </div><div class="line">     <span class="comment">// Within the group enumeration block, filter to enumerate just videos.</span></div><div class="line">     [group setAssetsFilter:[ALAssetsFilter allVideos]];</div><div class="line">     [group enumerateAssetsAtIndexes:[<span class="built_in">NSIndexSet</span> indexSetWithIndex:<span class="number">0</span>] options:<span class="number">0</span> usingBlock:^(ALAsset *result, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">         </div><div class="line">         <span class="keyword">if</span> (result) &#123;</div><div class="line">             </div><div class="line">             ALAssetRepresentation *represention = [result defaultRepresentation];</div><div class="line">             <span class="built_in">NSURL</span> *url = [represention url];</div><div class="line">             <span class="comment">// Do something interesting with the AV asset.</span></div><div class="line">             <span class="built_in">AVAsset</span> *avAsset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:url options:<span class="literal">nil</span>];</div><div class="line">             </div><div class="line">             </div><div class="line">         &#125;</div><div class="line">         </div><div class="line">     &#125;];</div><div class="line">     </div><div class="line"> &#125; failureBlock:^(<span class="built_in">NSError</span> *error) &#123;</div><div class="line">     </div><div class="line">     <span class="comment">// Typically you should handle an error more gracefully than this.</span></div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"No groups"</span>);</div><div class="line">     </div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>这里需要引入<code>#import &lt;AssetsLibrary/AssetsLibrary.h&gt;</code>。</p>
<h2 id="准备Asset来用"><a href="#准备Asset来用" class="headerlink" title="准备Asset来用"></a>准备Asset来用</h2><p>初始化一个Asset(或者Track)并不意味着你立即就可以使用所有的信息。它还需要时间来计算这个Asset的时长(比如：一个MP3文件可能会包含一些总结信息)。你可以遵守<code>AVAsynchronousKeyValueLoading</code>协议来异步获取其结果，这样可以不用阻塞主线程（AVSeet和AVAssetTrack都遵守<code>AVAsynchronousKeyValueLoading</code>协议）。可以使用<code>statusOfValueForKey:error:</code>来测试是否某个某个属性的值被正常加载了。首次加载的时候，它所有属性的值是<code>AVKeyValueStatusUnknown</code>。使用<code>loadValuesAsynchronouslyForKeys:completionHandler:</code>，可以加载一个或者多个属性的值。由于网络原因或者加载被取消，所以需要一直准备加载。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">ALAssetRepresentation *represention = [result defaultRepresentation];</div><div class="line">   <span class="built_in">NSURL</span> *url = [represention url];</div><div class="line">   <span class="comment">// Do something interesting with the AV asset.</span></div><div class="line">   <span class="built_in">AVAsset</span> *avAsset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:url options:<span class="literal">nil</span>];</div><div class="line">   <span class="built_in">NSArray</span> *keys = @[<span class="string">@"duration"</span>];</div><div class="line">   [avAsset loadValuesAsynchronouslyForKeys:keys completionHandler:^&#123;</div><div class="line">      </div><div class="line">       <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">       <span class="built_in">AVKeyValueStatus</span> tracksStatus = [avAsset statusOfValueForKey:<span class="string">@"duration"</span> error:&amp;error];</div><div class="line">       </div><div class="line">       <span class="keyword">switch</span> (tracksStatus) &#123;</div><div class="line">           <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusLoaded</span>:</div><div class="line">               </div><div class="line">               [<span class="keyword">self</span> updateUserInterfaceForDuration];</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusFailed</span>:</div><div class="line">               </div><div class="line">               [<span class="keyword">self</span> reportError:error forAsset:asset];</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusCancelled</span>:</div><div class="line">               <span class="comment">// Do whatever is appropriate for cancelation.</span></div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<p>如果想准备一个asset来回播，那么还需要加载它的<code>tracks</code>属性。</p>
<h2 id="从视频中获取静态图片"><a href="#从视频中获取静态图片" class="headerlink" title="从视频中获取静态图片"></a>从视频中获取静态图片</h2><p>如果想要从asset中得到了一静态的图片，例如缩略图，你需要使用<code>AVAssetImageGenerator</code>对象。使用asset初始化一个generator。尽管在初始化的时候asset不会处理不可视的track，但是初始化还是可能会失败的，这就需要在必要的时候检查是否asset有track中包含有可视化的，使用<code>tracksWithMediaCharacteristic</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">AVAsset</span> anAsset = &lt;<span class="meta">#Get an asset#&gt;;</span></div><div class="line"><span class="keyword">if</span> ([[anAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] count] &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">AVAssetImageGenerator</span> *imageGenerator =</div><div class="line">        [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:anAsset];</div><div class="line">    <span class="comment">// Implementation continues...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以对图片生成器的不同方面做不同的配置，例如可以使用maximumSize来指明其最大的尺度，使用<code>apertureMode</code>来指明孔径的模式。然后你就可以在给定的时间点来产生一张或者多张图片。<code>必须要强引用这个图片生成器否则，其会被释放掉。</code></p>
<h2 id="产生单独的一张图片"><a href="#产生单独的一张图片" class="headerlink" title="产生单独的一张图片"></a>产生单独的一张图片</h2><p>使用<code>copyCGImageAtTime:actualTime:error:</code>来产生在特定时间点的图片。AVFoundation框架可能不会在你请求的时候立即产生出一张图片，因此你可以给第二个参数传递一个指针，指向一个CMTime，该指针包含了图片实际产生的时间。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">AVAsset</span> *myAsset = &lt;<span class="meta">#An asset#&gt;];</span></div><div class="line"><span class="built_in">AVAssetImageGenerator</span> *imageGenerator = [[<span class="built_in">AVAssetImageGenerator</span> alloc]</div><div class="line">initWithAsset:myAsset];</div><div class="line">Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([myAsset duration]);</div><div class="line"><span class="built_in">CMTime</span> midpoint = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">2.0</span>, <span class="number">600</span>);</div><div class="line"><span class="built_in">NSError</span> *error;</div><div class="line"><span class="built_in">CMTime</span> actualTime;</div><div class="line"><span class="built_in">CGImageRef</span> halfWayImage = [imageGenerator copyCGImageAtTime:midpoint</div><div class="line">actualTime:&amp;actualTime error:&amp;error];</div><div class="line"><span class="keyword">if</span> (halfWayImage != <span class="literal">NULL</span>) &#123;</div><div class="line"><span class="built_in">NSString</span> *actualTimeString = (<span class="built_in">NSString</span> *)<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, actualTime); </div><div class="line">    <span class="built_in">NSString</span> *requestedTimeString = (<span class="built_in">NSString</span> *)<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>,</div><div class="line">midpoint);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Got halfWayImage: Asked for %@, got %@"</span>, requestedTimeString,</div><div class="line">actualTimeString);</div><div class="line">    <span class="comment">// Do something interesting with the image.</span></div><div class="line">    <span class="built_in">CGImageRelease</span>(halfWayImage);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="产生一系列的图片"><a href="#产生一系列的图片" class="headerlink" title="产生一系列的图片"></a>产生一系列的图片</h3><p>为了产生一系列的图片，你应该调用图片生成器的<code>generateCGImagesAsynchronouslyForTimes:completionHandler:</code>方法，第一个参数是一个包含NSValue对象的数组，NSValue对象是由<code>CMTime</code>生成的，它指明了你需要生成的图片所在的时间点。第二个参数是每个图片生成之后的回调。其中包含的字段包括</p>
<ul>
<li>图片</li>
<li>请求图片的时间和图片生成的真实时间</li>
<li>失败时候错误信息的error对象</li>
</ul>
<p>在实现block的过程中，需要检测结果来决定图片是否生成了。除此之外：<strong>在生成图片之前要一直强引用这个图片生成器</strong>。</p>
<pre><code class="objc"><span class="built_in">AVAsset</span> *myAsset = <span class="literal">nil</span>;
<span class="keyword">self</span>.imageGenerator = [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:myAsset]; 
Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([myAsset duration]);
<span class="built_in">CMTime</span> firstThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">3.0</span>, <span class="number">600</span>);
<span class="built_in">CMTime</span> secondThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds*<span class="number">2.0</span>/<span class="number">3.0</span>, <span class="number">600</span>);
<span class="built_in">CMTime</span> end = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds, <span class="number">600</span>);
<span class="built_in">NSArray</span> *times = @[ <span class="built_in">NSValue</span> valueWithCMTime:kCMTimeZero],
                    [<span class="built_in">NSValue</span> valueWithCMTime:firstThird], 
                    [<span class="built_in">NSValue</span> valueWithCMTime:secondThird],
                    [<span class="built_in">NSValue</span> valueWithCMTime:end]];
[imageGenerator generateCGImagesAsynchronouslyForTimes:times completionHandler:^(<span class="built_in">CMTime</span> requestedTime, <span class="built_in">CGImageRef</span> image, <span class="built_in">CMTime</span> actualTime,
<span class="built_in">AVAssetImageGeneratorResult</span> result, <span class="built_in">NSError</span> *error) {
<span class="built_in">NSString</span> *requestedTimeString = (<span class="built_in">NSString</span> *) <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, requestedTime));
<span class="built_in">NSString</span> *actualTimeString = (<span class="built_in">NSString</span> *)
                      <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, actualTime));
 <span class="built_in">NSLog</span>(<span class="string">@"Requested: %@; actual %@"</span>, requestedTimeString, actualTimeString);

<span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorSucceeded</span>) {
    <span class="comment">// Do something interesting with the image.</span>
} 
<span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorFailed</span>) { <span class="built_in">NSLog</span>(<span class="string">@"Failed with error: %@"</span>, [error localizedDescription]); 
}
<span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorCancelled</span>) {
    <span class="built_in">NSLog</span>(<span class="string">@"Canceled"</span>);
}
}];
</code></pre>
<p>如果想要在中途终止图片序列的生成，可以调用<code>cancelAllCGImageGeneration</code>方法。</p>
<h3 id="视频的裁剪和转码"><a href="#视频的裁剪和转码" class="headerlink" title="视频的裁剪和转码"></a>视频的裁剪和转码</h3><p>使用<code>AVAssetExportSession</code>对象，可以将视频从一种格式到另一种格式进行转码，并且可以裁剪视频。一个export session是一个控制器对象，它管理着一个asset的异步输出。你可以将想要输出的asset以及输出的用来表明输出选项的<code>preset</code>来初始化一个<code>session</code>。然后你可以配置这个输出的session来指明输入的URL，以及文件格式，以及其它设置的一些可选配置，如metadata，以及是否输出需要被优化。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-7454ffe396927bff.png" alt="视频转码"><br>可以使用<code>exportPresetsCompatibleWithAsset:</code>来检测你是否可以输出一种给定的<code>asset</code>，如下所示</p>
<pre><code class="objc"><span class="built_in">AVAsset</span> *anAsset = &lt;<span class="meta">#Get an asset#&gt;;</span>
<span class="built_in">NSArray</span> *compatiblePresets = [<span class="built_in">AVAssetExportSession</span>
exportPresetsCompatibleWithAsset:anAsset];
<span class="keyword">if</span> ([compatiblePresets containsObject:<span class="built_in">AVAssetExportPresetLowQuality</span>]) {
    <span class="built_in">AVAssetExportSession</span> *exportSession = [[<span class="built_in">AVAssetExportSession</span> alloc]
        initWithAsset:anAsset presetName:<span class="built_in">AVAssetExportPresetLowQuality</span>];
    <span class="comment">// Implementation continues.</span>
}
</code></pre>
<p>你可以通过提供输出的URL(该URL必须是一个文件的URL)来配置这个session，<code>AVAssetExportSession</code>可以根据输出的<code>URL</code>的路径扩展，来推断需要输出的文件类型；然而也可以通过使用<code>outputFileType</code>直接进行配置。你也可以指明一些其它的属性，比如时间范围，输出长度的限制，是否输出的文件需要被优化来作为网络使用，以及一个视频的合成。下面的例子说明了如何使用<code>timeRange</code>属性来裁剪视频：</p>
<pre><code class="objc">exportSession.outputURL = &lt;<span class="meta">#A file URL#&gt;;</span>
exportSession.outputFileType = <span class="built_in">AVFileTypeQuickTimeMovie</span>;
<span class="built_in">CMTime</span> start = <span class="built_in">CMTimeMakeWithSeconds</span>(<span class="number">1.0</span>, <span class="number">600</span>);
<span class="built_in">CMTime</span> duration = <span class="built_in">CMTimeMakeWithSeconds</span>(<span class="number">3.0</span>, <span class="number">600</span>);
<span class="built_in">CMTimeRange</span> range = <span class="built_in">CMTimeRangeMake</span>(start, duration);
exportSession.timeRange = range;
</code></pre>
<p>调用<code>exportAsynchronouslyWithCompletionHandler:</code>方法可以用来创建一个新的文件。当输出操作结束的时候这个文成的block将会被回调。如果你要处理这个回调，那么你需要检测这个seesion的<code>status</code>值来确定是否这次输出是成功的，失败的，或者是被取消的。</p>
<pre><code class="objc">[exportSession exportAsynchronouslyWithCompletionHandler:^{
          <span class="keyword">switch</span> ([exportSession status]) {
              <span class="keyword">case</span> <span class="built_in">AVAssetExportSessionStatusFailed</span>:
                  <span class="built_in">NSLog</span>(<span class="string">@"Export failed: %@"</span>, [[exportSession error]
  localizedDescription]);
                  <span class="keyword">break</span>;
              <span class="keyword">case</span> <span class="built_in">AVAssetExportSessionStatusCancelled</span>:
                  <span class="built_in">NSLog</span>(<span class="string">@"Export canceled"</span>);
                  <span class="keyword">break</span>;
              <span class="keyword">default</span>:
<span class="keyword">break</span>; } 
}];
</code></pre>
<p>通过调用session的<code>cancelExport</code>方法，可以取消某次输出。<br>如果你试图往一个已经存在的文件中重复写入，或者往应用的沙盒之外的其它地方写文件，那么将会造成输出文件失败。下面的情况也会造成输出失败：</p>
<ul>
<li>电话呼入</li>
<li>你的应用推到了后台，同时另一个应用也开始执行回播</li>
</ul>
<p>这种情况下，你需要提醒用户输出失败，以便其可以重新输出。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mikefighting.github.io/2017/08/04/avfoundation-introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="击水湘江">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="击水湘江">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/04/avfoundation-introduction/" itemprop="url">AVFoundation--简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-04T23:37:34+08:00">2017-08-04</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AVFoundation是很多处理基于时间的音视频文件的框架之一。你可以用它来检查，创建，编辑或者对媒体文件重编码。可以从设备中得到输入流，以及在实时捕捉和播放的时候对视频进行处理。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1513759-d41cc62c5bec457a.png" alt="AVFoundation"></p>
<ul>
<li>如果你仅仅需要播放视频，在IOS上你可以使用Media Player框架中的<code>MPMoviePlayerController</code>或者<code>MPMoviePlayerViewController</code>，如果是基于Web的视频，那么你可以使用<code>UIWebView</code>。</li>
<li>为了录制视频，并且几乎不需要关注其格式，那么你可以使用UIKit框架中的<code>UIImagePickerController</code>。</li>
</ul>
<p>然而请注意：在AVFoundation中使用的一些原始数据（包括基于时间的数据结构以及携带及包含媒体信息的封装对象）都是在<code>Core Media</code>框架中声明的。</p>
<h1 id="AVFoundation框架简介"><a href="#AVFoundation框架简介" class="headerlink" title="AVFoundation框架简介"></a>AVFoundation框架简介</h1><p>AV Foundation中有两个方面的API(处理视频的和处理音频的)。</p>
<ul>
<li>使用<code>AVAudioPlayer</code>来播放音频文件</li>
<li>使用<code>AVAudioRecorder</code>来录制音频文件</li>
</ul>
<p>你可以通过<code>AVAudioSessin</code>对象来对配置音频的播放行为，相关配置可以参考：<code>Audio Session Programming Guide</code>。</p>
<p>AVFoundation中用来代表媒体信息的关键类是AVAsset。该框架的大部分功能都是有AVAsset来表现的。理解AVAsset将有助于理解整个框架是如何工作的。AVAsset是一片或者多片媒体数据的集合。它统一提供这个集合的信息，包括其标题，时长，自然表现大小（natural presentation size）等。一个AVAsset不合具体的数据格式相绑定。AVAsset是其它用URL来创建asset实例的父类。<br>asset中的每一个独立媒体片是一个统一的类型并且其成为<code>track</code>。</p>
<h2 id="使用Assets"><a href="#使用Assets" class="headerlink" title="使用Assets"></a>使用Assets</h2><p>AVAsset是AVFoundation的基础类。AVFoundation框架的设计很大程度上都是通过这个类来表现的。它提供了视频的名称，时间，正常展示的大小(natural presentation size)。AVAsset没有和具体的数据形式相绑定。AVAsset是从一个<code>URL</code>来创建出Asset实例的父类，并且可以创建出新的组合。每个asset中独立的视频片段都是统一的类型叫做<code>track</code>。一般情况下：一个track代表音频成分，一个track代表视频成分。很重要的一点是：初始化一个asset并不意味着立即就可以用。它还需要一些时间来计算。但是这种计算不会阻塞主线程，他会异步的执行。</p>
<h2 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h2><p><code>presentation state</code>是由<code>player item</code>对象管理的，某个track的<code>presentation state</code>是由<code>player item track</code>对象管理的。你可以使用<code>player</code>对象来播放，并且直接将其输出到<code>Core Animation</code>上。可以使用一个<code>player queue</code>有续地来管理一系列的<code>player items</code>。</p>
<h2 id="读，写以及重新编码Asset"><a href="#读，写以及重新编码Asset" class="headerlink" title="读，写以及重新编码Asset"></a>读，写以及重新编码<code>Asset</code></h2><p>AV Foundation让你给一个Asset用不同的方式创建出新的展示。你可以仅仅对一个已经存在的asset进行重编码（ios4.1之后），你可以在一个asset的内容上执行不同的操作，然后将结果用新的asset来存储。将一种表现转化成其他类型的表现，可以使用<code>asset reader</code>和<code>asset writer</code>来串联两个视频动画。</p>
<h2 id="缩略图"><a href="#缩略图" class="headerlink" title="缩略图"></a>缩略图</h2><p>使用<code>AVAssetImageGenerator</code>对象可以来创建缩略图。编辑，AV Foundation使用<code>compositions</code>来从现有的媒体片段中新建assets。可以设置相对volume，音频<code>track ramp</code>，设置透明度。</p>
<h2 id="Media捕捉和使用Camera"><a href="#Media捕捉和使用Camera" class="headerlink" title="Media捕捉和使用Camera"></a>Media捕捉和使用Camera</h2><p>可以使用<code>preview player</code>来展示camera录制的内容。</p>
<h2 id="AV-Foundation和多线程并发"><a href="#AV-Foundation和多线程并发" class="headerlink" title="AV Foundation和多线程并发"></a>AV Foundation和多线程并发</h2><p>有两点需要注意的：</p>
<ul>
<li>UI相关的通知应该在主线程中触发。</li>
<li>需要自己明确指定类和方法所在线程的话会在响应的线程中年触发通知</li>
</ul>
<p>如果要开发多线程的应用，那么你应该使用<code>isMainThread</code>或者<code>[[NSThread currentThread] isEqual:&lt;#A stored thread reference#&gt;]</code>来提前测试是否该线程是你期望的要执行的线程。如果要跨线程，你可能需要如下方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">performSelectorOnMainThread:withObject:waitUntilDone: </div><div class="line">performSelector:onThread:withObject:waitUntilDone:modes:</div><div class="line"><span class="built_in">dispatch_async</span></div></pre></td></tr></table></figure>
<p>为了更好的开发AVFoundation，你需要具备如下前提知识：</p>
<ul>
<li>全面理解基础的Cocoa开发工具及技术</li>
<li>基本理解Block</li>
<li>基本理解KVC和KVO</li>
<li>对于视频回播，需要理解合理动画，对于基本的回播，需要理解AV Kit框架参考手册</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">击水湘江</p>
              <p class="site-description motion-element" itemprop="description">努力让明天的自己爱上今天的自己！</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">38</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">击水湘江</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.3"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
